<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 11.2.0"/>
    <title>pygel3d.hmesh API documentation</title>

    <style>/*! * Bootstrap Reboot v5.0.0 (https://getbootstrap.com/) * Copyright 2011-2021 The Bootstrap Authors * Copyright 2011-2021 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus:not(:focus-visible){outline:0}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}select:disabled{opacity:1}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>
    <style>/*! syntax-highlighting.css */pre{line-height:125%;}span.linenos{color:inherit; background-color:transparent; padding-left:5px; padding-right:20px;}.pdoc-code .hll{background-color:#ffffcc}.pdoc-code{background:#f8f8f8;}.pdoc-code .c{color:#3D7B7B; font-style:italic}.pdoc-code .err{border:1px solid #FF0000}.pdoc-code .k{color:#008000; font-weight:bold}.pdoc-code .o{color:#666666}.pdoc-code .ch{color:#3D7B7B; font-style:italic}.pdoc-code .cm{color:#3D7B7B; font-style:italic}.pdoc-code .cp{color:#9C6500}.pdoc-code .cpf{color:#3D7B7B; font-style:italic}.pdoc-code .c1{color:#3D7B7B; font-style:italic}.pdoc-code .cs{color:#3D7B7B; font-style:italic}.pdoc-code .gd{color:#A00000}.pdoc-code .ge{font-style:italic}.pdoc-code .gr{color:#E40000}.pdoc-code .gh{color:#000080; font-weight:bold}.pdoc-code .gi{color:#008400}.pdoc-code .go{color:#717171}.pdoc-code .gp{color:#000080; font-weight:bold}.pdoc-code .gs{font-weight:bold}.pdoc-code .gu{color:#800080; font-weight:bold}.pdoc-code .gt{color:#0044DD}.pdoc-code .kc{color:#008000; font-weight:bold}.pdoc-code .kd{color:#008000; font-weight:bold}.pdoc-code .kn{color:#008000; font-weight:bold}.pdoc-code .kp{color:#008000}.pdoc-code .kr{color:#008000; font-weight:bold}.pdoc-code .kt{color:#B00040}.pdoc-code .m{color:#666666}.pdoc-code .s{color:#BA2121}.pdoc-code .na{color:#687822}.pdoc-code .nb{color:#008000}.pdoc-code .nc{color:#0000FF; font-weight:bold}.pdoc-code .no{color:#880000}.pdoc-code .nd{color:#AA22FF}.pdoc-code .ni{color:#717171; font-weight:bold}.pdoc-code .ne{color:#CB3F38; font-weight:bold}.pdoc-code .nf{color:#0000FF}.pdoc-code .nl{color:#767600}.pdoc-code .nn{color:#0000FF; font-weight:bold}.pdoc-code .nt{color:#008000; font-weight:bold}.pdoc-code .nv{color:#19177C}.pdoc-code .ow{color:#AA22FF; font-weight:bold}.pdoc-code .w{color:#bbbbbb}.pdoc-code .mb{color:#666666}.pdoc-code .mf{color:#666666}.pdoc-code .mh{color:#666666}.pdoc-code .mi{color:#666666}.pdoc-code .mo{color:#666666}.pdoc-code .sa{color:#BA2121}.pdoc-code .sb{color:#BA2121}.pdoc-code .sc{color:#BA2121}.pdoc-code .dl{color:#BA2121}.pdoc-code .sd{color:#BA2121; font-style:italic}.pdoc-code .s2{color:#BA2121}.pdoc-code .se{color:#AA5D1F; font-weight:bold}.pdoc-code .sh{color:#BA2121}.pdoc-code .si{color:#A45A77; font-weight:bold}.pdoc-code .sx{color:#008000}.pdoc-code .sr{color:#A45A77}.pdoc-code .s1{color:#BA2121}.pdoc-code .ss{color:#19177C}.pdoc-code .bp{color:#008000}.pdoc-code .fm{color:#0000FF}.pdoc-code .vc{color:#19177C}.pdoc-code .vg{color:#19177C}.pdoc-code .vi{color:#19177C}.pdoc-code .vm{color:#19177C}.pdoc-code .il{color:#666666}</style>
    <style>/*! theme.css */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f8f8f8;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}</style>
    <style>/*! layout.css */html, body{width:100%;height:100%;}html, main{scroll-behavior:smooth;}body{background-color:var(--pdoc-background);}@media (max-width:769px){#navtoggle{cursor:pointer;position:absolute;width:50px;height:40px;top:1rem;right:1rem;border-color:var(--text);color:var(--text);display:flex;opacity:0.8;}#navtoggle:hover{opacity:1;}#togglestate + div{display:none;}#togglestate:checked + div{display:inherit;}main, header{padding:2rem 3vw;}header + main{margin-top:-3rem;}.git-button{display:none !important;}nav input[type="search"]{max-width:77%;}nav input[type="search"]:first-child{margin-top:-6px;}nav input[type="search"]:valid ~ *{display:none !important;}}@media (min-width:770px){:root{--sidebar-width:clamp(12.5rem, 28vw, 22rem);}nav{position:fixed;overflow:auto;height:100vh;width:var(--sidebar-width);}main, header{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);width:calc(54rem + var(--sidebar-width));max-width:100%;}header + main{margin-top:-4rem;}#navtoggle{display:none;}}#togglestate{position:absolute;height:0;}nav.pdoc{--pad:clamp(0.5rem, 2vw, 1.75rem);--indent:1.5rem;background-color:var(--accent);border-right:1px solid var(--accent2);box-shadow:0 0 20px rgba(50, 50, 50, .2) inset;padding:0 0 0 var(--pad);overflow-wrap:anywhere;scrollbar-width:thin; scrollbar-color:var(--accent2) transparent }nav.pdoc::-webkit-scrollbar{width:.4rem; }nav.pdoc::-webkit-scrollbar-thumb{background-color:var(--accent2); }nav.pdoc > div{padding:var(--pad) 0;}nav.pdoc .module-list-button{display:inline-flex;align-items:center;color:var(--text);border-color:var(--muted);margin-bottom:1rem;}nav.pdoc .module-list-button:hover{border-color:var(--text);}nav.pdoc input[type=search]{display:block;outline-offset:0;width:calc(100% - var(--pad));}nav.pdoc .logo{max-width:calc(100% - var(--pad));max-height:35vh;display:block;margin:0 auto 1rem;transform:translate(calc(-.5 * var(--pad)), 0);}nav.pdoc ul{list-style:none;padding-left:0;}nav.pdoc > div > ul{margin-left:calc(0px - var(--pad));}nav.pdoc li a{padding:.2rem 0 .2rem calc(var(--pad) + var(--indent));}nav.pdoc > div > ul > li > a{padding-left:var(--pad);}nav.pdoc li{transition:all 100ms;}nav.pdoc li:hover{background-color:var(--nav-hover);}nav.pdoc a, nav.pdoc a:hover{color:var(--text);}nav.pdoc a{display:block;}nav.pdoc > h2:first-of-type{margin-top:1.5rem;}nav.pdoc .class:before{content:"class ";color:var(--muted);}nav.pdoc .function:after{content:"()";color:var(--muted);}nav.pdoc footer:before{content:"";display:block;width:calc(100% - var(--pad));border-top:solid var(--accent2) 1px;margin-top:1.5rem;padding-top:.5rem;}nav.pdoc footer{font-size:small;}</style>
    <style>/*! content.css */.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .pdoc-alert{padding:1rem 1rem 1rem calc(1.5rem + 24px);border:1px solid transparent;border-radius:.25rem;background-repeat:no-repeat;background-position:1rem center;margin-bottom:1rem;}.pdoc .pdoc-alert > *:last-child{margin-bottom:0;}.pdoc .pdoc-alert-note {color:#084298;background-color:#cfe2ff;border-color:#b6d4fe;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2224%22%20height%3D%2224%22%20fill%3D%22%23084298%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M8%2016A8%208%200%201%200%208%200a8%208%200%200%200%200%2016zm.93-9.412-1%204.705c-.07.34.029.533.304.533.194%200%20.487-.07.686-.246l-.088.416c-.287.346-.92.598-1.465.598-.703%200-1.002-.422-.808-1.319l.738-3.468c.064-.293.006-.399-.287-.47l-.451-.081.082-.381%202.29-.287zM8%205.5a1%201%200%201%201%200-2%201%201%200%200%201%200%202z%22/%3E%3C/svg%3E");}.pdoc .pdoc-alert-warning{color:#664d03;background-color:#fff3cd;border-color:#ffecb5;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2224%22%20height%3D%2224%22%20fill%3D%22%23664d03%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M8.982%201.566a1.13%201.13%200%200%200-1.96%200L.165%2013.233c-.457.778.091%201.767.98%201.767h13.713c.889%200%201.438-.99.98-1.767L8.982%201.566zM8%205c.535%200%20.954.462.9.995l-.35%203.507a.552.552%200%200%201-1.1%200L7.1%205.995A.905.905%200%200%201%208%205zm.002%206a1%201%200%201%201%200%202%201%201%200%200%201%200-2z%22/%3E%3C/svg%3E");}.pdoc .pdoc-alert-danger{color:#842029;background-color:#f8d7da;border-color:#f5c2c7;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2224%22%20height%3D%2224%22%20fill%3D%22%23842029%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M5.52.359A.5.5%200%200%201%206%200h4a.5.5%200%200%201%20.474.658L8.694%206H12.5a.5.5%200%200%201%20.395.807l-7%209a.5.5%200%200%201-.873-.454L6.823%209.5H3.5a.5.5%200%200%201-.48-.641l2.5-8.5z%22/%3E%3C/svg%3E");}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc > section:not(.module-info) h1{font-size:1.5rem;font-weight:500;}.pdoc > section:not(.module-info) h2{font-size:1.4rem;font-weight:500;}.pdoc > section:not(.module-info) h3{font-size:1.3rem;font-weight:500;}.pdoc > section:not(.module-info) h4{font-size:1.2rem;}.pdoc > section:not(.module-info) h5{font-size:1.1rem;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-top:0;margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;background-color:var(--code);}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc > section:not(.module-info){margin-bottom:1.5rem;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.pdoc details{filter:opacity(1);}.pdoc details:not([open]){height:0;}.pdoc details > summary{position:absolute;top:-35px;right:0;font-size:.75rem;color:var(--muted);padding:0 .7em;user-select:none;cursor:pointer;}.pdoc details > summary:focus{outline:0;}.pdoc > section.module-info details > summary{top:-20px;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc section:not(.module-info) .docstring{margin-left:clamp(0rem, 5vw - 2rem, 1rem);}.pdoc .docstring .pdoc-code{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target,.pdoc .pdoc-code > pre > span:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc .pdoc-code > pre > span:target{display:block;}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc *{scroll-margin:2rem;}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc .headerlink{position:absolute;width:0;margin-left:-1.5rem;line-height:1.4rem;font-size:1.5rem;font-weight:normal;transition:all 100ms ease-in-out;opacity:0;user-select:none;}.pdoc .attr > .headerlink{margin-left:-2.5rem;}.pdoc *:hover > .headerlink,.pdoc *:target > .attr > .headerlink{opacity:1;}.pdoc .attr{display:block;color:var(--text);margin:.5rem 0 .5rem;padding:.4rem 5rem .4rem 1rem;background-color:var(--accent);}.pdoc .classattr{margin-left:2rem;}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{white-space:pre-wrap;}.pdoc .annotation{color:var(--annotation);}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .search-result .docstring{overflow:auto;max-height:25vh;}.pdoc .search-result.focused > .attr{background-color:var(--active);}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}.pdoc table{display:block;width:max-content;max-width:100%;overflow:auto;margin-bottom:1rem;}.pdoc table th{font-weight:600;}.pdoc table th, .pdoc table td{padding:6px 13px;border:1px solid var(--accent2);}</style>
    <style>/*! custom.css */</style></head>
<body>
    <nav class="pdoc">
        <label id="navtoggle" for="togglestate" class="pdoc-button"><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke-linecap='round' stroke="currentColor" stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg></label>
        <input id="togglestate" type="checkbox" aria-hidden="true" tabindex="-1">
        <div>            <a class="pdoc-button module-list-button" href="../pygel3d.html">
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-box-arrow-in-left" viewBox="0 0 16 16">
  <path fill-rule="evenodd" d="M10 3.5a.5.5 0 0 0-.5-.5h-8a.5.5 0 0 0-.5.5v9a.5.5 0 0 0 .5.5h8a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 1 1 0v2A1.5 1.5 0 0 1 9.5 14h-8A1.5 1.5 0 0 1 0 12.5v-9A1.5 1.5 0 0 1 1.5 2h8A1.5 1.5 0 0 1 11 3.5v2a.5.5 0 0 1-1 0v-2z"/>
  <path fill-rule="evenodd" d="M4.146 8.354a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H14.5a.5.5 0 0 1 0 1H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3z"/>
</svg>                &nbsp;pygel3d</a>


            <input type="search" placeholder="Search..." role="searchbox" aria-label="search"
                   pattern=".+" required>



        <h2>API Documentation</h2>
            <ul class="memberlist">
            <li>
                    <a class="class" href="#Manifold">Manifold</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#Manifold.__init__">Manifold</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.from_triangles">from_triangles</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.from_points">from_points</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.add_face">add_face</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.positions">positions</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.no_allocated_vertices">no_allocated_vertices</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.no_allocated_faces">no_allocated_faces</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.no_allocated_halfedges">no_allocated_halfedges</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.vertices">vertices</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.faces">faces</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.halfedges">halfedges</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.circulate_vertex">circulate_vertex</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.circulate_face">circulate_face</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.next_halfedge">next_halfedge</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.prev_halfedge">prev_halfedge</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.opposite_halfedge">opposite_halfedge</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.incident_face">incident_face</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.incident_vertex">incident_vertex</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.remove_vertex">remove_vertex</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.remove_face">remove_face</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.remove_edge">remove_edge</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.vertex_in_use">vertex_in_use</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.face_in_use">face_in_use</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.halfedge_in_use">halfedge_in_use</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.flip_edge">flip_edge</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.collapse_edge">collapse_edge</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.split_face_by_edge">split_face_by_edge</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.split_face_by_vertex">split_face_by_vertex</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.split_edge">split_edge</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.stitch_boundary_edges">stitch_boundary_edges</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.merge_faces">merge_faces</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.close_hole">close_hole</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.cleanup">cleanup</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.is_halfedge_at_boundary">is_halfedge_at_boundary</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.is_vertex_at_boundary">is_vertex_at_boundary</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.edge_length">edge_length</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.valency">valency</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.vertex_normal">vertex_normal</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.connected">connected</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.no_edges">no_edges</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.face_normal">face_normal</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.area">area</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.perimeter">perimeter</a>
                        </li>
                        <li>
                                <a class="function" href="#Manifold.centre">centre</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="function" href="#valid">valid</a>
            </li>
            <li>
                    <a class="function" href="#closed">closed</a>
            </li>
            <li>
                    <a class="function" href="#bbox">bbox</a>
            </li>
            <li>
                    <a class="function" href="#bsphere">bsphere</a>
            </li>
            <li>
                    <a class="function" href="#stitch">stitch</a>
            </li>
            <li>
                    <a class="function" href="#obj_save">obj_save</a>
            </li>
            <li>
                    <a class="function" href="#off_save">off_save</a>
            </li>
            <li>
                    <a class="function" href="#x3d_save">x3d_save</a>
            </li>
            <li>
                    <a class="function" href="#obj_load">obj_load</a>
            </li>
            <li>
                    <a class="function" href="#off_load">off_load</a>
            </li>
            <li>
                    <a class="function" href="#ply_load">ply_load</a>
            </li>
            <li>
                    <a class="function" href="#x3d_load">x3d_load</a>
            </li>
            <li>
                    <a class="function" href="#load">load</a>
            </li>
            <li>
                    <a class="function" href="#save">save</a>
            </li>
            <li>
                    <a class="function" href="#remove_caps">remove_caps</a>
            </li>
            <li>
                    <a class="function" href="#remove_needles">remove_needles</a>
            </li>
            <li>
                    <a class="function" href="#close_holes">close_holes</a>
            </li>
            <li>
                    <a class="function" href="#flip_orientation">flip_orientation</a>
            </li>
            <li>
                    <a class="function" href="#merge_coincident_boundary_vertices">merge_coincident_boundary_vertices</a>
            </li>
            <li>
                    <a class="function" href="#minimize_curvature">minimize_curvature</a>
            </li>
            <li>
                    <a class="function" href="#minimize_dihedral_angle">minimize_dihedral_angle</a>
            </li>
            <li>
                    <a class="function" href="#maximize_min_angle">maximize_min_angle</a>
            </li>
            <li>
                    <a class="function" href="#optimize_valency">optimize_valency</a>
            </li>
            <li>
                    <a class="function" href="#randomize_mesh">randomize_mesh</a>
            </li>
            <li>
                    <a class="function" href="#quadric_simplify">quadric_simplify</a>
            </li>
            <li>
                    <a class="function" href="#average_edge_length">average_edge_length</a>
            </li>
            <li>
                    <a class="function" href="#median_edge_length">median_edge_length</a>
            </li>
            <li>
                    <a class="function" href="#refine_edges">refine_edges</a>
            </li>
            <li>
                    <a class="function" href="#cc_split">cc_split</a>
            </li>
            <li>
                    <a class="function" href="#loop_split">loop_split</a>
            </li>
            <li>
                    <a class="function" href="#root3_subdivide">root3_subdivide</a>
            </li>
            <li>
                    <a class="function" href="#rootCC_subdivide">rootCC_subdivide</a>
            </li>
            <li>
                    <a class="function" href="#butterfly_subdivide">butterfly_subdivide</a>
            </li>
            <li>
                    <a class="function" href="#cc_smooth">cc_smooth</a>
            </li>
            <li>
                    <a class="function" href="#loop_smooth">loop_smooth</a>
            </li>
            <li>
                    <a class="function" href="#triangulate">triangulate</a>
            </li>
            <li>
                    <a class="class" href="#MeshDistance">MeshDistance</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#MeshDistance.__init__">MeshDistance</a>
                        </li>
                        <li>
                                <a class="function" href="#MeshDistance.signed_distance">signed_distance</a>
                        </li>
                        <li>
                                <a class="function" href="#MeshDistance.ray_inside_test">ray_inside_test</a>
                        </li>
                </ul>

            </li>
    </ul>



        <a class="attribution" title="pdoc: Python API documentation generator" href="https://pdoc.dev" target="_blank">
            built with <span class="visually-hidden">pdoc</span><img
                alt="pdoc logo"
                src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20role%3D%22img%22%20aria-label%3D%22pdoc%20logo%22%20width%3D%22300%22%20height%3D%22150%22%20viewBox%3D%22-1%200%2060%2030%22%3E%3Ctitle%3Epdoc%3C/title%3E%3Cpath%20d%3D%22M29.621%2021.293c-.011-.273-.214-.475-.511-.481a.5.5%200%200%200-.489.503l-.044%201.393c-.097.551-.695%201.215-1.566%201.704-.577.428-1.306.486-2.193.182-1.426-.617-2.467-1.654-3.304-2.487l-.173-.172a3.43%203.43%200%200%200-.365-.306.49.49%200%200%200-.286-.196c-1.718-1.06-4.931-1.47-7.353.191l-.219.15c-1.707%201.187-3.413%202.131-4.328%201.03-.02-.027-.49-.685-.141-1.763.233-.721.546-2.408.772-4.076.042-.09.067-.187.046-.288.166-1.347.277-2.625.241-3.351%201.378-1.008%202.271-2.586%202.271-4.362%200-.976-.272-1.935-.788-2.774-.057-.094-.122-.18-.184-.268.033-.167.052-.339.052-.516%200-1.477-1.202-2.679-2.679-2.679-.791%200-1.496.352-1.987.9a6.3%206.3%200%200%200-1.001.029c-.492-.564-1.207-.929-2.012-.929-1.477%200-2.679%201.202-2.679%202.679A2.65%202.65%200%200%200%20.97%206.554c-.383.747-.595%201.572-.595%202.41%200%202.311%201.507%204.29%203.635%205.107-.037.699-.147%202.27-.423%203.294l-.137.461c-.622%202.042-2.515%208.257%201.727%2010.643%201.614.908%203.06%201.248%204.317%201.248%202.665%200%204.492-1.524%205.322-2.401%201.476-1.559%202.886-1.854%206.491.82%201.877%201.393%203.514%201.753%204.861%201.068%202.223-1.713%202.811-3.867%203.399-6.374.077-.846.056-1.469.054-1.537zm-4.835%204.313c-.054.305-.156.586-.242.629-.034-.007-.131-.022-.307-.157-.145-.111-.314-.478-.456-.908.221.121.432.25.675.355.115.039.219.051.33.081zm-2.251-1.238c-.05.33-.158.648-.252.694-.022.001-.125-.018-.307-.157-.217-.166-.488-.906-.639-1.573.358.344.754.693%201.198%201.036zm-3.887-2.337c-.006-.116-.018-.231-.041-.342.635.145%201.189.368%201.599.625.097.231.166.481.174.642-.03.049-.055.101-.067.158-.046.013-.128.026-.298.004-.278-.037-.901-.57-1.367-1.087zm-1.127-.497c.116.306.176.625.12.71-.019.014-.117.045-.345.016-.206-.027-.604-.332-.986-.695.41-.051.816-.056%201.211-.031zm-4.535%201.535c.209.22.379.47.358.598-.006.041-.088.138-.351.234-.144.055-.539-.063-.979-.259a11.66%2011.66%200%200%200%20.972-.573zm.983-.664c.359-.237.738-.418%201.126-.554.25.237.479.548.457.694-.006.042-.087.138-.351.235-.174.064-.694-.105-1.232-.375zm-3.381%201.794c-.022.145-.061.29-.149.401-.133.166-.358.248-.69.251h-.002c-.133%200-.306-.26-.45-.621.417.091.854.07%201.291-.031zm-2.066-8.077a4.78%204.78%200%200%201-.775-.584c.172-.115.505-.254.88-.378l-.105.962zm-.331%202.302a10.32%2010.32%200%200%201-.828-.502c.202-.143.576-.328.984-.49l-.156.992zm-.45%202.157l-.701-.403c.214-.115.536-.249.891-.376a11.57%2011.57%200%200%201-.19.779zm-.181%201.716c.064.398.194.702.298.893-.194-.051-.435-.162-.736-.398.061-.119.224-.3.438-.495zM8.87%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zm-.735-.389a1.15%201.15%200%200%200-.314.783%201.16%201.16%200%200%200%201.162%201.162c.457%200%20.842-.27%201.032-.653.026.117.042.238.042.362a1.68%201.68%200%200%201-1.679%201.679%201.68%201.68%200%200%201-1.679-1.679c0-.843.626-1.535%201.436-1.654zM5.059%205.406A1.68%201.68%200%200%201%203.38%207.085a1.68%201.68%200%200%201-1.679-1.679c0-.037.009-.072.011-.109.21.3.541.508.935.508a1.16%201.16%200%200%200%201.162-1.162%201.14%201.14%200%200%200-.474-.912c.015%200%20.03-.005.045-.005.926.001%201.679.754%201.679%201.68zM3.198%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zM1.375%208.964c0-.52.103-1.035.288-1.52.466.394%201.06.64%201.717.64%201.144%200%202.116-.725%202.499-1.738.383%201.012%201.355%201.738%202.499%201.738.867%200%201.631-.421%202.121-1.062.307.605.478%201.267.478%201.942%200%202.486-2.153%204.51-4.801%204.51s-4.801-2.023-4.801-4.51zm24.342%2019.349c-.985.498-2.267.168-3.813-.979-3.073-2.281-5.453-3.199-7.813-.705-1.315%201.391-4.163%203.365-8.423.97-3.174-1.786-2.239-6.266-1.261-9.479l.146-.492c.276-1.02.395-2.457.444-3.268a6.11%206.11%200%200%200%201.18.115%206.01%206.01%200%200%200%202.536-.562l-.006.175c-.802.215-1.848.612-2.021%201.25-.079.295.021.601.274.837.219.203.415.364.598.501-.667.304-1.243.698-1.311%201.179-.02.144-.022.507.393.787.213.144.395.26.564.365-1.285.521-1.361.96-1.381%201.126-.018.142-.011.496.427.746l.854.489c-.473.389-.971.914-.999%201.429-.018.278.095.532.316.713.675.556%201.231.721%201.653.721.059%200%20.104-.014.158-.02.207.707.641%201.64%201.513%201.64h.013c.8-.008%201.236-.345%201.462-.626.173-.216.268-.457.325-.692.424.195.93.374%201.372.374.151%200%20.294-.021.423-.068.732-.27.944-.704.993-1.021.009-.061.003-.119.002-.179.266.086.538.147.789.147.15%200%20.294-.021.423-.069.542-.2.797-.489.914-.754.237.147.478.258.704.288.106.014.205.021.296.021.356%200%20.595-.101.767-.229.438.435%201.094.992%201.656%201.067.106.014.205.021.296.021a1.56%201.56%200%200%200%20.323-.035c.17.575.453%201.289.866%201.605.358.273.665.362.914.362a.99.99%200%200%200%20.421-.093%201.03%201.03%200%200%200%20.245-.164c.168.428.39.846.68%201.068.358.273.665.362.913.362a.99.99%200%200%200%20.421-.093c.317-.148.512-.448.639-.762.251.157.495.257.726.257.127%200%20.25-.024.37-.071.427-.17.706-.617.841-1.314.022-.015.047-.022.068-.038.067-.051.133-.104.196-.159-.443%201.486-1.107%202.761-2.086%203.257zM8.66%209.925a.5.5%200%201%200-1%200c0%20.653-.818%201.205-1.787%201.205s-1.787-.552-1.787-1.205a.5.5%200%201%200-1%200c0%201.216%201.25%202.205%202.787%202.205s2.787-.989%202.787-2.205zm4.4%2015.965l-.208.097c-2.661%201.258-4.708%201.436-6.086.527-1.542-1.017-1.88-3.19-1.844-4.198a.4.4%200%200%200-.385-.414c-.242-.029-.406.164-.414.385-.046%201.249.367%203.686%202.202%204.896.708.467%201.547.7%202.51.7%201.248%200%202.706-.392%204.362-1.174l.185-.086a.4.4%200%200%200%20.205-.527c-.089-.204-.326-.291-.527-.206zM9.547%202.292c.093.077.205.114.317.114a.5.5%200%200%200%20.318-.886L8.817.397a.5.5%200%200%200-.703.068.5.5%200%200%200%20.069.703l1.364%201.124zm-7.661-.065c.086%200%20.173-.022.253-.068l1.523-.893a.5.5%200%200%200-.506-.863l-1.523.892a.5.5%200%200%200-.179.685c.094.158.261.247.432.247z%22%20transform%3D%22matrix%28-1%200%200%201%2058%200%29%22%20fill%3D%22%233bb300%22/%3E%3Cpath%20d%3D%22M.3%2021.86V10.18q0-.46.02-.68.04-.22.18-.5.28-.54%201.34-.54%201.06%200%201.42.28.38.26.44.78.76-1.04%202.38-1.04%201.64%200%203.1%201.54%201.46%201.54%201.46%203.58%200%202.04-1.46%203.58-1.44%201.54-3.08%201.54-1.64%200-2.38-.92v4.04q0%20.46-.04.68-.02.22-.18.5-.14.3-.5.42-.36.12-.98.12-.62%200-1-.12-.36-.12-.52-.4-.14-.28-.18-.5-.02-.22-.02-.68zm3.96-9.42q-.46.54-.46%201.18%200%20.64.46%201.18.48.52%201.2.52.74%200%201.24-.52.52-.52.52-1.18%200-.66-.48-1.18-.48-.54-1.26-.54-.76%200-1.22.54zm14.741-8.36q.16-.3.54-.42.38-.12%201-.12.64%200%201.02.12.38.12.52.42.16.3.18.54.04.22.04.68v11.94q0%20.46-.04.7-.02.22-.18.5-.3.54-1.7.54-1.38%200-1.54-.98-.84.96-2.34.96-1.8%200-3.28-1.56-1.48-1.58-1.48-3.66%200-2.1%201.48-3.68%201.5-1.58%203.28-1.58%201.48%200%202.3%201v-4.2q0-.46.02-.68.04-.24.18-.52zm-3.24%2010.86q.52.54%201.26.54.74%200%201.22-.54.5-.54.5-1.18%200-.66-.48-1.22-.46-.56-1.26-.56-.8%200-1.28.56-.48.54-.48%201.2%200%20.66.52%201.2zm7.833-1.2q0-2.4%201.68-3.96%201.68-1.56%203.84-1.56%202.16%200%203.82%201.56%201.66%201.54%201.66%203.94%200%201.66-.86%202.96-.86%201.28-2.1%201.9-1.22.6-2.54.6-1.32%200-2.56-.64-1.24-.66-2.1-1.92-.84-1.28-.84-2.88zm4.18%201.44q.64.48%201.3.48.66%200%201.32-.5.66-.5.66-1.48%200-.98-.62-1.46-.62-.48-1.34-.48-.72%200-1.34.5-.62.5-.62%201.48%200%20.96.64%201.46zm11.412-1.44q0%20.84.56%201.32.56.46%201.18.46.64%200%201.18-.36.56-.38.9-.38.6%200%201.46%201.06.46.58.46%201.04%200%20.76-1.1%201.42-1.14.8-2.8.8-1.86%200-3.58-1.34-.82-.64-1.34-1.7-.52-1.08-.52-2.36%200-1.3.52-2.34.52-1.06%201.34-1.7%201.66-1.32%203.54-1.32.76%200%201.48.22.72.2%201.06.4l.32.2q.36.24.56.38.52.4.52.92%200%20.5-.42%201.14-.72%201.1-1.38%201.1-.38%200-1.08-.44-.36-.34-1.04-.34-.66%200-1.24.48-.58.48-.58%201.34z%22%20fill%3D%22green%22/%3E%3C/svg%3E"/>
        </a>
</div>
    </nav>
    <main class="pdoc">
            <section class="module-info">
                    <h1 class="modulename">
<a href="./../pygel3d.html">pygel3d</a><wbr>.hmesh    </h1>

                        <div class="docstring"><p>The hmesh module provides an halfedge based mesh representation.</p>
</div>

                        <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="L-0"><a href="#L-0"><span class="linenos">  0</span></a><span class="sd">&quot;&quot;&quot; The hmesh module provides an halfedge based mesh representation.&quot;&quot;&quot;</span>
</span><span id="L-1"><a href="#L-1"><span class="linenos">  1</span></a><span class="kn">import</span> <span class="nn">ctypes</span> <span class="k">as</span> <span class="nn">ct</span>
</span><span id="L-2"><a href="#L-2"><span class="linenos">  2</span></a><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span><span id="L-3"><a href="#L-3"><span class="linenos">  3</span></a><span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">norm</span>
</span><span id="L-4"><a href="#L-4"><span class="linenos">  4</span></a><span class="kn">from</span> <span class="nn">pygel3d</span> <span class="kn">import</span> <span class="n">lib_py_gel</span><span class="p">,</span> <span class="n">IntVector</span><span class="p">,</span> <span class="n">Vec3dVector</span>
</span><span id="L-5"><a href="#L-5"><span class="linenos">  5</span></a>
</span><span id="L-6"><a href="#L-6"><span class="linenos">  6</span></a>
</span><span id="L-7"><a href="#L-7"><span class="linenos">  7</span></a><span class="k">class</span> <span class="nc">Manifold</span><span class="p">:</span>
</span><span id="L-8"><a href="#L-8"><span class="linenos">  8</span></a>    <span class="sd">&quot;&quot;&quot; The Manifold class represents a halfedge based mesh. It is maybe a bit grand to call</span>
</span><span id="L-9"><a href="#L-9"><span class="linenos">  9</span></a><span class="sd">    a mesh class Manifold, but meshes based on the halfedge representation are manifold (if we</span>
</span><span id="L-10"><a href="#L-10"><span class="linenos"> 10</span></a><span class="sd">    ignore a few corner cases) unlike some other representations. This class contains a number of</span>
</span><span id="L-11"><a href="#L-11"><span class="linenos"> 11</span></a><span class="sd">    methods for mesh manipulation and inspection. Note also that numerous further functions are</span>
</span><span id="L-12"><a href="#L-12"><span class="linenos"> 12</span></a><span class="sd">    available to manipulate meshes stored as Manifolds.</span>
</span><span id="L-13"><a href="#L-13"><span class="linenos"> 13</span></a><span class="sd">    </span>
</span><span id="L-14"><a href="#L-14"><span class="linenos"> 14</span></a><span class="sd">    Many of the functions below accept arguments called hid, fid, or vid. These are simply indices</span>
</span><span id="L-15"><a href="#L-15"><span class="linenos"> 15</span></a><span class="sd">    of halfedges, faces and vertices, respectively: integer numbers that identify the corresponding</span>
</span><span id="L-16"><a href="#L-16"><span class="linenos"> 16</span></a><span class="sd">    mesh element. Using a plain integer to identify a mesh entity means that, for instance, a</span>
</span><span id="L-17"><a href="#L-17"><span class="linenos"> 17</span></a><span class="sd">    vertex index can also be used as an index into, say, a NumPy array without any conversion.</span>
</span><span id="L-18"><a href="#L-18"><span class="linenos"> 18</span></a><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="L-19"><a href="#L-19"><span class="linenos"> 19</span></a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">orig</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
</span><span id="L-20"><a href="#L-20"><span class="linenos"> 20</span></a>        <span class="k">if</span> <span class="n">orig</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="L-21"><a href="#L-21"><span class="linenos"> 21</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">obj</span> <span class="o">=</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_new</span><span class="p">()</span>
</span><span id="L-22"><a href="#L-22"><span class="linenos"> 22</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="L-23"><a href="#L-23"><span class="linenos"> 23</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">obj</span> <span class="o">=</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_copy</span><span class="p">(</span><span class="n">orig</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="L-24"><a href="#L-24"><span class="linenos"> 24</span></a>    <span class="nd">@classmethod</span>
</span><span id="L-25"><a href="#L-25"><span class="linenos"> 25</span></a>    <span class="k">def</span> <span class="nf">from_triangles</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span><span class="n">vertices</span><span class="p">,</span> <span class="n">faces</span><span class="p">):</span>
</span><span id="L-26"><a href="#L-26"><span class="linenos"> 26</span></a>        <span class="sd">&quot;&quot;&quot; Given a list of vertices and triangles (faces), this function produces </span>
</span><span id="L-27"><a href="#L-27"><span class="linenos"> 27</span></a><span class="sd">        a Manifold mesh.&quot;&quot;&quot;</span>
</span><span id="L-28"><a href="#L-28"><span class="linenos"> 28</span></a>        <span class="n">m</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>
</span><span id="L-29"><a href="#L-29"><span class="linenos"> 29</span></a>        <span class="n">m</span><span class="o">.</span><span class="n">obj</span> <span class="o">=</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_from_triangles</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">faces</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">ct</span><span class="o">.</span><span class="n">c_int</span><span class="p">))</span>
</span><span id="L-30"><a href="#L-30"><span class="linenos"> 30</span></a>        <span class="k">return</span> <span class="n">m</span>
</span><span id="L-31"><a href="#L-31"><span class="linenos"> 31</span></a>    <span class="nd">@classmethod</span>
</span><span id="L-32"><a href="#L-32"><span class="linenos"> 32</span></a>    <span class="k">def</span> <span class="nf">from_points</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span><span class="n">pts</span><span class="p">,</span><span class="n">xaxis</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span><span class="n">yaxis</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])):</span>
</span><span id="L-33"><a href="#L-33"><span class="linenos"> 33</span></a>        <span class="sd">&quot;&quot;&quot; This function computes the Delaunay triangulation of pts. You need</span>
</span><span id="L-34"><a href="#L-34"><span class="linenos"> 34</span></a><span class="sd">        to specify xaxis and yaxis if they are not canonical. The function returns</span>
</span><span id="L-35"><a href="#L-35"><span class="linenos"> 35</span></a><span class="sd">        a Manifold with the resulting triangles. Clearly, this function will</span>
</span><span id="L-36"><a href="#L-36"><span class="linenos"> 36</span></a><span class="sd">        give surprising results if the surface represented by the points is not</span>
</span><span id="L-37"><a href="#L-37"><span class="linenos"> 37</span></a><span class="sd">        well represented as a 2.5D surface, aka a height field. &quot;&quot;&quot;</span>
</span><span id="L-38"><a href="#L-38"><span class="linenos"> 38</span></a>        <span class="n">m</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>
</span><span id="L-39"><a href="#L-39"><span class="linenos"> 39</span></a>        <span class="n">m</span><span class="o">.</span><span class="n">obj</span> <span class="o">=</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_from_points</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pts</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xaxis</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">yaxis</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>
</span><span id="L-40"><a href="#L-40"><span class="linenos"> 40</span></a>        <span class="k">return</span> <span class="n">m</span>
</span><span id="L-41"><a href="#L-41"><span class="linenos"> 41</span></a>    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="L-42"><a href="#L-42"><span class="linenos"> 42</span></a>        <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="L-43"><a href="#L-43"><span class="linenos"> 43</span></a>    <span class="k">def</span> <span class="nf">add_face</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pts</span><span class="p">):</span>
</span><span id="L-44"><a href="#L-44"><span class="linenos"> 44</span></a>        <span class="sd">&quot;&quot;&quot; Add a face to the Manifold.</span>
</span><span id="L-45"><a href="#L-45"><span class="linenos"> 45</span></a><span class="sd">        This function takes a list of 3D points, pts, as argument and creates a face</span>
</span><span id="L-46"><a href="#L-46"><span class="linenos"> 46</span></a><span class="sd">        in the mesh with those points as vertices. The function returns the index</span>
</span><span id="L-47"><a href="#L-47"><span class="linenos"> 47</span></a><span class="sd">        of the created face.</span>
</span><span id="L-48"><a href="#L-48"><span class="linenos"> 48</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="L-49"><a href="#L-49"><span class="linenos"> 49</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_add_face</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">pts</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pts</span><span class="p">))</span>
</span><span id="L-50"><a href="#L-50"><span class="linenos"> 50</span></a>    <span class="k">def</span> <span class="nf">positions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="L-51"><a href="#L-51"><span class="linenos"> 51</span></a>        <span class="sd">&quot;&quot;&quot; Retrieve an array containing the vertex positions of the Manifold.</span>
</span><span id="L-52"><a href="#L-52"><span class="linenos"> 52</span></a><span class="sd">        It is not a copy: any changes are made to the actual vertex positions. &quot;&quot;&quot;</span>
</span><span id="L-53"><a href="#L-53"><span class="linenos"> 53</span></a>        <span class="n">pos</span> <span class="o">=</span> <span class="n">ct</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">c_double</span><span class="p">)()</span>
</span><span id="L-54"><a href="#L-54"><span class="linenos"> 54</span></a>        <span class="n">n</span> <span class="o">=</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_positions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">ct</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">pos</span><span class="p">))</span>
</span><span id="L-55"><a href="#L-55"><span class="linenos"> 55</span></a>        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">as_array</span><span class="p">(</span><span class="n">pos</span><span class="p">,(</span><span class="n">n</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
</span><span id="L-56"><a href="#L-56"><span class="linenos"> 56</span></a>    <span class="k">def</span> <span class="nf">no_allocated_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="L-57"><a href="#L-57"><span class="linenos"> 57</span></a>        <span class="sd">&quot;&quot;&quot; Number of vertices.</span>
</span><span id="L-58"><a href="#L-58"><span class="linenos"> 58</span></a><span class="sd">        This number could be higher than the number of actually</span>
</span><span id="L-59"><a href="#L-59"><span class="linenos"> 59</span></a><span class="sd">        used vertices, but corresponds to the size of the array allocated</span>
</span><span id="L-60"><a href="#L-60"><span class="linenos"> 60</span></a><span class="sd">        for vertices.&quot;&quot;&quot;</span>
</span><span id="L-61"><a href="#L-61"><span class="linenos"> 61</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_no_allocated_vertices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="L-62"><a href="#L-62"><span class="linenos"> 62</span></a>    <span class="k">def</span> <span class="nf">no_allocated_faces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="L-63"><a href="#L-63"><span class="linenos"> 63</span></a>        <span class="sd">&quot;&quot;&quot; Number of faces.</span>
</span><span id="L-64"><a href="#L-64"><span class="linenos"> 64</span></a><span class="sd">        This number could be higher than the number of actually</span>
</span><span id="L-65"><a href="#L-65"><span class="linenos"> 65</span></a><span class="sd">        used faces, but corresponds to the size of the array allocated</span>
</span><span id="L-66"><a href="#L-66"><span class="linenos"> 66</span></a><span class="sd">        for faces.&quot;&quot;&quot;</span>
</span><span id="L-67"><a href="#L-67"><span class="linenos"> 67</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_no_allocated_faces</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="L-68"><a href="#L-68"><span class="linenos"> 68</span></a>    <span class="k">def</span> <span class="nf">no_allocated_halfedges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="L-69"><a href="#L-69"><span class="linenos"> 69</span></a>        <span class="sd">&quot;&quot;&quot; Number of halfedges.</span>
</span><span id="L-70"><a href="#L-70"><span class="linenos"> 70</span></a><span class="sd">        This number could be higher than the number of actually</span>
</span><span id="L-71"><a href="#L-71"><span class="linenos"> 71</span></a><span class="sd">        used halfedges, but corresponds to the size of the array allocated</span>
</span><span id="L-72"><a href="#L-72"><span class="linenos"> 72</span></a><span class="sd">        for halfedges.&quot;&quot;&quot;</span>
</span><span id="L-73"><a href="#L-73"><span class="linenos"> 73</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_no_allocated_halfedges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="L-74"><a href="#L-74"><span class="linenos"> 74</span></a>    <span class="k">def</span> <span class="nf">vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="L-75"><a href="#L-75"><span class="linenos"> 75</span></a>        <span class="sd">&quot;&quot;&quot; Returns an iterable containing all vertex indices&quot;&quot;&quot;</span>
</span><span id="L-76"><a href="#L-76"><span class="linenos"> 76</span></a>        <span class="n">verts</span> <span class="o">=</span> <span class="n">IntVector</span><span class="p">()</span>
</span><span id="L-77"><a href="#L-77"><span class="linenos"> 77</span></a>        <span class="n">n</span> <span class="o">=</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_vertices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">verts</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="L-78"><a href="#L-78"><span class="linenos"> 78</span></a>        <span class="k">return</span> <span class="n">verts</span>
</span><span id="L-79"><a href="#L-79"><span class="linenos"> 79</span></a>    <span class="k">def</span> <span class="nf">faces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="L-80"><a href="#L-80"><span class="linenos"> 80</span></a>        <span class="sd">&quot;&quot;&quot; Returns an iterable containing all face indices&quot;&quot;&quot;</span>
</span><span id="L-81"><a href="#L-81"><span class="linenos"> 81</span></a>        <span class="n">faces</span> <span class="o">=</span> <span class="n">IntVector</span><span class="p">()</span>
</span><span id="L-82"><a href="#L-82"><span class="linenos"> 82</span></a>        <span class="n">n</span> <span class="o">=</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_faces</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">faces</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="L-83"><a href="#L-83"><span class="linenos"> 83</span></a>        <span class="k">return</span> <span class="n">faces</span>
</span><span id="L-84"><a href="#L-84"><span class="linenos"> 84</span></a>    <span class="k">def</span> <span class="nf">halfedges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="L-85"><a href="#L-85"><span class="linenos"> 85</span></a>        <span class="sd">&quot;&quot;&quot; Returns an iterable containing all halfedge indices&quot;&quot;&quot;</span>
</span><span id="L-86"><a href="#L-86"><span class="linenos"> 86</span></a>        <span class="n">hedges</span> <span class="o">=</span> <span class="n">IntVector</span><span class="p">()</span>
</span><span id="L-87"><a href="#L-87"><span class="linenos"> 87</span></a>        <span class="n">n</span> <span class="o">=</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_halfedges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">hedges</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="L-88"><a href="#L-88"><span class="linenos"> 88</span></a>        <span class="k">return</span> <span class="n">hedges</span>
</span><span id="L-89"><a href="#L-89"><span class="linenos"> 89</span></a>    <span class="k">def</span> <span class="nf">circulate_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vid</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">):</span>
</span><span id="L-90"><a href="#L-90"><span class="linenos"> 90</span></a>        <span class="sd">&quot;&quot;&quot; Circulate a vertex. Passed a vertex index, vid, and second argument,</span>
</span><span id="L-91"><a href="#L-91"><span class="linenos"> 91</span></a><span class="sd">        mode=&#39;f&#39;, this function will return an iterable with all faces incident</span>
</span><span id="L-92"><a href="#L-92"><span class="linenos"> 92</span></a><span class="sd">        on vid arranged in counter clockwise order. Similarly, if mode is &#39;h&#39;,</span>
</span><span id="L-93"><a href="#L-93"><span class="linenos"> 93</span></a><span class="sd">        incident halfedges (outgoing) are returned, and for mode = &#39;v&#39;, all</span>
</span><span id="L-94"><a href="#L-94"><span class="linenos"> 94</span></a><span class="sd">        neighboring vertices are returned. &quot;&quot;&quot;</span>
</span><span id="L-95"><a href="#L-95"><span class="linenos"> 95</span></a>        <span class="n">nbrs</span> <span class="o">=</span> <span class="n">IntVector</span><span class="p">()</span>
</span><span id="L-96"><a href="#L-96"><span class="linenos"> 96</span></a>        <span class="n">n</span> <span class="o">=</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_circulate_vertex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">vid</span><span class="p">,</span> <span class="n">ct</span><span class="o">.</span><span class="n">c_char</span><span class="p">(</span><span class="n">mode</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)),</span> <span class="n">nbrs</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="L-97"><a href="#L-97"><span class="linenos"> 97</span></a>        <span class="k">return</span> <span class="n">nbrs</span>
</span><span id="L-98"><a href="#L-98"><span class="linenos"> 98</span></a>    <span class="k">def</span> <span class="nf">circulate_face</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">):</span>
</span><span id="L-99"><a href="#L-99"><span class="linenos"> 99</span></a>        <span class="sd">&quot;&quot;&quot; Circulate a face. Passed a face index, fid, and second argument,</span>
</span><span id="L-100"><a href="#L-100"><span class="linenos">100</span></a><span class="sd">        mode=&#39;f&#39;, this function will return an iterable with all faces that</span>
</span><span id="L-101"><a href="#L-101"><span class="linenos">101</span></a><span class="sd">        share an edge with fid (in counter clockwise order). If the argument is</span>
</span><span id="L-102"><a href="#L-102"><span class="linenos">102</span></a><span class="sd">        mode=&#39;h&#39;, the halfedges themselves are returned. For mode=&#39;v&#39;, the</span>
</span><span id="L-103"><a href="#L-103"><span class="linenos">103</span></a><span class="sd">        incident vertices of the face are returned. &quot;&quot;&quot;</span>
</span><span id="L-104"><a href="#L-104"><span class="linenos">104</span></a>        <span class="n">nbrs</span> <span class="o">=</span> <span class="n">IntVector</span><span class="p">()</span>
</span><span id="L-105"><a href="#L-105"><span class="linenos">105</span></a>        <span class="n">n</span> <span class="o">=</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_circulate_face</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">ct</span><span class="o">.</span><span class="n">c_char</span><span class="p">(</span><span class="n">mode</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)),</span> <span class="n">nbrs</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="L-106"><a href="#L-106"><span class="linenos">106</span></a>        <span class="k">return</span> <span class="n">nbrs</span>
</span><span id="L-107"><a href="#L-107"><span class="linenos">107</span></a>    <span class="k">def</span> <span class="nf">next_halfedge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hid</span><span class="p">):</span>
</span><span id="L-108"><a href="#L-108"><span class="linenos">108</span></a>        <span class="sd">&quot;&quot;&quot; Returns next halfedge to hid. &quot;&quot;&quot;</span>
</span><span id="L-109"><a href="#L-109"><span class="linenos">109</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Walker_next_halfedge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">hid</span><span class="p">)</span>
</span><span id="L-110"><a href="#L-110"><span class="linenos">110</span></a>    <span class="k">def</span> <span class="nf">prev_halfedge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hid</span><span class="p">):</span>
</span><span id="L-111"><a href="#L-111"><span class="linenos">111</span></a>        <span class="sd">&quot;&quot;&quot; Returns previous halfedge to hid. &quot;&quot;&quot;</span>
</span><span id="L-112"><a href="#L-112"><span class="linenos">112</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Walker_prev_halfedge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">hid</span><span class="p">)</span>
</span><span id="L-113"><a href="#L-113"><span class="linenos">113</span></a>    <span class="k">def</span> <span class="nf">opposite_halfedge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hid</span><span class="p">):</span>
</span><span id="L-114"><a href="#L-114"><span class="linenos">114</span></a>        <span class="sd">&quot;&quot;&quot; Returns opposite halfedge to hid. &quot;&quot;&quot;</span>
</span><span id="L-115"><a href="#L-115"><span class="linenos">115</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Walker_opposite_halfedge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">hid</span><span class="p">)</span>
</span><span id="L-116"><a href="#L-116"><span class="linenos">116</span></a>    <span class="k">def</span> <span class="nf">incident_face</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hid</span><span class="p">):</span>
</span><span id="L-117"><a href="#L-117"><span class="linenos">117</span></a>        <span class="sd">&quot;&quot;&quot; Returns face corresponding to hid. &quot;&quot;&quot;</span>
</span><span id="L-118"><a href="#L-118"><span class="linenos">118</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Walker_incident_face</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">hid</span><span class="p">)</span>
</span><span id="L-119"><a href="#L-119"><span class="linenos">119</span></a>    <span class="k">def</span> <span class="nf">incident_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hid</span><span class="p">):</span>
</span><span id="L-120"><a href="#L-120"><span class="linenos">120</span></a>        <span class="sd">&quot;&quot;&quot; Returns vertex corresponding to (or pointed to by) hid. &quot;&quot;&quot;</span>
</span><span id="L-121"><a href="#L-121"><span class="linenos">121</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Walker_incident_vertex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">hid</span><span class="p">)</span>
</span><span id="L-122"><a href="#L-122"><span class="linenos">122</span></a>    <span class="k">def</span> <span class="nf">remove_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">vid</span><span class="p">):</span>
</span><span id="L-123"><a href="#L-123"><span class="linenos">123</span></a>        <span class="sd">&quot;&quot;&quot; Remove vertex vid from the Manifold. This function merges all faces</span>
</span><span id="L-124"><a href="#L-124"><span class="linenos">124</span></a><span class="sd">        around the vertex into one and then removes this resulting face. &quot;&quot;&quot;</span>
</span><span id="L-125"><a href="#L-125"><span class="linenos">125</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_remove_vertex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">vid</span><span class="p">)</span>
</span><span id="L-126"><a href="#L-126"><span class="linenos">126</span></a>    <span class="k">def</span> <span class="nf">remove_face</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fid</span><span class="p">):</span>
</span><span id="L-127"><a href="#L-127"><span class="linenos">127</span></a>        <span class="sd">&quot;&quot;&quot; Removes a face, fid, from the Manifold. If it is an interior face it is</span>
</span><span id="L-128"><a href="#L-128"><span class="linenos">128</span></a><span class="sd">        simply replaced by an invalid index. If the face contains boundary</span>
</span><span id="L-129"><a href="#L-129"><span class="linenos">129</span></a><span class="sd">        edges, these are removed. Situations may arise where the mesh is no</span>
</span><span id="L-130"><a href="#L-130"><span class="linenos">130</span></a><span class="sd">        longer manifold because the situation at a boundary vertex is not</span>
</span><span id="L-131"><a href="#L-131"><span class="linenos">131</span></a><span class="sd">        homeomorphic to a half disk. This, we can probably ignore since from the</span>
</span><span id="L-132"><a href="#L-132"><span class="linenos">132</span></a><span class="sd">        data structure point of view it is not really a problem that a vertex is</span>
</span><span id="L-133"><a href="#L-133"><span class="linenos">133</span></a><span class="sd">        incident on two holes - a hole can be seen as a special type of face.</span>
</span><span id="L-134"><a href="#L-134"><span class="linenos">134</span></a><span class="sd">        The function returns false if the index of the face is not valid,</span>
</span><span id="L-135"><a href="#L-135"><span class="linenos">135</span></a><span class="sd">        otherwise the function must complete. &quot;&quot;&quot;</span>
</span><span id="L-136"><a href="#L-136"><span class="linenos">136</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_remove_face</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">fid</span><span class="p">)</span>
</span><span id="L-137"><a href="#L-137"><span class="linenos">137</span></a>    <span class="k">def</span> <span class="nf">remove_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hid</span><span class="p">):</span>
</span><span id="L-138"><a href="#L-138"><span class="linenos">138</span></a>        <span class="sd">&quot;&quot;&quot; Remove an edge, hid, from the Manifold. This function will remove the</span>
</span><span id="L-139"><a href="#L-139"><span class="linenos">139</span></a><span class="sd">        faces on either side and the edge itself in the process. Thus, it is a</span>
</span><span id="L-140"><a href="#L-140"><span class="linenos">140</span></a><span class="sd">        simple application of remove_face. &quot;&quot;&quot;</span>
</span><span id="L-141"><a href="#L-141"><span class="linenos">141</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_remove_edge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">hid</span><span class="p">)</span>
</span><span id="L-142"><a href="#L-142"><span class="linenos">142</span></a>    <span class="k">def</span> <span class="nf">vertex_in_use</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">vid</span><span class="p">):</span>
</span><span id="L-143"><a href="#L-143"><span class="linenos">143</span></a>        <span class="sd">&quot;&quot;&quot; check if vertex, vid, is in use. This function returns true if the id corresponds</span>
</span><span id="L-144"><a href="#L-144"><span class="linenos">144</span></a><span class="sd">        to a vertex that is currently in the mesh and false otherwise. vid could</span>
</span><span id="L-145"><a href="#L-145"><span class="linenos">145</span></a><span class="sd">        be outside the range of used ids and it could also correspond to a vertex</span>
</span><span id="L-146"><a href="#L-146"><span class="linenos">146</span></a><span class="sd">        which is not active. The function returns false in both cases. &quot;&quot;&quot;</span>
</span><span id="L-147"><a href="#L-147"><span class="linenos">147</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_vertex_in_use</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">vid</span><span class="p">)</span>
</span><span id="L-148"><a href="#L-148"><span class="linenos">148</span></a>    <span class="k">def</span> <span class="nf">face_in_use</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fid</span><span class="p">):</span>
</span><span id="L-149"><a href="#L-149"><span class="linenos">149</span></a>        <span class="sd">&quot;&quot;&quot; check if face, fid, is in use. This function returns true if the id corresponds</span>
</span><span id="L-150"><a href="#L-150"><span class="linenos">150</span></a><span class="sd">        to a face that is currently in the mesh and false otherwise. fid could</span>
</span><span id="L-151"><a href="#L-151"><span class="linenos">151</span></a><span class="sd">        be outside the range of used ids and it could also correspond to a face</span>
</span><span id="L-152"><a href="#L-152"><span class="linenos">152</span></a><span class="sd">        which is not active. The function returns false in both cases. &quot;&quot;&quot;</span>
</span><span id="L-153"><a href="#L-153"><span class="linenos">153</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_face_in_use</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">fid</span><span class="p">)</span>
</span><span id="L-154"><a href="#L-154"><span class="linenos">154</span></a>    <span class="k">def</span> <span class="nf">halfedge_in_use</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hid</span><span class="p">):</span>
</span><span id="L-155"><a href="#L-155"><span class="linenos">155</span></a>        <span class="sd">&quot;&quot;&quot; check if halfedge hid is in use. This function returns true if the id corresponds</span>
</span><span id="L-156"><a href="#L-156"><span class="linenos">156</span></a><span class="sd">        to a halfedge that is currently in the mesh and false otherwise. hid could</span>
</span><span id="L-157"><a href="#L-157"><span class="linenos">157</span></a><span class="sd">        be outside the range of used ids and it could also correspond to a halfedge</span>
</span><span id="L-158"><a href="#L-158"><span class="linenos">158</span></a><span class="sd">        which is not active. The function returns false in both cases. &quot;&quot;&quot;</span>
</span><span id="L-159"><a href="#L-159"><span class="linenos">159</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_halfedge_in_use</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">hid</span><span class="p">)</span>
</span><span id="L-160"><a href="#L-160"><span class="linenos">160</span></a>    <span class="k">def</span> <span class="nf">flip_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hid</span><span class="p">):</span>
</span><span id="L-161"><a href="#L-161"><span class="linenos">161</span></a>        <span class="sd">&quot;&quot;&quot; Flip the edge, hid, separating two faces. The function first verifies that</span>
</span><span id="L-162"><a href="#L-162"><span class="linenos">162</span></a><span class="sd">        the edge is flippable. This entails making sure that all of the</span>
</span><span id="L-163"><a href="#L-163"><span class="linenos">163</span></a><span class="sd">        following are true.</span>
</span><span id="L-164"><a href="#L-164"><span class="linenos">164</span></a><span class="sd">        1. adjacent faces are triangles.</span>
</span><span id="L-165"><a href="#L-165"><span class="linenos">165</span></a><span class="sd">        2. neither end point has valency three or less.</span>
</span><span id="L-166"><a href="#L-166"><span class="linenos">166</span></a><span class="sd">        3. the vertices that will be connected are not already.</span>
</span><span id="L-167"><a href="#L-167"><span class="linenos">167</span></a><span class="sd">        If the tests are passed, the flip is performed and the function</span>
</span><span id="L-168"><a href="#L-168"><span class="linenos">168</span></a><span class="sd">        returns True. Otherwise False.&quot;&quot;&quot;</span>
</span><span id="L-169"><a href="#L-169"><span class="linenos">169</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_flip_edge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span><span class="n">hid</span><span class="p">)</span>
</span><span id="L-170"><a href="#L-170"><span class="linenos">170</span></a>    <span class="k">def</span> <span class="nf">collapse_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hid</span><span class="p">,</span> <span class="n">avg_vertices</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="L-171"><a href="#L-171"><span class="linenos">171</span></a>        <span class="sd">&quot;&quot;&quot; Collapse an edge hid.</span>
</span><span id="L-172"><a href="#L-172"><span class="linenos">172</span></a><span class="sd">        Before collapsing hid, a number of tests are made:</span>
</span><span id="L-173"><a href="#L-173"><span class="linenos">173</span></a><span class="sd">        ---</span>
</span><span id="L-174"><a href="#L-174"><span class="linenos">174</span></a><span class="sd">        1.  For the two vertices adjacent to the edge, we generate a list of all their neighbouring vertices.</span>
</span><span id="L-175"><a href="#L-175"><span class="linenos">175</span></a><span class="sd">        We then generate a  list of the vertices that occur in both these lists.</span>
</span><span id="L-176"><a href="#L-176"><span class="linenos">176</span></a><span class="sd">        That is, we find all vertices connected by edges to both endpoints of the edge and store these in a list.</span>
</span><span id="L-177"><a href="#L-177"><span class="linenos">177</span></a><span class="sd">        2.  For both faces incident on the edge, check whether they are triangular.</span>
</span><span id="L-178"><a href="#L-178"><span class="linenos">178</span></a><span class="sd">        If this is the case, the face will be removed, and it is ok that the the third vertex is connected to both endpoints.</span>
</span><span id="L-179"><a href="#L-179"><span class="linenos">179</span></a><span class="sd">        Thus the third vertex in such a face is removed from the list generated in 1.</span>
</span><span id="L-180"><a href="#L-180"><span class="linenos">180</span></a><span class="sd">        3.  If the list is now empty, all is well.</span>
</span><span id="L-181"><a href="#L-181"><span class="linenos">181</span></a><span class="sd">        Otherwise, there would be a vertex in the new mesh with two edges connecting it to the same vertex. Return false.</span>
</span><span id="L-182"><a href="#L-182"><span class="linenos">182</span></a><span class="sd">        4.  TETRAHEDRON TEST:</span>
</span><span id="L-183"><a href="#L-183"><span class="linenos">183</span></a><span class="sd">        If the valency of both vertices is three, and the incident faces are triangles, we also disallow the operation.</span>
</span><span id="L-184"><a href="#L-184"><span class="linenos">184</span></a><span class="sd">        Reason: A vertex valency of two and two triangles incident on the adjacent vertices makes the construction collapse.</span>
</span><span id="L-185"><a href="#L-185"><span class="linenos">185</span></a><span class="sd">        5.  VALENCY 4 TEST:</span>
</span><span id="L-186"><a href="#L-186"><span class="linenos">186</span></a><span class="sd">        If a triangle is adjacent to the edge being collapsed, it disappears.</span>
</span><span id="L-187"><a href="#L-187"><span class="linenos">187</span></a><span class="sd">        This means the valency of the remaining edge vertex is decreased by one.</span>
</span><span id="L-188"><a href="#L-188"><span class="linenos">188</span></a><span class="sd">        A valency two vertex reduced to a valency one vertex is considered illegal.</span>
</span><span id="L-189"><a href="#L-189"><span class="linenos">189</span></a><span class="sd">        6.  PREVENT MERGING HOLES:</span>
</span><span id="L-190"><a href="#L-190"><span class="linenos">190</span></a><span class="sd">        Collapsing an edge with boundary endpoints and valid faces results in the creation where two holes meet.</span>
</span><span id="L-191"><a href="#L-191"><span class="linenos">191</span></a><span class="sd">        A non manifold situation. We could relax this...</span>
</span><span id="L-192"><a href="#L-192"><span class="linenos">192</span></a><span class="sd">        7. New test: if the same face is in the one-ring of both vertices but not adjacent to the common edge,</span>
</span><span id="L-193"><a href="#L-193"><span class="linenos">193</span></a><span class="sd">        then the result of a collapse would be a one ring where the same face occurs twice. This is disallowed as the resulting</span>
</span><span id="L-194"><a href="#L-194"><span class="linenos">194</span></a><span class="sd">        face would be non-simple.</span>
</span><span id="L-195"><a href="#L-195"><span class="linenos">195</span></a><span class="sd">        If the tests are passed, the collapse is performed and the function</span>
</span><span id="L-196"><a href="#L-196"><span class="linenos">196</span></a><span class="sd">        returns True. Otherwise False.&quot;&quot;&quot;</span>
</span><span id="L-197"><a href="#L-197"><span class="linenos">197</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_collapse_edge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">hid</span><span class="p">,</span> <span class="n">avg_vertices</span><span class="p">)</span>
</span><span id="L-198"><a href="#L-198"><span class="linenos">198</span></a>    <span class="k">def</span> <span class="nf">split_face_by_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fid</span><span class="p">,</span><span class="n">v0</span><span class="p">,</span><span class="n">v1</span><span class="p">):</span>
</span><span id="L-199"><a href="#L-199"><span class="linenos">199</span></a>        <span class="sd">&quot;&quot;&quot;   Split a face. The face, fid, is split by creating an edge with</span>
</span><span id="L-200"><a href="#L-200"><span class="linenos">200</span></a><span class="sd">        endpoints v0 and v1 (the next two arguments). The vertices of the old</span>
</span><span id="L-201"><a href="#L-201"><span class="linenos">201</span></a><span class="sd">        face between v0 and v1 (in counter clockwise order) continue to belong</span>
</span><span id="L-202"><a href="#L-202"><span class="linenos">202</span></a><span class="sd">        to fid. The vertices between v1 and v0 belong to the new face. A handle to</span>
</span><span id="L-203"><a href="#L-203"><span class="linenos">203</span></a><span class="sd">        the new face is returned. &quot;&quot;&quot;</span>
</span><span id="L-204"><a href="#L-204"><span class="linenos">204</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_split_face_by_edge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
</span><span id="L-205"><a href="#L-205"><span class="linenos">205</span></a>    <span class="k">def</span> <span class="nf">split_face_by_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fid</span><span class="p">):</span>
</span><span id="L-206"><a href="#L-206"><span class="linenos">206</span></a>        <span class="sd">&quot;&quot;&quot;   Split a polygon, fid, by inserting a vertex at the barycenter. This</span>
</span><span id="L-207"><a href="#L-207"><span class="linenos">207</span></a><span class="sd">        function is less likely to create flipped triangles than the</span>
</span><span id="L-208"><a href="#L-208"><span class="linenos">208</span></a><span class="sd">        split_face_triangulate function. On the other hand, it introduces more</span>
</span><span id="L-209"><a href="#L-209"><span class="linenos">209</span></a><span class="sd">        vertices and probably makes the triangles more acute. The vertex id of the</span>
</span><span id="L-210"><a href="#L-210"><span class="linenos">210</span></a><span class="sd">        inserted vertex is returned. &quot;&quot;&quot;</span>
</span><span id="L-211"><a href="#L-211"><span class="linenos">211</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_split_face_by_vertex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span><span class="n">fid</span><span class="p">)</span>
</span><span id="L-212"><a href="#L-212"><span class="linenos">212</span></a>    <span class="k">def</span> <span class="nf">split_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hid</span><span class="p">):</span>
</span><span id="L-213"><a href="#L-213"><span class="linenos">213</span></a>        <span class="sd">&quot;&quot;&quot;   Insert a new vertex on halfedge hid. The new halfedge is insterted</span>
</span><span id="L-214"><a href="#L-214"><span class="linenos">214</span></a><span class="sd">        as the previous edge to hid. The vertex id of the inserted vertex is returned. &quot;&quot;&quot;</span>
</span><span id="L-215"><a href="#L-215"><span class="linenos">215</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_split_edge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span><span class="n">hid</span><span class="p">)</span>
</span><span id="L-216"><a href="#L-216"><span class="linenos">216</span></a>    <span class="k">def</span> <span class="nf">stitch_boundary_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">h0</span><span class="p">,</span><span class="n">h1</span><span class="p">):</span>
</span><span id="L-217"><a href="#L-217"><span class="linenos">217</span></a>        <span class="sd">&quot;&quot;&quot;   Stitch two halfedges. Two boundary halfedges, h0 and h1, can be stitched</span>
</span><span id="L-218"><a href="#L-218"><span class="linenos">218</span></a><span class="sd">        together. This can be used to build a complex mesh from a bunch of</span>
</span><span id="L-219"><a href="#L-219"><span class="linenos">219</span></a><span class="sd">        simple faces. &quot;&quot;&quot;</span>
</span><span id="L-220"><a href="#L-220"><span class="linenos">220</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_stitch_boundary_edges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">h0</span><span class="p">,</span> <span class="n">h1</span><span class="p">)</span>
</span><span id="L-221"><a href="#L-221"><span class="linenos">221</span></a>    <span class="k">def</span> <span class="nf">merge_faces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hid</span><span class="p">):</span>
</span><span id="L-222"><a href="#L-222"><span class="linenos">222</span></a>        <span class="sd">&quot;&quot;&quot;   Merges two faces into a single polygon. The merged faces are those shared</span>
</span><span id="L-223"><a href="#L-223"><span class="linenos">223</span></a><span class="sd">        by the edge for which hid is one of the two corresponding halfedges. This function returns</span>
</span><span id="L-224"><a href="#L-224"><span class="linenos">224</span></a><span class="sd">        true if the merging was possible and false otherwise. Currently merge</span>
</span><span id="L-225"><a href="#L-225"><span class="linenos">225</span></a><span class="sd">        only fails if the mesh is already illegal. Thus it should, in fact,</span>
</span><span id="L-226"><a href="#L-226"><span class="linenos">226</span></a><span class="sd">        never fail. &quot;&quot;&quot;</span>
</span><span id="L-227"><a href="#L-227"><span class="linenos">227</span></a>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_halfedge_at_boundary</span><span class="p">(</span><span class="n">hid</span><span class="p">):</span>
</span><span id="L-228"><a href="#L-228"><span class="linenos">228</span></a>            <span class="k">return</span> <span class="kc">False</span>
</span><span id="L-229"><a href="#L-229"><span class="linenos">229</span></a>        <span class="n">fid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">incident_face</span><span class="p">(</span><span class="n">hid</span><span class="p">)</span>
</span><span id="L-230"><a href="#L-230"><span class="linenos">230</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_merge_faces</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">hid</span><span class="p">)</span>
</span><span id="L-231"><a href="#L-231"><span class="linenos">231</span></a>    <span class="k">def</span> <span class="nf">close_hole</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hid</span><span class="p">):</span>
</span><span id="L-232"><a href="#L-232"><span class="linenos">232</span></a>        <span class="sd">&quot;&quot;&quot; Close hole given by hid (i.e. the face referenced by hid). Returns</span>
</span><span id="L-233"><a href="#L-233"><span class="linenos">233</span></a><span class="sd">        index of the created face or the face that was already there if, in</span>
</span><span id="L-234"><a href="#L-234"><span class="linenos">234</span></a><span class="sd">        fact, hid was not next to a hole. &quot;&quot;&quot;</span>
</span><span id="L-235"><a href="#L-235"><span class="linenos">235</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_close_hole</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">hid</span><span class="p">)</span>
</span><span id="L-236"><a href="#L-236"><span class="linenos">236</span></a>    <span class="k">def</span> <span class="nf">cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="L-237"><a href="#L-237"><span class="linenos">237</span></a>        <span class="sd">&quot;&quot;&quot; Remove unused items from Mesh. This function remaps all vertices, halfedges</span>
</span><span id="L-238"><a href="#L-238"><span class="linenos">238</span></a><span class="sd">        and faces such that the arrays do not contain any holes left by unused mesh</span>
</span><span id="L-239"><a href="#L-239"><span class="linenos">239</span></a><span class="sd">        entities. It is a good idea to call this function when a mesh has been simplified</span>
</span><span id="L-240"><a href="#L-240"><span class="linenos">240</span></a><span class="sd">        or changed in other ways such that mesh entities have been removed. However, note</span>
</span><span id="L-241"><a href="#L-241"><span class="linenos">241</span></a><span class="sd">        that it invalidates any attributes that you might have stored in auxilliary arrays.&quot;&quot;&quot;</span>
</span><span id="L-242"><a href="#L-242"><span class="linenos">242</span></a>        <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_cleanup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="L-243"><a href="#L-243"><span class="linenos">243</span></a>    <span class="k">def</span> <span class="nf">is_halfedge_at_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hid</span><span class="p">):</span>
</span><span id="L-244"><a href="#L-244"><span class="linenos">244</span></a>        <span class="sd">&quot;&quot;&quot; Returns True if hid is a boundary halfedge, i.e. face on either</span>
</span><span id="L-245"><a href="#L-245"><span class="linenos">245</span></a><span class="sd">        side is invalid. &quot;&quot;&quot;</span>
</span><span id="L-246"><a href="#L-246"><span class="linenos">246</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">is_halfedge_at_boundary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">hid</span><span class="p">)</span>
</span><span id="L-247"><a href="#L-247"><span class="linenos">247</span></a>    <span class="k">def</span> <span class="nf">is_vertex_at_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vid</span><span class="p">):</span>
</span><span id="L-248"><a href="#L-248"><span class="linenos">248</span></a>        <span class="sd">&quot;&quot;&quot; Returns True if vid lies on a boundary. &quot;&quot;&quot;</span>
</span><span id="L-249"><a href="#L-249"><span class="linenos">249</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">is_vertex_at_boundary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">vid</span><span class="p">)</span>
</span><span id="L-250"><a href="#L-250"><span class="linenos">250</span></a>    <span class="k">def</span> <span class="nf">edge_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hid</span><span class="p">):</span>
</span><span id="L-251"><a href="#L-251"><span class="linenos">251</span></a>        <span class="sd">&quot;&quot;&quot; Returns length of edge given by halfedge hid which is passed as argument. &quot;&quot;&quot;</span>
</span><span id="L-252"><a href="#L-252"><span class="linenos">252</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">length</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">hid</span><span class="p">)</span>
</span><span id="L-253"><a href="#L-253"><span class="linenos">253</span></a>    <span class="k">def</span> <span class="nf">valency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">vid</span><span class="p">):</span>
</span><span id="L-254"><a href="#L-254"><span class="linenos">254</span></a>        <span class="sd">&quot;&quot;&quot; Returns valency of vid, i.e. number of incident edges.&quot;&quot;&quot;</span>
</span><span id="L-255"><a href="#L-255"><span class="linenos">255</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">valency</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span><span class="n">vid</span><span class="p">)</span>
</span><span id="L-256"><a href="#L-256"><span class="linenos">256</span></a>    <span class="k">def</span> <span class="nf">vertex_normal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vid</span><span class="p">):</span>
</span><span id="L-257"><a href="#L-257"><span class="linenos">257</span></a>        <span class="sd">&quot;&quot;&quot; Returns vertex normal (angle weighted) of vertex given by vid &quot;&quot;&quot;</span>
</span><span id="L-258"><a href="#L-258"><span class="linenos">258</span></a>        <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">c_double</span><span class="o">*</span><span class="mi">3</span><span class="p">)()</span>
</span><span id="L-259"><a href="#L-259"><span class="linenos">259</span></a>        <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">vertex_normal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">vid</span><span class="p">,</span> <span class="n">ct</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
</span><span id="L-260"><a href="#L-260"><span class="linenos">260</span></a>        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
</span><span id="L-261"><a href="#L-261"><span class="linenos">261</span></a>    <span class="k">def</span> <span class="nf">connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">):</span>
</span><span id="L-262"><a href="#L-262"><span class="linenos">262</span></a>        <span class="sd">&quot;&quot;&quot; Returns true if the two argument vertices, v0 and v1, are in each other&#39;s one-rings.&quot;&quot;&quot;</span>
</span><span id="L-263"><a href="#L-263"><span class="linenos">263</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">connected</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span><span class="n">v0</span><span class="p">,</span><span class="n">v1</span><span class="p">)</span>
</span><span id="L-264"><a href="#L-264"><span class="linenos">264</span></a>    <span class="k">def</span> <span class="nf">no_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fid</span><span class="p">):</span>
</span><span id="L-265"><a href="#L-265"><span class="linenos">265</span></a>        <span class="sd">&quot;&quot;&quot; Compute the number of edges of a face fid &quot;&quot;&quot;</span>
</span><span id="L-266"><a href="#L-266"><span class="linenos">266</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">no_edges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">fid</span><span class="p">)</span>
</span><span id="L-267"><a href="#L-267"><span class="linenos">267</span></a>    <span class="k">def</span> <span class="nf">face_normal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fid</span><span class="p">):</span>
</span><span id="L-268"><a href="#L-268"><span class="linenos">268</span></a>        <span class="sd">&quot;&quot;&quot; Compute the normal of a face fid. If the face is not a triangle,</span>
</span><span id="L-269"><a href="#L-269"><span class="linenos">269</span></a><span class="sd">        the normal is not defined, but computed using the first three</span>
</span><span id="L-270"><a href="#L-270"><span class="linenos">270</span></a><span class="sd">        vertices of the face. &quot;&quot;&quot;</span>
</span><span id="L-271"><a href="#L-271"><span class="linenos">271</span></a>        <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">c_double</span><span class="o">*</span><span class="mi">3</span><span class="p">)()</span>
</span><span id="L-272"><a href="#L-272"><span class="linenos">272</span></a>        <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">face_normal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">ct</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
</span><span id="L-273"><a href="#L-273"><span class="linenos">273</span></a>        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
</span><span id="L-274"><a href="#L-274"><span class="linenos">274</span></a>    <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fid</span><span class="p">):</span>
</span><span id="L-275"><a href="#L-275"><span class="linenos">275</span></a>        <span class="sd">&quot;&quot;&quot; Returns the area of a face fid. &quot;&quot;&quot;</span>
</span><span id="L-276"><a href="#L-276"><span class="linenos">276</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">area</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">fid</span><span class="p">)</span>
</span><span id="L-277"><a href="#L-277"><span class="linenos">277</span></a>    <span class="k">def</span> <span class="nf">perimeter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fid</span><span class="p">):</span>
</span><span id="L-278"><a href="#L-278"><span class="linenos">278</span></a>        <span class="sd">&quot;&quot;&quot; Returns the perimeter of a face fid. &quot;&quot;&quot;</span>
</span><span id="L-279"><a href="#L-279"><span class="linenos">279</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">perimeter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">fid</span><span class="p">)</span>
</span><span id="L-280"><a href="#L-280"><span class="linenos">280</span></a>    <span class="k">def</span> <span class="nf">centre</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fid</span><span class="p">):</span>
</span><span id="L-281"><a href="#L-281"><span class="linenos">281</span></a>        <span class="sd">&quot;&quot;&quot; Returns the centre of a face. &quot;&quot;&quot;</span>
</span><span id="L-282"><a href="#L-282"><span class="linenos">282</span></a>        <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">c_double</span><span class="o">*</span><span class="mi">3</span><span class="p">)()</span>
</span><span id="L-283"><a href="#L-283"><span class="linenos">283</span></a>        <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">centre</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">ct</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
</span><span id="L-284"><a href="#L-284"><span class="linenos">284</span></a>        <span class="k">return</span> <span class="n">v</span>
</span><span id="L-285"><a href="#L-285"><span class="linenos">285</span></a>
</span><span id="L-286"><a href="#L-286"><span class="linenos">286</span></a><span class="k">def</span> <span class="nf">valid</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
</span><span id="L-287"><a href="#L-287"><span class="linenos">287</span></a>    <span class="sd">&quot;&quot;&quot;This function performs a series of tests to check that this</span>
</span><span id="L-288"><a href="#L-288"><span class="linenos">288</span></a><span class="sd">    is a valid manifold. This function is not rigorously constructed but seems</span>
</span><span id="L-289"><a href="#L-289"><span class="linenos">289</span></a><span class="sd">    to catch all problems so far. The function returns true if the mesh is valid</span>
</span><span id="L-290"><a href="#L-290"><span class="linenos">290</span></a><span class="sd">    and false otherwise. &quot;&quot;&quot;</span>
</span><span id="L-291"><a href="#L-291"><span class="linenos">291</span></a>    <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">valid</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="L-292"><a href="#L-292"><span class="linenos">292</span></a>
</span><span id="L-293"><a href="#L-293"><span class="linenos">293</span></a><span class="k">def</span> <span class="nf">closed</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
</span><span id="L-294"><a href="#L-294"><span class="linenos">294</span></a>    <span class="sd">&quot;&quot;&quot; Returns true if m is closed, i.e. has no boundary.&quot;&quot;&quot;</span>
</span><span id="L-295"><a href="#L-295"><span class="linenos">295</span></a>    <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">closed</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="L-296"><a href="#L-296"><span class="linenos">296</span></a>
</span><span id="L-297"><a href="#L-297"><span class="linenos">297</span></a><span class="k">def</span> <span class="nf">bbox</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
</span><span id="L-298"><a href="#L-298"><span class="linenos">298</span></a>    <span class="sd">&quot;&quot;&quot; Returns the min and max corners of the bounding box of Manifold m. &quot;&quot;&quot;</span>
</span><span id="L-299"><a href="#L-299"><span class="linenos">299</span></a>    <span class="n">pmin</span> <span class="o">=</span> <span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">c_double</span><span class="o">*</span><span class="mi">3</span><span class="p">)()</span>
</span><span id="L-300"><a href="#L-300"><span class="linenos">300</span></a>    <span class="n">pmax</span> <span class="o">=</span> <span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">c_double</span><span class="o">*</span><span class="mi">3</span><span class="p">)()</span>
</span><span id="L-301"><a href="#L-301"><span class="linenos">301</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">bbox</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">ct</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">pmin</span><span class="p">),</span><span class="n">ct</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">pmax</span><span class="p">))</span>
</span><span id="L-302"><a href="#L-302"><span class="linenos">302</span></a>    <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">as_array</span><span class="p">(</span><span class="n">pmin</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">as_array</span><span class="p">(</span><span class="n">pmax</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
</span><span id="L-303"><a href="#L-303"><span class="linenos">303</span></a>
</span><span id="L-304"><a href="#L-304"><span class="linenos">304</span></a><span class="k">def</span> <span class="nf">bsphere</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
</span><span id="L-305"><a href="#L-305"><span class="linenos">305</span></a>    <span class="sd">&quot;&quot;&quot; Calculate the bounding sphere of the manifold m.</span>
</span><span id="L-306"><a href="#L-306"><span class="linenos">306</span></a><span class="sd">    Returns centre,radius &quot;&quot;&quot;</span>
</span><span id="L-307"><a href="#L-307"><span class="linenos">307</span></a>    <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">c_double</span><span class="o">*</span><span class="mi">3</span><span class="p">)()</span>
</span><span id="L-308"><a href="#L-308"><span class="linenos">308</span></a>    <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">c_double</span><span class="p">)()</span>
</span><span id="L-309"><a href="#L-309"><span class="linenos">309</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">bsphere</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span><span class="n">ct</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">c</span><span class="p">),</span><span class="n">ct</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
</span><span id="L-310"><a href="#L-310"><span class="linenos">310</span></a>    <span class="k">return</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
</span><span id="L-311"><a href="#L-311"><span class="linenos">311</span></a>
</span><span id="L-312"><a href="#L-312"><span class="linenos">312</span></a><span class="k">def</span> <span class="nf">stitch</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">rad</span><span class="o">=</span><span class="mf">1e-30</span><span class="p">):</span>
</span><span id="L-313"><a href="#L-313"><span class="linenos">313</span></a>    <span class="sd">&quot;&quot;&quot; Stitch together edges of m whose endpoints coincide geometrically. This</span>
</span><span id="L-314"><a href="#L-314"><span class="linenos">314</span></a><span class="sd">    function allows you to create a mesh as a bunch of faces and then stitch</span>
</span><span id="L-315"><a href="#L-315"><span class="linenos">315</span></a><span class="sd">    these together to form a coherent whole. What this function adds is a</span>
</span><span id="L-316"><a href="#L-316"><span class="linenos">316</span></a><span class="sd">    spatial data structure to find out which vertices coincide. The return value</span>
</span><span id="L-317"><a href="#L-317"><span class="linenos">317</span></a><span class="sd">    is the number of edges that could not be stitched. Often this is because it</span>
</span><span id="L-318"><a href="#L-318"><span class="linenos">318</span></a><span class="sd">    would introduce a non-manifold situation.&quot;&quot;&quot;</span>
</span><span id="L-319"><a href="#L-319"><span class="linenos">319</span></a>    <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">stitch_mesh</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span><span class="n">rad</span><span class="p">)</span>
</span><span id="L-320"><a href="#L-320"><span class="linenos">320</span></a>
</span><span id="L-321"><a href="#L-321"><span class="linenos">321</span></a><span class="k">def</span> <span class="nf">obj_save</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
</span><span id="L-322"><a href="#L-322"><span class="linenos">322</span></a>    <span class="sd">&quot;&quot;&quot; Save Manifold m to Wavefront obj file. &quot;&quot;&quot;</span>
</span><span id="L-323"><a href="#L-323"><span class="linenos">323</span></a>    <span class="n">s</span> <span class="o">=</span> <span class="n">ct</span><span class="o">.</span><span class="n">c_char_p</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
</span><span id="L-324"><a href="#L-324"><span class="linenos">324</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">obj_save</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="L-325"><a href="#L-325"><span class="linenos">325</span></a>
</span><span id="L-326"><a href="#L-326"><span class="linenos">326</span></a><span class="k">def</span> <span class="nf">off_save</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
</span><span id="L-327"><a href="#L-327"><span class="linenos">327</span></a>    <span class="sd">&quot;&quot;&quot; Save Manifold m to OFF file. &quot;&quot;&quot;</span>
</span><span id="L-328"><a href="#L-328"><span class="linenos">328</span></a>    <span class="n">s</span> <span class="o">=</span> <span class="n">ct</span><span class="o">.</span><span class="n">c_char_p</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
</span><span id="L-329"><a href="#L-329"><span class="linenos">329</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">off_save</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="L-330"><a href="#L-330"><span class="linenos">330</span></a>
</span><span id="L-331"><a href="#L-331"><span class="linenos">331</span></a><span class="k">def</span> <span class="nf">x3d_save</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
</span><span id="L-332"><a href="#L-332"><span class="linenos">332</span></a>    <span class="sd">&quot;&quot;&quot; Save Manifold m to X3D file. &quot;&quot;&quot;</span>
</span><span id="L-333"><a href="#L-333"><span class="linenos">333</span></a>    <span class="n">s</span> <span class="o">=</span> <span class="n">ct</span><span class="o">.</span><span class="n">c_char_p</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
</span><span id="L-334"><a href="#L-334"><span class="linenos">334</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">x3d_save</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="L-335"><a href="#L-335"><span class="linenos">335</span></a>
</span><span id="L-336"><a href="#L-336"><span class="linenos">336</span></a><span class="k">def</span> <span class="nf">obj_load</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
</span><span id="L-337"><a href="#L-337"><span class="linenos">337</span></a>    <span class="sd">&quot;&quot;&quot; Load and return Manifold from Wavefront obj file.</span>
</span><span id="L-338"><a href="#L-338"><span class="linenos">338</span></a><span class="sd">    Returns None if loading failed. &quot;&quot;&quot;</span>
</span><span id="L-339"><a href="#L-339"><span class="linenos">339</span></a>    <span class="n">m</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">()</span>
</span><span id="L-340"><a href="#L-340"><span class="linenos">340</span></a>    <span class="n">s</span> <span class="o">=</span> <span class="n">ct</span><span class="o">.</span><span class="n">c_char_p</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
</span><span id="L-341"><a href="#L-341"><span class="linenos">341</span></a>    <span class="k">if</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">obj_load</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">):</span>
</span><span id="L-342"><a href="#L-342"><span class="linenos">342</span></a>        <span class="k">return</span> <span class="n">m</span>
</span><span id="L-343"><a href="#L-343"><span class="linenos">343</span></a>    <span class="k">return</span> <span class="kc">None</span>
</span><span id="L-344"><a href="#L-344"><span class="linenos">344</span></a>
</span><span id="L-345"><a href="#L-345"><span class="linenos">345</span></a><span class="k">def</span> <span class="nf">off_load</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
</span><span id="L-346"><a href="#L-346"><span class="linenos">346</span></a>    <span class="sd">&quot;&quot;&quot; Load and return Manifold from OFF file.</span>
</span><span id="L-347"><a href="#L-347"><span class="linenos">347</span></a><span class="sd">    Returns None if loading failed.&quot;&quot;&quot;</span>
</span><span id="L-348"><a href="#L-348"><span class="linenos">348</span></a>    <span class="n">m</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">()</span>
</span><span id="L-349"><a href="#L-349"><span class="linenos">349</span></a>    <span class="n">s</span> <span class="o">=</span> <span class="n">ct</span><span class="o">.</span><span class="n">c_char_p</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
</span><span id="L-350"><a href="#L-350"><span class="linenos">350</span></a>    <span class="k">if</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">off_load</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">):</span>
</span><span id="L-351"><a href="#L-351"><span class="linenos">351</span></a>        <span class="k">return</span> <span class="n">m</span>
</span><span id="L-352"><a href="#L-352"><span class="linenos">352</span></a>    <span class="k">return</span> <span class="kc">None</span>
</span><span id="L-353"><a href="#L-353"><span class="linenos">353</span></a>
</span><span id="L-354"><a href="#L-354"><span class="linenos">354</span></a><span class="k">def</span> <span class="nf">ply_load</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
</span><span id="L-355"><a href="#L-355"><span class="linenos">355</span></a>    <span class="sd">&quot;&quot;&quot; Load and return Manifold from Stanford PLY file.</span>
</span><span id="L-356"><a href="#L-356"><span class="linenos">356</span></a><span class="sd">    Returns None if loading failed. &quot;&quot;&quot;</span>
</span><span id="L-357"><a href="#L-357"><span class="linenos">357</span></a>    <span class="n">m</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">()</span>
</span><span id="L-358"><a href="#L-358"><span class="linenos">358</span></a>    <span class="n">s</span> <span class="o">=</span> <span class="n">ct</span><span class="o">.</span><span class="n">c_char_p</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
</span><span id="L-359"><a href="#L-359"><span class="linenos">359</span></a>    <span class="k">if</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">ply_load</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">):</span>
</span><span id="L-360"><a href="#L-360"><span class="linenos">360</span></a>        <span class="k">return</span> <span class="n">m</span>
</span><span id="L-361"><a href="#L-361"><span class="linenos">361</span></a>    <span class="k">return</span> <span class="kc">None</span>
</span><span id="L-362"><a href="#L-362"><span class="linenos">362</span></a>
</span><span id="L-363"><a href="#L-363"><span class="linenos">363</span></a><span class="k">def</span> <span class="nf">x3d_load</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
</span><span id="L-364"><a href="#L-364"><span class="linenos">364</span></a>    <span class="sd">&quot;&quot;&quot; Load and return Manifold from X3D file.</span>
</span><span id="L-365"><a href="#L-365"><span class="linenos">365</span></a><span class="sd">    Returns None if loading failed.&quot;&quot;&quot;</span>
</span><span id="L-366"><a href="#L-366"><span class="linenos">366</span></a>    <span class="n">m</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">()</span>
</span><span id="L-367"><a href="#L-367"><span class="linenos">367</span></a>    <span class="n">s</span> <span class="o">=</span> <span class="n">ct</span><span class="o">.</span><span class="n">c_char_p</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
</span><span id="L-368"><a href="#L-368"><span class="linenos">368</span></a>    <span class="k">if</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">x3d_load</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">):</span>
</span><span id="L-369"><a href="#L-369"><span class="linenos">369</span></a>        <span class="k">return</span> <span class="n">m</span>
</span><span id="L-370"><a href="#L-370"><span class="linenos">370</span></a>    <span class="k">return</span> <span class="kc">None</span>
</span><span id="L-371"><a href="#L-371"><span class="linenos">371</span></a>
</span><span id="L-372"><a href="#L-372"><span class="linenos">372</span></a><span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">splitext</span>
</span><span id="L-373"><a href="#L-373"><span class="linenos">373</span></a><span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
</span><span id="L-374"><a href="#L-374"><span class="linenos">374</span></a>    <span class="sd">&quot;&quot;&quot; Load a Manifold from an X3D/OBJ/OFF/PLY file. Return the</span>
</span><span id="L-375"><a href="#L-375"><span class="linenos">375</span></a><span class="sd">    loaded Manifold. Returns None if loading failed.&quot;&quot;&quot;</span>
</span><span id="L-376"><a href="#L-376"><span class="linenos">376</span></a>    <span class="n">name</span><span class="p">,</span> <span class="n">extension</span> <span class="o">=</span> <span class="n">splitext</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
</span><span id="L-377"><a href="#L-377"><span class="linenos">377</span></a>    <span class="k">if</span> <span class="n">extension</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;.x3d&quot;</span><span class="p">:</span>
</span><span id="L-378"><a href="#L-378"><span class="linenos">378</span></a>        <span class="k">return</span> <span class="n">x3d_load</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
</span><span id="L-379"><a href="#L-379"><span class="linenos">379</span></a>    <span class="k">if</span> <span class="n">extension</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;.obj&quot;</span><span class="p">:</span>
</span><span id="L-380"><a href="#L-380"><span class="linenos">380</span></a>        <span class="k">return</span> <span class="n">obj_load</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
</span><span id="L-381"><a href="#L-381"><span class="linenos">381</span></a>    <span class="k">if</span> <span class="n">extension</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;.off&quot;</span><span class="p">:</span>
</span><span id="L-382"><a href="#L-382"><span class="linenos">382</span></a>        <span class="k">return</span> <span class="n">off_load</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
</span><span id="L-383"><a href="#L-383"><span class="linenos">383</span></a>    <span class="k">if</span> <span class="n">extension</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;.ply&quot;</span><span class="p">:</span>
</span><span id="L-384"><a href="#L-384"><span class="linenos">384</span></a>        <span class="k">return</span> <span class="n">ply_load</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
</span><span id="L-385"><a href="#L-385"><span class="linenos">385</span></a>    <span class="k">return</span> <span class="kc">None</span>
</span><span id="L-386"><a href="#L-386"><span class="linenos">386</span></a>
</span><span id="L-387"><a href="#L-387"><span class="linenos">387</span></a><span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
</span><span id="L-388"><a href="#L-388"><span class="linenos">388</span></a>    <span class="sd">&quot;&quot;&quot; Save a Manifold, m, to an X3D/OBJ/OFF file. &quot;&quot;&quot;</span>
</span><span id="L-389"><a href="#L-389"><span class="linenos">389</span></a>    <span class="n">name</span><span class="p">,</span> <span class="n">extension</span> <span class="o">=</span> <span class="n">splitext</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
</span><span id="L-390"><a href="#L-390"><span class="linenos">390</span></a>    <span class="k">if</span> <span class="n">extension</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;.x3d&quot;</span><span class="p">:</span>
</span><span id="L-391"><a href="#L-391"><span class="linenos">391</span></a>        <span class="n">x3d_save</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</span><span id="L-392"><a href="#L-392"><span class="linenos">392</span></a>    <span class="k">elif</span> <span class="n">extension</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;.obj&quot;</span><span class="p">:</span>
</span><span id="L-393"><a href="#L-393"><span class="linenos">393</span></a>        <span class="n">obj_save</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</span><span id="L-394"><a href="#L-394"><span class="linenos">394</span></a>    <span class="k">elif</span> <span class="n">extension</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;.off&quot;</span><span class="p">:</span>
</span><span id="L-395"><a href="#L-395"><span class="linenos">395</span></a>        <span class="n">off_save</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</span><span id="L-396"><a href="#L-396"><span class="linenos">396</span></a>
</span><span id="L-397"><a href="#L-397"><span class="linenos">397</span></a>
</span><span id="L-398"><a href="#L-398"><span class="linenos">398</span></a><span class="k">def</span> <span class="nf">remove_caps</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mf">2.9</span><span class="p">):</span>
</span><span id="L-399"><a href="#L-399"><span class="linenos">399</span></a>    <span class="sd">&quot;&quot;&quot; Remove caps from a manifold, m, consisting of only triangles. A cap is a</span>
</span><span id="L-400"><a href="#L-400"><span class="linenos">400</span></a><span class="sd">    triangle with two very small angles and an angle close to pi, however a cap</span>
</span><span id="L-401"><a href="#L-401"><span class="linenos">401</span></a><span class="sd">    does not necessarily have a very short edge. Set the ang_thresh to a value</span>
</span><span id="L-402"><a href="#L-402"><span class="linenos">402</span></a><span class="sd">    close to pi. The closer to pi the _less_ sensitive the cap removal. A cap is</span>
</span><span id="L-403"><a href="#L-403"><span class="linenos">403</span></a><span class="sd">    removed by flipping the (long) edge E opposite to the vertex V with the</span>
</span><span id="L-404"><a href="#L-404"><span class="linenos">404</span></a><span class="sd">    angle close to pi. However, the function is more complex. Read code and</span>
</span><span id="L-405"><a href="#L-405"><span class="linenos">405</span></a><span class="sd">    document more carefully !!! &quot;&quot;&quot;</span>
</span><span id="L-406"><a href="#L-406"><span class="linenos">406</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">remove_caps</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span><span class="n">thresh</span><span class="p">)</span>
</span><span id="L-407"><a href="#L-407"><span class="linenos">407</span></a>
</span><span id="L-408"><a href="#L-408"><span class="linenos">408</span></a><span class="k">def</span> <span class="nf">remove_needles</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">average_positions</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="L-409"><a href="#L-409"><span class="linenos">409</span></a>    <span class="sd">&quot;&quot;&quot;  Remove needles from a manifold, m, consisting of only triangles. A needle</span>
</span><span id="L-410"><a href="#L-410"><span class="linenos">410</span></a><span class="sd">    is a triangle with a single very short edge. It is moved by collapsing the</span>
</span><span id="L-411"><a href="#L-411"><span class="linenos">411</span></a><span class="sd">    short edge. The thresh parameter sets the length threshold (in terms of the average edge length</span>
</span><span id="L-412"><a href="#L-412"><span class="linenos">412</span></a><span class="sd">    in the mesh). If average_positions is true then the collapsed vertex is placed at the average position of the end points.&quot;&quot;&quot;</span>
</span><span id="L-413"><a href="#L-413"><span class="linenos">413</span></a>    <span class="n">abs_thresh</span> <span class="o">=</span> <span class="n">thresh</span> <span class="o">*</span> <span class="n">average_edge_length</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
</span><span id="L-414"><a href="#L-414"><span class="linenos">414</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">remove_needles</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span><span class="n">abs_thresh</span><span class="p">,</span> <span class="n">average_positions</span><span class="p">)</span>
</span><span id="L-415"><a href="#L-415"><span class="linenos">415</span></a>
</span><span id="L-416"><a href="#L-416"><span class="linenos">416</span></a><span class="k">def</span> <span class="nf">close_holes</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">max_size</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
</span><span id="L-417"><a href="#L-417"><span class="linenos">417</span></a>    <span class="sd">&quot;&quot;&quot;  This function replaces holes in m by faces. It is really a simple function</span>
</span><span id="L-418"><a href="#L-418"><span class="linenos">418</span></a><span class="sd">    that just finds all loops of edges next to missing faces. &quot;&quot;&quot;</span>
</span><span id="L-419"><a href="#L-419"><span class="linenos">419</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">close_holes</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">max_size</span><span class="p">)</span>
</span><span id="L-420"><a href="#L-420"><span class="linenos">420</span></a>
</span><span id="L-421"><a href="#L-421"><span class="linenos">421</span></a><span class="k">def</span> <span class="nf">flip_orientation</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
</span><span id="L-422"><a href="#L-422"><span class="linenos">422</span></a>    <span class="sd">&quot;&quot;&quot;  Flip the orientation of a mesh, m. After calling this function, normals</span>
</span><span id="L-423"><a href="#L-423"><span class="linenos">423</span></a><span class="sd">    will point the other way and clockwise becomes counter clockwise &quot;&quot;&quot;</span>
</span><span id="L-424"><a href="#L-424"><span class="linenos">424</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">flip_orientation</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="L-425"><a href="#L-425"><span class="linenos">425</span></a>
</span><span id="L-426"><a href="#L-426"><span class="linenos">426</span></a><span class="k">def</span> <span class="nf">merge_coincident_boundary_vertices</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">rad</span> <span class="o">=</span> <span class="mf">1.0e-30</span><span class="p">):</span>
</span><span id="L-427"><a href="#L-427"><span class="linenos">427</span></a>    <span class="sd">&quot;&quot;&quot;  Merge vertices of m that are boundary vertices and coincident.</span>
</span><span id="L-428"><a href="#L-428"><span class="linenos">428</span></a><span class="sd">        However, if one belongs to the other&#39;s one ring or the one</span>
</span><span id="L-429"><a href="#L-429"><span class="linenos">429</span></a><span class="sd">        rings share a vertex, they will not be merged. &quot;&quot;&quot;</span>
</span><span id="L-430"><a href="#L-430"><span class="linenos">430</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">merge_coincident_boundary_vertices</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">rad</span><span class="p">)</span>
</span><span id="L-431"><a href="#L-431"><span class="linenos">431</span></a>
</span><span id="L-432"><a href="#L-432"><span class="linenos">432</span></a><span class="k">def</span> <span class="nf">minimize_curvature</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">anneal</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="L-433"><a href="#L-433"><span class="linenos">433</span></a>    <span class="sd">&quot;&quot;&quot; Minimizes mean curvature of m by flipping edges. Hence, no vertices are moved.</span>
</span><span id="L-434"><a href="#L-434"><span class="linenos">434</span></a><span class="sd">     This is really the same as dihedral angle minimization, except that we weight by edge length. &quot;&quot;&quot;</span>
</span><span id="L-435"><a href="#L-435"><span class="linenos">435</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">minimize_curvature</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">anneal</span><span class="p">)</span>
</span><span id="L-436"><a href="#L-436"><span class="linenos">436</span></a>
</span><span id="L-437"><a href="#L-437"><span class="linenos">437</span></a><span class="k">def</span> <span class="nf">minimize_dihedral_angle</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">anneal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mf">4.0</span><span class="p">):</span>
</span><span id="L-438"><a href="#L-438"><span class="linenos">438</span></a>    <span class="sd">&quot;&quot;&quot; Minimizes dihedral angles in m by flipping edges.</span>
</span><span id="L-439"><a href="#L-439"><span class="linenos">439</span></a><span class="sd">        Arguments:</span>
</span><span id="L-440"><a href="#L-440"><span class="linenos">440</span></a><span class="sd">        max_iter is the maximum number of iterations for simulated annealing.</span>
</span><span id="L-441"><a href="#L-441"><span class="linenos">441</span></a><span class="sd">        anneal tells us the code whether to apply simulated annealing</span>
</span><span id="L-442"><a href="#L-442"><span class="linenos">442</span></a><span class="sd">        alpha=False means that we use the cosine of angles rather than true angles (faster)</span>
</span><span id="L-443"><a href="#L-443"><span class="linenos">443</span></a><span class="sd">        gamma is the power to which the angles are raised.&quot;&quot;&quot;</span>
</span><span id="L-444"><a href="#L-444"><span class="linenos">444</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">minimize_dihedral_angle</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">,</span> <span class="n">anneal</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span><span class="n">ct</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span><span class="n">gamma</span><span class="p">))</span>
</span><span id="L-445"><a href="#L-445"><span class="linenos">445</span></a>
</span><span id="L-446"><a href="#L-446"><span class="linenos">446</span></a>
</span><span id="L-447"><a href="#L-447"><span class="linenos">447</span></a><span class="k">def</span> <span class="nf">maximize_min_angle</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">dihedral_thresh</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span><span class="n">anneal</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="L-448"><a href="#L-448"><span class="linenos">448</span></a>    <span class="sd">&quot;&quot;&quot; Maximizes the minimum angle of triangles by flipping edges of m. Makes the mesh more Delaunay.&quot;&quot;&quot;</span>
</span><span id="L-449"><a href="#L-449"><span class="linenos">449</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">maximize_min_angle</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span><span class="n">dihedral_thresh</span><span class="p">,</span><span class="n">anneal</span><span class="p">)</span>
</span><span id="L-450"><a href="#L-450"><span class="linenos">450</span></a>
</span><span id="L-451"><a href="#L-451"><span class="linenos">451</span></a><span class="k">def</span> <span class="nf">optimize_valency</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">anneal</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="L-452"><a href="#L-452"><span class="linenos">452</span></a>    <span class="sd">&quot;&quot;&quot; Tries to achieve valence 6 internally and 4 along edges by flipping edges of m. &quot;&quot;&quot;</span>
</span><span id="L-453"><a href="#L-453"><span class="linenos">453</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">optimize_valency</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">anneal</span><span class="p">)</span>
</span><span id="L-454"><a href="#L-454"><span class="linenos">454</span></a>
</span><span id="L-455"><a href="#L-455"><span class="linenos">455</span></a><span class="k">def</span> <span class="nf">randomize_mesh</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
</span><span id="L-456"><a href="#L-456"><span class="linenos">456</span></a>    <span class="sd">&quot;&quot;&quot;  Make random flips in m. Useful for generating synthetic test cases. &quot;&quot;&quot;</span>
</span><span id="L-457"><a href="#L-457"><span class="linenos">457</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">randomize_mesh</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">)</span>
</span><span id="L-458"><a href="#L-458"><span class="linenos">458</span></a>
</span><span id="L-459"><a href="#L-459"><span class="linenos">459</span></a><span class="k">def</span> <span class="nf">quadric_simplify</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">keep_fraction</span><span class="p">,</span><span class="n">singular_thresh</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span><span class="n">optimal_positions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
</span><span id="L-460"><a href="#L-460"><span class="linenos">460</span></a>    <span class="sd">&quot;&quot;&quot; Garland Heckbert simplification of mesh m in our own implementation. keep_fraction</span>
</span><span id="L-461"><a href="#L-461"><span class="linenos">461</span></a><span class="sd">    is the fraction of vertices to retain. The singular_thresh defines how small</span>
</span><span id="L-462"><a href="#L-462"><span class="linenos">462</span></a><span class="sd">    singular values from the SVD we accept. It is relative to the greatest</span>
</span><span id="L-463"><a href="#L-463"><span class="linenos">463</span></a><span class="sd">    singular value. If optimal_positions is true, we reposition vertices.</span>
</span><span id="L-464"><a href="#L-464"><span class="linenos">464</span></a><span class="sd">    Otherwise the vertices are a subset of the old vertices.&quot;&quot;&quot;</span>
</span><span id="L-465"><a href="#L-465"><span class="linenos">465</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">quadric_simplify</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">keep_fraction</span><span class="p">,</span> <span class="n">singular_thresh</span><span class="p">,</span><span class="n">optimal_positions</span><span class="p">)</span>
</span><span id="L-466"><a href="#L-466"><span class="linenos">466</span></a>
</span><span id="L-467"><a href="#L-467"><span class="linenos">467</span></a><span class="k">def</span> <span class="nf">average_edge_length</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
</span><span id="L-468"><a href="#L-468"><span class="linenos">468</span></a>    <span class="sd">&quot;&quot;&quot; Returns the average edge length of mesh m. &quot;&quot;&quot;</span>
</span><span id="L-469"><a href="#L-469"><span class="linenos">469</span></a>    <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">average_edge_length</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="L-470"><a href="#L-470"><span class="linenos">470</span></a>
</span><span id="L-471"><a href="#L-471"><span class="linenos">471</span></a><span class="k">def</span> <span class="nf">median_edge_length</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
</span><span id="L-472"><a href="#L-472"><span class="linenos">472</span></a>    <span class="sd">&quot;&quot;&quot; Returns the median edge length of m&quot;&quot;&quot;</span>
</span><span id="L-473"><a href="#L-473"><span class="linenos">473</span></a>    <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">median_edge_length</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="L-474"><a href="#L-474"><span class="linenos">474</span></a>
</span><span id="L-475"><a href="#L-475"><span class="linenos">475</span></a><span class="k">def</span> <span class="nf">refine_edges</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">threshold</span><span class="p">):</span>
</span><span id="L-476"><a href="#L-476"><span class="linenos">476</span></a>    <span class="sd">&quot;&quot;&quot; Split all edges in m which are longer</span>
</span><span id="L-477"><a href="#L-477"><span class="linenos">477</span></a><span class="sd">    than the threshold (second arg) length. A split edge</span>
</span><span id="L-478"><a href="#L-478"><span class="linenos">478</span></a><span class="sd">    results in a new vertex of valence two.&quot;&quot;&quot;</span>
</span><span id="L-479"><a href="#L-479"><span class="linenos">479</span></a>    <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">refine_edges</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
</span><span id="L-480"><a href="#L-480"><span class="linenos">480</span></a>
</span><span id="L-481"><a href="#L-481"><span class="linenos">481</span></a><span class="k">def</span> <span class="nf">cc_split</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
</span><span id="L-482"><a href="#L-482"><span class="linenos">482</span></a>    <span class="sd">&quot;&quot;&quot; Perform a Catmull-Clark split on m, i.e. a split where each face is divided</span>
</span><span id="L-483"><a href="#L-483"><span class="linenos">483</span></a><span class="sd">    into new quadrilateral faces formed by connecting a corner with a point on</span>
</span><span id="L-484"><a href="#L-484"><span class="linenos">484</span></a><span class="sd">    each incident edge and a point at the centre of the face.&quot;&quot;&quot;</span>
</span><span id="L-485"><a href="#L-485"><span class="linenos">485</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">cc_split</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="L-486"><a href="#L-486"><span class="linenos">486</span></a>
</span><span id="L-487"><a href="#L-487"><span class="linenos">487</span></a><span class="k">def</span> <span class="nf">loop_split</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
</span><span id="L-488"><a href="#L-488"><span class="linenos">488</span></a>    <span class="sd">&quot;&quot;&quot; Perform a loop split on m where each edge is divided into two segments, and</span>
</span><span id="L-489"><a href="#L-489"><span class="linenos">489</span></a><span class="sd">    four new triangles are created for each original triangle. &quot;&quot;&quot;</span>
</span><span id="L-490"><a href="#L-490"><span class="linenos">490</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">loop_split</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="L-491"><a href="#L-491"><span class="linenos">491</span></a>
</span><span id="L-492"><a href="#L-492"><span class="linenos">492</span></a><span class="k">def</span> <span class="nf">root3_subdivide</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
</span><span id="L-493"><a href="#L-493"><span class="linenos">493</span></a>    <span class="sd">&quot;&quot;&quot; Leif Kobbelt&#39;s subdivision scheme applied to m. A vertex is placed in the</span>
</span><span id="L-494"><a href="#L-494"><span class="linenos">494</span></a><span class="sd">    center of each face and all old edges are flipped. &quot;&quot;&quot;</span>
</span><span id="L-495"><a href="#L-495"><span class="linenos">495</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">root3_subdivide</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="L-496"><a href="#L-496"><span class="linenos">496</span></a>
</span><span id="L-497"><a href="#L-497"><span class="linenos">497</span></a><span class="k">def</span> <span class="nf">rootCC_subdivide</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
</span><span id="L-498"><a href="#L-498"><span class="linenos">498</span></a>    <span class="sd">&quot;&quot;&quot; This subdivision scheme creates a vertex inside each original (quad) face of m,</span>
</span><span id="L-499"><a href="#L-499"><span class="linenos">499</span></a><span class="sd">    producing four triangles. Triangles sharing an old edge are then merged.</span>
</span><span id="L-500"><a href="#L-500"><span class="linenos">500</span></a><span class="sd">    Two steps produce something similar to Catmull-Clark. &quot;&quot;&quot;</span>
</span><span id="L-501"><a href="#L-501"><span class="linenos">501</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">rootCC_subdivide</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="L-502"><a href="#L-502"><span class="linenos">502</span></a>
</span><span id="L-503"><a href="#L-503"><span class="linenos">503</span></a><span class="k">def</span> <span class="nf">butterfly_subdivide</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
</span><span id="L-504"><a href="#L-504"><span class="linenos">504</span></a>    <span class="sd">&quot;&quot;&quot; Butterfly subidiviosn on m. An interpolatory scheme. Creates the same connectivity as Loop. &quot;&quot;&quot;</span>
</span><span id="L-505"><a href="#L-505"><span class="linenos">505</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">butterfly_subdivide</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="L-506"><a href="#L-506"><span class="linenos">506</span></a>
</span><span id="L-507"><a href="#L-507"><span class="linenos">507</span></a><span class="k">def</span> <span class="nf">cc_smooth</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
</span><span id="L-508"><a href="#L-508"><span class="linenos">508</span></a>    <span class="sd">&quot;&quot;&quot; If called after cc_split, this function completes a step of Catmull-Clark</span>
</span><span id="L-509"><a href="#L-509"><span class="linenos">509</span></a><span class="sd">    subdivision of m.&quot;&quot;&quot;</span>
</span><span id="L-510"><a href="#L-510"><span class="linenos">510</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">cc_smooth</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="L-511"><a href="#L-511"><span class="linenos">511</span></a>
</span><span id="L-512"><a href="#L-512"><span class="linenos">512</span></a><span class="k">def</span> <span class="nf">loop_smooth</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
</span><span id="L-513"><a href="#L-513"><span class="linenos">513</span></a>    <span class="sd">&quot;&quot;&quot; If called after Loop split, this function completes a step of Loop</span>
</span><span id="L-514"><a href="#L-514"><span class="linenos">514</span></a><span class="sd">    subdivision of m. &quot;&quot;&quot;</span>
</span><span id="L-515"><a href="#L-515"><span class="linenos">515</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">loop_smooth</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="L-516"><a href="#L-516"><span class="linenos">516</span></a>
</span><span id="L-517"><a href="#L-517"><span class="linenos">517</span></a><span class="k">def</span> <span class="nf">triangulate</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">clip_ear</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
</span><span id="L-518"><a href="#L-518"><span class="linenos">518</span></a>    <span class="sd">&quot;&quot;&quot; Turn a general polygonal mesh, m, into a triangle mesh by repeatedly</span>
</span><span id="L-519"><a href="#L-519"><span class="linenos">519</span></a><span class="sd">        splitting a polygon into smaller polygons. &quot;&quot;&quot;</span>
</span><span id="L-520"><a href="#L-520"><span class="linenos">520</span></a>    <span class="k">if</span> <span class="n">clip_ear</span><span class="p">:</span>
</span><span id="L-521"><a href="#L-521"><span class="linenos">521</span></a>        <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">ear_clip_triangulate</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="L-522"><a href="#L-522"><span class="linenos">522</span></a>    <span class="k">else</span><span class="p">:</span>
</span><span id="L-523"><a href="#L-523"><span class="linenos">523</span></a>        <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">shortest_edge_triangulate</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="L-524"><a href="#L-524"><span class="linenos">524</span></a>
</span><span id="L-525"><a href="#L-525"><span class="linenos">525</span></a>
</span><span id="L-526"><a href="#L-526"><span class="linenos">526</span></a><span class="k">class</span> <span class="nc">MeshDistance</span><span class="p">:</span>
</span><span id="L-527"><a href="#L-527"><span class="linenos">527</span></a>    <span class="sd">&quot;&quot;&quot; This class allows you to compute the distance from any point in space to</span>
</span><span id="L-528"><a href="#L-528"><span class="linenos">528</span></a><span class="sd">    a Manifold (which must be triangulated). The constructor creates an instance</span>
</span><span id="L-529"><a href="#L-529"><span class="linenos">529</span></a><span class="sd">    based on a specific mesh, and the signed_distance function computes the actual distance. &quot;&quot;&quot;</span>
</span><span id="L-530"><a href="#L-530"><span class="linenos">530</span></a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">m</span><span class="p">):</span>
</span><span id="L-531"><a href="#L-531"><span class="linenos">531</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">obj</span> <span class="o">=</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">MeshDistance_new</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="L-532"><a href="#L-532"><span class="linenos">532</span></a>    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="L-533"><a href="#L-533"><span class="linenos">533</span></a>        <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">MeshDistance_delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="L-534"><a href="#L-534"><span class="linenos">534</span></a>    <span class="k">def</span> <span class="nf">signed_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pts</span><span class="p">,</span><span class="n">upper</span><span class="o">=</span><span class="mf">1e30</span><span class="p">):</span>
</span><span id="L-535"><a href="#L-535"><span class="linenos">535</span></a>        <span class="sd">&quot;&quot;&quot; Compute the signed distance from each point in pts to the mesh stored in </span>
</span><span id="L-536"><a href="#L-536"><span class="linenos">536</span></a><span class="sd">        this class instance. pts should be convertible to a length N&gt;=1 array of 3D </span>
</span><span id="L-537"><a href="#L-537"><span class="linenos">537</span></a><span class="sd">        points. The function returns an array of N distance values with a single distance </span>
</span><span id="L-538"><a href="#L-538"><span class="linenos">538</span></a><span class="sd">        for each point. The distance corresponding to a point is positive if the point </span>
</span><span id="L-539"><a href="#L-539"><span class="linenos">539</span></a><span class="sd">        is outside and negative if inside. The upper parameter can be used to threshold </span>
</span><span id="L-540"><a href="#L-540"><span class="linenos">540</span></a><span class="sd">        how far away the distance is of interest. &quot;&quot;&quot;</span>
</span><span id="L-541"><a href="#L-541"><span class="linenos">541</span></a>        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">ct</span><span class="o">.</span><span class="n">c_float</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
</span><span id="L-542"><a href="#L-542"><span class="linenos">542</span></a>        <span class="n">n</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span><span id="L-543"><a href="#L-543"><span class="linenos">543</span></a>        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ct</span><span class="o">.</span><span class="n">c_float</span><span class="p">)</span>
</span><span id="L-544"><a href="#L-544"><span class="linenos">544</span></a>        <span class="n">p_ct</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">c_float</span><span class="p">))</span>
</span><span id="L-545"><a href="#L-545"><span class="linenos">545</span></a>        <span class="n">d_ct</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">c_float</span><span class="p">))</span>
</span><span id="L-546"><a href="#L-546"><span class="linenos">546</span></a>        <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">MeshDistance_signed_distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">p_ct</span><span class="p">,</span><span class="n">d_ct</span><span class="p">,</span><span class="n">upper</span><span class="p">)</span>
</span><span id="L-547"><a href="#L-547"><span class="linenos">547</span></a>        <span class="k">return</span> <span class="n">d</span>
</span><span id="L-548"><a href="#L-548"><span class="linenos">548</span></a>    <span class="k">def</span> <span class="nf">ray_inside_test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pts</span><span class="p">,</span><span class="n">no_rays</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
</span><span id="L-549"><a href="#L-549"><span class="linenos">549</span></a>        <span class="sd">&quot;&quot;&quot;Check whether each point in pts is inside or outside the stored mesh by </span>
</span><span id="L-550"><a href="#L-550"><span class="linenos">550</span></a><span class="sd">        casting rays. pts should be convertible to a length N&gt;=1 array of 3D points.</span>
</span><span id="L-551"><a href="#L-551"><span class="linenos">551</span></a><span class="sd">        Effectively, this is the sign of the distance. In some cases casting (multiple)</span>
</span><span id="L-552"><a href="#L-552"><span class="linenos">552</span></a><span class="sd">        ray is more robust than using the sign computed locally. Returns an array of </span>
</span><span id="L-553"><a href="#L-553"><span class="linenos">553</span></a><span class="sd">        N integers which are either 1 or 0 depending on whether the corresponding point</span>
</span><span id="L-554"><a href="#L-554"><span class="linenos">554</span></a><span class="sd">        is inside (1) or outside (0). &quot;&quot;&quot;</span>
</span><span id="L-555"><a href="#L-555"><span class="linenos">555</span></a>        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">ct</span><span class="o">.</span><span class="n">c_float</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
</span><span id="L-556"><a href="#L-556"><span class="linenos">556</span></a>        <span class="n">n</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span><span id="L-557"><a href="#L-557"><span class="linenos">557</span></a>        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ct</span><span class="o">.</span><span class="n">c_int</span><span class="p">)</span>
</span><span id="L-558"><a href="#L-558"><span class="linenos">558</span></a>        <span class="n">p_ct</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">c_float</span><span class="p">))</span>
</span><span id="L-559"><a href="#L-559"><span class="linenos">559</span></a>        <span class="n">s_ct</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">c_int</span><span class="p">))</span>
</span><span id="L-560"><a href="#L-560"><span class="linenos">560</span></a>        <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">MeshDistance_ray_inside_test</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">p_ct</span><span class="p">,</span><span class="n">s_ct</span><span class="p">,</span><span class="n">no_rays</span><span class="p">)</span>
</span><span id="L-561"><a href="#L-561"><span class="linenos">561</span></a>        <span class="k">return</span> <span class="n">s</span>
</span></pre></div>

        </details>

            </section>
                <section id="Manifold">
                                <div class="attr class">
        <a class="headerlink" href="#Manifold">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">Manifold</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold-8"><a href="#Manifold-8"><span class="linenos">  8</span></a><span class="k">class</span> <span class="nc">Manifold</span><span class="p">:</span>
</span><span id="Manifold-9"><a href="#Manifold-9"><span class="linenos">  9</span></a>    <span class="sd">&quot;&quot;&quot; The Manifold class represents a halfedge based mesh. It is maybe a bit grand to call</span>
</span><span id="Manifold-10"><a href="#Manifold-10"><span class="linenos"> 10</span></a><span class="sd">    a mesh class Manifold, but meshes based on the halfedge representation are manifold (if we</span>
</span><span id="Manifold-11"><a href="#Manifold-11"><span class="linenos"> 11</span></a><span class="sd">    ignore a few corner cases) unlike some other representations. This class contains a number of</span>
</span><span id="Manifold-12"><a href="#Manifold-12"><span class="linenos"> 12</span></a><span class="sd">    methods for mesh manipulation and inspection. Note also that numerous further functions are</span>
</span><span id="Manifold-13"><a href="#Manifold-13"><span class="linenos"> 13</span></a><span class="sd">    available to manipulate meshes stored as Manifolds.</span>
</span><span id="Manifold-14"><a href="#Manifold-14"><span class="linenos"> 14</span></a><span class="sd">    </span>
</span><span id="Manifold-15"><a href="#Manifold-15"><span class="linenos"> 15</span></a><span class="sd">    Many of the functions below accept arguments called hid, fid, or vid. These are simply indices</span>
</span><span id="Manifold-16"><a href="#Manifold-16"><span class="linenos"> 16</span></a><span class="sd">    of halfedges, faces and vertices, respectively: integer numbers that identify the corresponding</span>
</span><span id="Manifold-17"><a href="#Manifold-17"><span class="linenos"> 17</span></a><span class="sd">    mesh element. Using a plain integer to identify a mesh entity means that, for instance, a</span>
</span><span id="Manifold-18"><a href="#Manifold-18"><span class="linenos"> 18</span></a><span class="sd">    vertex index can also be used as an index into, say, a NumPy array without any conversion.</span>
</span><span id="Manifold-19"><a href="#Manifold-19"><span class="linenos"> 19</span></a><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="Manifold-20"><a href="#Manifold-20"><span class="linenos"> 20</span></a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">orig</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
</span><span id="Manifold-21"><a href="#Manifold-21"><span class="linenos"> 21</span></a>        <span class="k">if</span> <span class="n">orig</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="Manifold-22"><a href="#Manifold-22"><span class="linenos"> 22</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">obj</span> <span class="o">=</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_new</span><span class="p">()</span>
</span><span id="Manifold-23"><a href="#Manifold-23"><span class="linenos"> 23</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="Manifold-24"><a href="#Manifold-24"><span class="linenos"> 24</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">obj</span> <span class="o">=</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_copy</span><span class="p">(</span><span class="n">orig</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="Manifold-25"><a href="#Manifold-25"><span class="linenos"> 25</span></a>    <span class="nd">@classmethod</span>
</span><span id="Manifold-26"><a href="#Manifold-26"><span class="linenos"> 26</span></a>    <span class="k">def</span> <span class="nf">from_triangles</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span><span class="n">vertices</span><span class="p">,</span> <span class="n">faces</span><span class="p">):</span>
</span><span id="Manifold-27"><a href="#Manifold-27"><span class="linenos"> 27</span></a>        <span class="sd">&quot;&quot;&quot; Given a list of vertices and triangles (faces), this function produces </span>
</span><span id="Manifold-28"><a href="#Manifold-28"><span class="linenos"> 28</span></a><span class="sd">        a Manifold mesh.&quot;&quot;&quot;</span>
</span><span id="Manifold-29"><a href="#Manifold-29"><span class="linenos"> 29</span></a>        <span class="n">m</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>
</span><span id="Manifold-30"><a href="#Manifold-30"><span class="linenos"> 30</span></a>        <span class="n">m</span><span class="o">.</span><span class="n">obj</span> <span class="o">=</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_from_triangles</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">faces</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">ct</span><span class="o">.</span><span class="n">c_int</span><span class="p">))</span>
</span><span id="Manifold-31"><a href="#Manifold-31"><span class="linenos"> 31</span></a>        <span class="k">return</span> <span class="n">m</span>
</span><span id="Manifold-32"><a href="#Manifold-32"><span class="linenos"> 32</span></a>    <span class="nd">@classmethod</span>
</span><span id="Manifold-33"><a href="#Manifold-33"><span class="linenos"> 33</span></a>    <span class="k">def</span> <span class="nf">from_points</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span><span class="n">pts</span><span class="p">,</span><span class="n">xaxis</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span><span class="n">yaxis</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])):</span>
</span><span id="Manifold-34"><a href="#Manifold-34"><span class="linenos"> 34</span></a>        <span class="sd">&quot;&quot;&quot; This function computes the Delaunay triangulation of pts. You need</span>
</span><span id="Manifold-35"><a href="#Manifold-35"><span class="linenos"> 35</span></a><span class="sd">        to specify xaxis and yaxis if they are not canonical. The function returns</span>
</span><span id="Manifold-36"><a href="#Manifold-36"><span class="linenos"> 36</span></a><span class="sd">        a Manifold with the resulting triangles. Clearly, this function will</span>
</span><span id="Manifold-37"><a href="#Manifold-37"><span class="linenos"> 37</span></a><span class="sd">        give surprising results if the surface represented by the points is not</span>
</span><span id="Manifold-38"><a href="#Manifold-38"><span class="linenos"> 38</span></a><span class="sd">        well represented as a 2.5D surface, aka a height field. &quot;&quot;&quot;</span>
</span><span id="Manifold-39"><a href="#Manifold-39"><span class="linenos"> 39</span></a>        <span class="n">m</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>
</span><span id="Manifold-40"><a href="#Manifold-40"><span class="linenos"> 40</span></a>        <span class="n">m</span><span class="o">.</span><span class="n">obj</span> <span class="o">=</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_from_points</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pts</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xaxis</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">yaxis</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>
</span><span id="Manifold-41"><a href="#Manifold-41"><span class="linenos"> 41</span></a>        <span class="k">return</span> <span class="n">m</span>
</span><span id="Manifold-42"><a href="#Manifold-42"><span class="linenos"> 42</span></a>    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="Manifold-43"><a href="#Manifold-43"><span class="linenos"> 43</span></a>        <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="Manifold-44"><a href="#Manifold-44"><span class="linenos"> 44</span></a>    <span class="k">def</span> <span class="nf">add_face</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pts</span><span class="p">):</span>
</span><span id="Manifold-45"><a href="#Manifold-45"><span class="linenos"> 45</span></a>        <span class="sd">&quot;&quot;&quot; Add a face to the Manifold.</span>
</span><span id="Manifold-46"><a href="#Manifold-46"><span class="linenos"> 46</span></a><span class="sd">        This function takes a list of 3D points, pts, as argument and creates a face</span>
</span><span id="Manifold-47"><a href="#Manifold-47"><span class="linenos"> 47</span></a><span class="sd">        in the mesh with those points as vertices. The function returns the index</span>
</span><span id="Manifold-48"><a href="#Manifold-48"><span class="linenos"> 48</span></a><span class="sd">        of the created face.</span>
</span><span id="Manifold-49"><a href="#Manifold-49"><span class="linenos"> 49</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="Manifold-50"><a href="#Manifold-50"><span class="linenos"> 50</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_add_face</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">pts</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pts</span><span class="p">))</span>
</span><span id="Manifold-51"><a href="#Manifold-51"><span class="linenos"> 51</span></a>    <span class="k">def</span> <span class="nf">positions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="Manifold-52"><a href="#Manifold-52"><span class="linenos"> 52</span></a>        <span class="sd">&quot;&quot;&quot; Retrieve an array containing the vertex positions of the Manifold.</span>
</span><span id="Manifold-53"><a href="#Manifold-53"><span class="linenos"> 53</span></a><span class="sd">        It is not a copy: any changes are made to the actual vertex positions. &quot;&quot;&quot;</span>
</span><span id="Manifold-54"><a href="#Manifold-54"><span class="linenos"> 54</span></a>        <span class="n">pos</span> <span class="o">=</span> <span class="n">ct</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">c_double</span><span class="p">)()</span>
</span><span id="Manifold-55"><a href="#Manifold-55"><span class="linenos"> 55</span></a>        <span class="n">n</span> <span class="o">=</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_positions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">ct</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">pos</span><span class="p">))</span>
</span><span id="Manifold-56"><a href="#Manifold-56"><span class="linenos"> 56</span></a>        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">as_array</span><span class="p">(</span><span class="n">pos</span><span class="p">,(</span><span class="n">n</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
</span><span id="Manifold-57"><a href="#Manifold-57"><span class="linenos"> 57</span></a>    <span class="k">def</span> <span class="nf">no_allocated_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="Manifold-58"><a href="#Manifold-58"><span class="linenos"> 58</span></a>        <span class="sd">&quot;&quot;&quot; Number of vertices.</span>
</span><span id="Manifold-59"><a href="#Manifold-59"><span class="linenos"> 59</span></a><span class="sd">        This number could be higher than the number of actually</span>
</span><span id="Manifold-60"><a href="#Manifold-60"><span class="linenos"> 60</span></a><span class="sd">        used vertices, but corresponds to the size of the array allocated</span>
</span><span id="Manifold-61"><a href="#Manifold-61"><span class="linenos"> 61</span></a><span class="sd">        for vertices.&quot;&quot;&quot;</span>
</span><span id="Manifold-62"><a href="#Manifold-62"><span class="linenos"> 62</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_no_allocated_vertices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="Manifold-63"><a href="#Manifold-63"><span class="linenos"> 63</span></a>    <span class="k">def</span> <span class="nf">no_allocated_faces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="Manifold-64"><a href="#Manifold-64"><span class="linenos"> 64</span></a>        <span class="sd">&quot;&quot;&quot; Number of faces.</span>
</span><span id="Manifold-65"><a href="#Manifold-65"><span class="linenos"> 65</span></a><span class="sd">        This number could be higher than the number of actually</span>
</span><span id="Manifold-66"><a href="#Manifold-66"><span class="linenos"> 66</span></a><span class="sd">        used faces, but corresponds to the size of the array allocated</span>
</span><span id="Manifold-67"><a href="#Manifold-67"><span class="linenos"> 67</span></a><span class="sd">        for faces.&quot;&quot;&quot;</span>
</span><span id="Manifold-68"><a href="#Manifold-68"><span class="linenos"> 68</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_no_allocated_faces</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="Manifold-69"><a href="#Manifold-69"><span class="linenos"> 69</span></a>    <span class="k">def</span> <span class="nf">no_allocated_halfedges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="Manifold-70"><a href="#Manifold-70"><span class="linenos"> 70</span></a>        <span class="sd">&quot;&quot;&quot; Number of halfedges.</span>
</span><span id="Manifold-71"><a href="#Manifold-71"><span class="linenos"> 71</span></a><span class="sd">        This number could be higher than the number of actually</span>
</span><span id="Manifold-72"><a href="#Manifold-72"><span class="linenos"> 72</span></a><span class="sd">        used halfedges, but corresponds to the size of the array allocated</span>
</span><span id="Manifold-73"><a href="#Manifold-73"><span class="linenos"> 73</span></a><span class="sd">        for halfedges.&quot;&quot;&quot;</span>
</span><span id="Manifold-74"><a href="#Manifold-74"><span class="linenos"> 74</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_no_allocated_halfedges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="Manifold-75"><a href="#Manifold-75"><span class="linenos"> 75</span></a>    <span class="k">def</span> <span class="nf">vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="Manifold-76"><a href="#Manifold-76"><span class="linenos"> 76</span></a>        <span class="sd">&quot;&quot;&quot; Returns an iterable containing all vertex indices&quot;&quot;&quot;</span>
</span><span id="Manifold-77"><a href="#Manifold-77"><span class="linenos"> 77</span></a>        <span class="n">verts</span> <span class="o">=</span> <span class="n">IntVector</span><span class="p">()</span>
</span><span id="Manifold-78"><a href="#Manifold-78"><span class="linenos"> 78</span></a>        <span class="n">n</span> <span class="o">=</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_vertices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">verts</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="Manifold-79"><a href="#Manifold-79"><span class="linenos"> 79</span></a>        <span class="k">return</span> <span class="n">verts</span>
</span><span id="Manifold-80"><a href="#Manifold-80"><span class="linenos"> 80</span></a>    <span class="k">def</span> <span class="nf">faces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="Manifold-81"><a href="#Manifold-81"><span class="linenos"> 81</span></a>        <span class="sd">&quot;&quot;&quot; Returns an iterable containing all face indices&quot;&quot;&quot;</span>
</span><span id="Manifold-82"><a href="#Manifold-82"><span class="linenos"> 82</span></a>        <span class="n">faces</span> <span class="o">=</span> <span class="n">IntVector</span><span class="p">()</span>
</span><span id="Manifold-83"><a href="#Manifold-83"><span class="linenos"> 83</span></a>        <span class="n">n</span> <span class="o">=</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_faces</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">faces</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="Manifold-84"><a href="#Manifold-84"><span class="linenos"> 84</span></a>        <span class="k">return</span> <span class="n">faces</span>
</span><span id="Manifold-85"><a href="#Manifold-85"><span class="linenos"> 85</span></a>    <span class="k">def</span> <span class="nf">halfedges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="Manifold-86"><a href="#Manifold-86"><span class="linenos"> 86</span></a>        <span class="sd">&quot;&quot;&quot; Returns an iterable containing all halfedge indices&quot;&quot;&quot;</span>
</span><span id="Manifold-87"><a href="#Manifold-87"><span class="linenos"> 87</span></a>        <span class="n">hedges</span> <span class="o">=</span> <span class="n">IntVector</span><span class="p">()</span>
</span><span id="Manifold-88"><a href="#Manifold-88"><span class="linenos"> 88</span></a>        <span class="n">n</span> <span class="o">=</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_halfedges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">hedges</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="Manifold-89"><a href="#Manifold-89"><span class="linenos"> 89</span></a>        <span class="k">return</span> <span class="n">hedges</span>
</span><span id="Manifold-90"><a href="#Manifold-90"><span class="linenos"> 90</span></a>    <span class="k">def</span> <span class="nf">circulate_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vid</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">):</span>
</span><span id="Manifold-91"><a href="#Manifold-91"><span class="linenos"> 91</span></a>        <span class="sd">&quot;&quot;&quot; Circulate a vertex. Passed a vertex index, vid, and second argument,</span>
</span><span id="Manifold-92"><a href="#Manifold-92"><span class="linenos"> 92</span></a><span class="sd">        mode=&#39;f&#39;, this function will return an iterable with all faces incident</span>
</span><span id="Manifold-93"><a href="#Manifold-93"><span class="linenos"> 93</span></a><span class="sd">        on vid arranged in counter clockwise order. Similarly, if mode is &#39;h&#39;,</span>
</span><span id="Manifold-94"><a href="#Manifold-94"><span class="linenos"> 94</span></a><span class="sd">        incident halfedges (outgoing) are returned, and for mode = &#39;v&#39;, all</span>
</span><span id="Manifold-95"><a href="#Manifold-95"><span class="linenos"> 95</span></a><span class="sd">        neighboring vertices are returned. &quot;&quot;&quot;</span>
</span><span id="Manifold-96"><a href="#Manifold-96"><span class="linenos"> 96</span></a>        <span class="n">nbrs</span> <span class="o">=</span> <span class="n">IntVector</span><span class="p">()</span>
</span><span id="Manifold-97"><a href="#Manifold-97"><span class="linenos"> 97</span></a>        <span class="n">n</span> <span class="o">=</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_circulate_vertex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">vid</span><span class="p">,</span> <span class="n">ct</span><span class="o">.</span><span class="n">c_char</span><span class="p">(</span><span class="n">mode</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)),</span> <span class="n">nbrs</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="Manifold-98"><a href="#Manifold-98"><span class="linenos"> 98</span></a>        <span class="k">return</span> <span class="n">nbrs</span>
</span><span id="Manifold-99"><a href="#Manifold-99"><span class="linenos"> 99</span></a>    <span class="k">def</span> <span class="nf">circulate_face</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">):</span>
</span><span id="Manifold-100"><a href="#Manifold-100"><span class="linenos">100</span></a>        <span class="sd">&quot;&quot;&quot; Circulate a face. Passed a face index, fid, and second argument,</span>
</span><span id="Manifold-101"><a href="#Manifold-101"><span class="linenos">101</span></a><span class="sd">        mode=&#39;f&#39;, this function will return an iterable with all faces that</span>
</span><span id="Manifold-102"><a href="#Manifold-102"><span class="linenos">102</span></a><span class="sd">        share an edge with fid (in counter clockwise order). If the argument is</span>
</span><span id="Manifold-103"><a href="#Manifold-103"><span class="linenos">103</span></a><span class="sd">        mode=&#39;h&#39;, the halfedges themselves are returned. For mode=&#39;v&#39;, the</span>
</span><span id="Manifold-104"><a href="#Manifold-104"><span class="linenos">104</span></a><span class="sd">        incident vertices of the face are returned. &quot;&quot;&quot;</span>
</span><span id="Manifold-105"><a href="#Manifold-105"><span class="linenos">105</span></a>        <span class="n">nbrs</span> <span class="o">=</span> <span class="n">IntVector</span><span class="p">()</span>
</span><span id="Manifold-106"><a href="#Manifold-106"><span class="linenos">106</span></a>        <span class="n">n</span> <span class="o">=</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_circulate_face</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">ct</span><span class="o">.</span><span class="n">c_char</span><span class="p">(</span><span class="n">mode</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)),</span> <span class="n">nbrs</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="Manifold-107"><a href="#Manifold-107"><span class="linenos">107</span></a>        <span class="k">return</span> <span class="n">nbrs</span>
</span><span id="Manifold-108"><a href="#Manifold-108"><span class="linenos">108</span></a>    <span class="k">def</span> <span class="nf">next_halfedge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hid</span><span class="p">):</span>
</span><span id="Manifold-109"><a href="#Manifold-109"><span class="linenos">109</span></a>        <span class="sd">&quot;&quot;&quot; Returns next halfedge to hid. &quot;&quot;&quot;</span>
</span><span id="Manifold-110"><a href="#Manifold-110"><span class="linenos">110</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Walker_next_halfedge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">hid</span><span class="p">)</span>
</span><span id="Manifold-111"><a href="#Manifold-111"><span class="linenos">111</span></a>    <span class="k">def</span> <span class="nf">prev_halfedge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hid</span><span class="p">):</span>
</span><span id="Manifold-112"><a href="#Manifold-112"><span class="linenos">112</span></a>        <span class="sd">&quot;&quot;&quot; Returns previous halfedge to hid. &quot;&quot;&quot;</span>
</span><span id="Manifold-113"><a href="#Manifold-113"><span class="linenos">113</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Walker_prev_halfedge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">hid</span><span class="p">)</span>
</span><span id="Manifold-114"><a href="#Manifold-114"><span class="linenos">114</span></a>    <span class="k">def</span> <span class="nf">opposite_halfedge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hid</span><span class="p">):</span>
</span><span id="Manifold-115"><a href="#Manifold-115"><span class="linenos">115</span></a>        <span class="sd">&quot;&quot;&quot; Returns opposite halfedge to hid. &quot;&quot;&quot;</span>
</span><span id="Manifold-116"><a href="#Manifold-116"><span class="linenos">116</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Walker_opposite_halfedge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">hid</span><span class="p">)</span>
</span><span id="Manifold-117"><a href="#Manifold-117"><span class="linenos">117</span></a>    <span class="k">def</span> <span class="nf">incident_face</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hid</span><span class="p">):</span>
</span><span id="Manifold-118"><a href="#Manifold-118"><span class="linenos">118</span></a>        <span class="sd">&quot;&quot;&quot; Returns face corresponding to hid. &quot;&quot;&quot;</span>
</span><span id="Manifold-119"><a href="#Manifold-119"><span class="linenos">119</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Walker_incident_face</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">hid</span><span class="p">)</span>
</span><span id="Manifold-120"><a href="#Manifold-120"><span class="linenos">120</span></a>    <span class="k">def</span> <span class="nf">incident_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hid</span><span class="p">):</span>
</span><span id="Manifold-121"><a href="#Manifold-121"><span class="linenos">121</span></a>        <span class="sd">&quot;&quot;&quot; Returns vertex corresponding to (or pointed to by) hid. &quot;&quot;&quot;</span>
</span><span id="Manifold-122"><a href="#Manifold-122"><span class="linenos">122</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Walker_incident_vertex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">hid</span><span class="p">)</span>
</span><span id="Manifold-123"><a href="#Manifold-123"><span class="linenos">123</span></a>    <span class="k">def</span> <span class="nf">remove_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">vid</span><span class="p">):</span>
</span><span id="Manifold-124"><a href="#Manifold-124"><span class="linenos">124</span></a>        <span class="sd">&quot;&quot;&quot; Remove vertex vid from the Manifold. This function merges all faces</span>
</span><span id="Manifold-125"><a href="#Manifold-125"><span class="linenos">125</span></a><span class="sd">        around the vertex into one and then removes this resulting face. &quot;&quot;&quot;</span>
</span><span id="Manifold-126"><a href="#Manifold-126"><span class="linenos">126</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_remove_vertex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">vid</span><span class="p">)</span>
</span><span id="Manifold-127"><a href="#Manifold-127"><span class="linenos">127</span></a>    <span class="k">def</span> <span class="nf">remove_face</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fid</span><span class="p">):</span>
</span><span id="Manifold-128"><a href="#Manifold-128"><span class="linenos">128</span></a>        <span class="sd">&quot;&quot;&quot; Removes a face, fid, from the Manifold. If it is an interior face it is</span>
</span><span id="Manifold-129"><a href="#Manifold-129"><span class="linenos">129</span></a><span class="sd">        simply replaced by an invalid index. If the face contains boundary</span>
</span><span id="Manifold-130"><a href="#Manifold-130"><span class="linenos">130</span></a><span class="sd">        edges, these are removed. Situations may arise where the mesh is no</span>
</span><span id="Manifold-131"><a href="#Manifold-131"><span class="linenos">131</span></a><span class="sd">        longer manifold because the situation at a boundary vertex is not</span>
</span><span id="Manifold-132"><a href="#Manifold-132"><span class="linenos">132</span></a><span class="sd">        homeomorphic to a half disk. This, we can probably ignore since from the</span>
</span><span id="Manifold-133"><a href="#Manifold-133"><span class="linenos">133</span></a><span class="sd">        data structure point of view it is not really a problem that a vertex is</span>
</span><span id="Manifold-134"><a href="#Manifold-134"><span class="linenos">134</span></a><span class="sd">        incident on two holes - a hole can be seen as a special type of face.</span>
</span><span id="Manifold-135"><a href="#Manifold-135"><span class="linenos">135</span></a><span class="sd">        The function returns false if the index of the face is not valid,</span>
</span><span id="Manifold-136"><a href="#Manifold-136"><span class="linenos">136</span></a><span class="sd">        otherwise the function must complete. &quot;&quot;&quot;</span>
</span><span id="Manifold-137"><a href="#Manifold-137"><span class="linenos">137</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_remove_face</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">fid</span><span class="p">)</span>
</span><span id="Manifold-138"><a href="#Manifold-138"><span class="linenos">138</span></a>    <span class="k">def</span> <span class="nf">remove_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hid</span><span class="p">):</span>
</span><span id="Manifold-139"><a href="#Manifold-139"><span class="linenos">139</span></a>        <span class="sd">&quot;&quot;&quot; Remove an edge, hid, from the Manifold. This function will remove the</span>
</span><span id="Manifold-140"><a href="#Manifold-140"><span class="linenos">140</span></a><span class="sd">        faces on either side and the edge itself in the process. Thus, it is a</span>
</span><span id="Manifold-141"><a href="#Manifold-141"><span class="linenos">141</span></a><span class="sd">        simple application of remove_face. &quot;&quot;&quot;</span>
</span><span id="Manifold-142"><a href="#Manifold-142"><span class="linenos">142</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_remove_edge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">hid</span><span class="p">)</span>
</span><span id="Manifold-143"><a href="#Manifold-143"><span class="linenos">143</span></a>    <span class="k">def</span> <span class="nf">vertex_in_use</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">vid</span><span class="p">):</span>
</span><span id="Manifold-144"><a href="#Manifold-144"><span class="linenos">144</span></a>        <span class="sd">&quot;&quot;&quot; check if vertex, vid, is in use. This function returns true if the id corresponds</span>
</span><span id="Manifold-145"><a href="#Manifold-145"><span class="linenos">145</span></a><span class="sd">        to a vertex that is currently in the mesh and false otherwise. vid could</span>
</span><span id="Manifold-146"><a href="#Manifold-146"><span class="linenos">146</span></a><span class="sd">        be outside the range of used ids and it could also correspond to a vertex</span>
</span><span id="Manifold-147"><a href="#Manifold-147"><span class="linenos">147</span></a><span class="sd">        which is not active. The function returns false in both cases. &quot;&quot;&quot;</span>
</span><span id="Manifold-148"><a href="#Manifold-148"><span class="linenos">148</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_vertex_in_use</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">vid</span><span class="p">)</span>
</span><span id="Manifold-149"><a href="#Manifold-149"><span class="linenos">149</span></a>    <span class="k">def</span> <span class="nf">face_in_use</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fid</span><span class="p">):</span>
</span><span id="Manifold-150"><a href="#Manifold-150"><span class="linenos">150</span></a>        <span class="sd">&quot;&quot;&quot; check if face, fid, is in use. This function returns true if the id corresponds</span>
</span><span id="Manifold-151"><a href="#Manifold-151"><span class="linenos">151</span></a><span class="sd">        to a face that is currently in the mesh and false otherwise. fid could</span>
</span><span id="Manifold-152"><a href="#Manifold-152"><span class="linenos">152</span></a><span class="sd">        be outside the range of used ids and it could also correspond to a face</span>
</span><span id="Manifold-153"><a href="#Manifold-153"><span class="linenos">153</span></a><span class="sd">        which is not active. The function returns false in both cases. &quot;&quot;&quot;</span>
</span><span id="Manifold-154"><a href="#Manifold-154"><span class="linenos">154</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_face_in_use</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">fid</span><span class="p">)</span>
</span><span id="Manifold-155"><a href="#Manifold-155"><span class="linenos">155</span></a>    <span class="k">def</span> <span class="nf">halfedge_in_use</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hid</span><span class="p">):</span>
</span><span id="Manifold-156"><a href="#Manifold-156"><span class="linenos">156</span></a>        <span class="sd">&quot;&quot;&quot; check if halfedge hid is in use. This function returns true if the id corresponds</span>
</span><span id="Manifold-157"><a href="#Manifold-157"><span class="linenos">157</span></a><span class="sd">        to a halfedge that is currently in the mesh and false otherwise. hid could</span>
</span><span id="Manifold-158"><a href="#Manifold-158"><span class="linenos">158</span></a><span class="sd">        be outside the range of used ids and it could also correspond to a halfedge</span>
</span><span id="Manifold-159"><a href="#Manifold-159"><span class="linenos">159</span></a><span class="sd">        which is not active. The function returns false in both cases. &quot;&quot;&quot;</span>
</span><span id="Manifold-160"><a href="#Manifold-160"><span class="linenos">160</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_halfedge_in_use</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">hid</span><span class="p">)</span>
</span><span id="Manifold-161"><a href="#Manifold-161"><span class="linenos">161</span></a>    <span class="k">def</span> <span class="nf">flip_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hid</span><span class="p">):</span>
</span><span id="Manifold-162"><a href="#Manifold-162"><span class="linenos">162</span></a>        <span class="sd">&quot;&quot;&quot; Flip the edge, hid, separating two faces. The function first verifies that</span>
</span><span id="Manifold-163"><a href="#Manifold-163"><span class="linenos">163</span></a><span class="sd">        the edge is flippable. This entails making sure that all of the</span>
</span><span id="Manifold-164"><a href="#Manifold-164"><span class="linenos">164</span></a><span class="sd">        following are true.</span>
</span><span id="Manifold-165"><a href="#Manifold-165"><span class="linenos">165</span></a><span class="sd">        1. adjacent faces are triangles.</span>
</span><span id="Manifold-166"><a href="#Manifold-166"><span class="linenos">166</span></a><span class="sd">        2. neither end point has valency three or less.</span>
</span><span id="Manifold-167"><a href="#Manifold-167"><span class="linenos">167</span></a><span class="sd">        3. the vertices that will be connected are not already.</span>
</span><span id="Manifold-168"><a href="#Manifold-168"><span class="linenos">168</span></a><span class="sd">        If the tests are passed, the flip is performed and the function</span>
</span><span id="Manifold-169"><a href="#Manifold-169"><span class="linenos">169</span></a><span class="sd">        returns True. Otherwise False.&quot;&quot;&quot;</span>
</span><span id="Manifold-170"><a href="#Manifold-170"><span class="linenos">170</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_flip_edge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span><span class="n">hid</span><span class="p">)</span>
</span><span id="Manifold-171"><a href="#Manifold-171"><span class="linenos">171</span></a>    <span class="k">def</span> <span class="nf">collapse_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hid</span><span class="p">,</span> <span class="n">avg_vertices</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="Manifold-172"><a href="#Manifold-172"><span class="linenos">172</span></a>        <span class="sd">&quot;&quot;&quot; Collapse an edge hid.</span>
</span><span id="Manifold-173"><a href="#Manifold-173"><span class="linenos">173</span></a><span class="sd">        Before collapsing hid, a number of tests are made:</span>
</span><span id="Manifold-174"><a href="#Manifold-174"><span class="linenos">174</span></a><span class="sd">        ---</span>
</span><span id="Manifold-175"><a href="#Manifold-175"><span class="linenos">175</span></a><span class="sd">        1.  For the two vertices adjacent to the edge, we generate a list of all their neighbouring vertices.</span>
</span><span id="Manifold-176"><a href="#Manifold-176"><span class="linenos">176</span></a><span class="sd">        We then generate a  list of the vertices that occur in both these lists.</span>
</span><span id="Manifold-177"><a href="#Manifold-177"><span class="linenos">177</span></a><span class="sd">        That is, we find all vertices connected by edges to both endpoints of the edge and store these in a list.</span>
</span><span id="Manifold-178"><a href="#Manifold-178"><span class="linenos">178</span></a><span class="sd">        2.  For both faces incident on the edge, check whether they are triangular.</span>
</span><span id="Manifold-179"><a href="#Manifold-179"><span class="linenos">179</span></a><span class="sd">        If this is the case, the face will be removed, and it is ok that the the third vertex is connected to both endpoints.</span>
</span><span id="Manifold-180"><a href="#Manifold-180"><span class="linenos">180</span></a><span class="sd">        Thus the third vertex in such a face is removed from the list generated in 1.</span>
</span><span id="Manifold-181"><a href="#Manifold-181"><span class="linenos">181</span></a><span class="sd">        3.  If the list is now empty, all is well.</span>
</span><span id="Manifold-182"><a href="#Manifold-182"><span class="linenos">182</span></a><span class="sd">        Otherwise, there would be a vertex in the new mesh with two edges connecting it to the same vertex. Return false.</span>
</span><span id="Manifold-183"><a href="#Manifold-183"><span class="linenos">183</span></a><span class="sd">        4.  TETRAHEDRON TEST:</span>
</span><span id="Manifold-184"><a href="#Manifold-184"><span class="linenos">184</span></a><span class="sd">        If the valency of both vertices is three, and the incident faces are triangles, we also disallow the operation.</span>
</span><span id="Manifold-185"><a href="#Manifold-185"><span class="linenos">185</span></a><span class="sd">        Reason: A vertex valency of two and two triangles incident on the adjacent vertices makes the construction collapse.</span>
</span><span id="Manifold-186"><a href="#Manifold-186"><span class="linenos">186</span></a><span class="sd">        5.  VALENCY 4 TEST:</span>
</span><span id="Manifold-187"><a href="#Manifold-187"><span class="linenos">187</span></a><span class="sd">        If a triangle is adjacent to the edge being collapsed, it disappears.</span>
</span><span id="Manifold-188"><a href="#Manifold-188"><span class="linenos">188</span></a><span class="sd">        This means the valency of the remaining edge vertex is decreased by one.</span>
</span><span id="Manifold-189"><a href="#Manifold-189"><span class="linenos">189</span></a><span class="sd">        A valency two vertex reduced to a valency one vertex is considered illegal.</span>
</span><span id="Manifold-190"><a href="#Manifold-190"><span class="linenos">190</span></a><span class="sd">        6.  PREVENT MERGING HOLES:</span>
</span><span id="Manifold-191"><a href="#Manifold-191"><span class="linenos">191</span></a><span class="sd">        Collapsing an edge with boundary endpoints and valid faces results in the creation where two holes meet.</span>
</span><span id="Manifold-192"><a href="#Manifold-192"><span class="linenos">192</span></a><span class="sd">        A non manifold situation. We could relax this...</span>
</span><span id="Manifold-193"><a href="#Manifold-193"><span class="linenos">193</span></a><span class="sd">        7. New test: if the same face is in the one-ring of both vertices but not adjacent to the common edge,</span>
</span><span id="Manifold-194"><a href="#Manifold-194"><span class="linenos">194</span></a><span class="sd">        then the result of a collapse would be a one ring where the same face occurs twice. This is disallowed as the resulting</span>
</span><span id="Manifold-195"><a href="#Manifold-195"><span class="linenos">195</span></a><span class="sd">        face would be non-simple.</span>
</span><span id="Manifold-196"><a href="#Manifold-196"><span class="linenos">196</span></a><span class="sd">        If the tests are passed, the collapse is performed and the function</span>
</span><span id="Manifold-197"><a href="#Manifold-197"><span class="linenos">197</span></a><span class="sd">        returns True. Otherwise False.&quot;&quot;&quot;</span>
</span><span id="Manifold-198"><a href="#Manifold-198"><span class="linenos">198</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_collapse_edge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">hid</span><span class="p">,</span> <span class="n">avg_vertices</span><span class="p">)</span>
</span><span id="Manifold-199"><a href="#Manifold-199"><span class="linenos">199</span></a>    <span class="k">def</span> <span class="nf">split_face_by_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fid</span><span class="p">,</span><span class="n">v0</span><span class="p">,</span><span class="n">v1</span><span class="p">):</span>
</span><span id="Manifold-200"><a href="#Manifold-200"><span class="linenos">200</span></a>        <span class="sd">&quot;&quot;&quot;   Split a face. The face, fid, is split by creating an edge with</span>
</span><span id="Manifold-201"><a href="#Manifold-201"><span class="linenos">201</span></a><span class="sd">        endpoints v0 and v1 (the next two arguments). The vertices of the old</span>
</span><span id="Manifold-202"><a href="#Manifold-202"><span class="linenos">202</span></a><span class="sd">        face between v0 and v1 (in counter clockwise order) continue to belong</span>
</span><span id="Manifold-203"><a href="#Manifold-203"><span class="linenos">203</span></a><span class="sd">        to fid. The vertices between v1 and v0 belong to the new face. A handle to</span>
</span><span id="Manifold-204"><a href="#Manifold-204"><span class="linenos">204</span></a><span class="sd">        the new face is returned. &quot;&quot;&quot;</span>
</span><span id="Manifold-205"><a href="#Manifold-205"><span class="linenos">205</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_split_face_by_edge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
</span><span id="Manifold-206"><a href="#Manifold-206"><span class="linenos">206</span></a>    <span class="k">def</span> <span class="nf">split_face_by_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fid</span><span class="p">):</span>
</span><span id="Manifold-207"><a href="#Manifold-207"><span class="linenos">207</span></a>        <span class="sd">&quot;&quot;&quot;   Split a polygon, fid, by inserting a vertex at the barycenter. This</span>
</span><span id="Manifold-208"><a href="#Manifold-208"><span class="linenos">208</span></a><span class="sd">        function is less likely to create flipped triangles than the</span>
</span><span id="Manifold-209"><a href="#Manifold-209"><span class="linenos">209</span></a><span class="sd">        split_face_triangulate function. On the other hand, it introduces more</span>
</span><span id="Manifold-210"><a href="#Manifold-210"><span class="linenos">210</span></a><span class="sd">        vertices and probably makes the triangles more acute. The vertex id of the</span>
</span><span id="Manifold-211"><a href="#Manifold-211"><span class="linenos">211</span></a><span class="sd">        inserted vertex is returned. &quot;&quot;&quot;</span>
</span><span id="Manifold-212"><a href="#Manifold-212"><span class="linenos">212</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_split_face_by_vertex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span><span class="n">fid</span><span class="p">)</span>
</span><span id="Manifold-213"><a href="#Manifold-213"><span class="linenos">213</span></a>    <span class="k">def</span> <span class="nf">split_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hid</span><span class="p">):</span>
</span><span id="Manifold-214"><a href="#Manifold-214"><span class="linenos">214</span></a>        <span class="sd">&quot;&quot;&quot;   Insert a new vertex on halfedge hid. The new halfedge is insterted</span>
</span><span id="Manifold-215"><a href="#Manifold-215"><span class="linenos">215</span></a><span class="sd">        as the previous edge to hid. The vertex id of the inserted vertex is returned. &quot;&quot;&quot;</span>
</span><span id="Manifold-216"><a href="#Manifold-216"><span class="linenos">216</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_split_edge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span><span class="n">hid</span><span class="p">)</span>
</span><span id="Manifold-217"><a href="#Manifold-217"><span class="linenos">217</span></a>    <span class="k">def</span> <span class="nf">stitch_boundary_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">h0</span><span class="p">,</span><span class="n">h1</span><span class="p">):</span>
</span><span id="Manifold-218"><a href="#Manifold-218"><span class="linenos">218</span></a>        <span class="sd">&quot;&quot;&quot;   Stitch two halfedges. Two boundary halfedges, h0 and h1, can be stitched</span>
</span><span id="Manifold-219"><a href="#Manifold-219"><span class="linenos">219</span></a><span class="sd">        together. This can be used to build a complex mesh from a bunch of</span>
</span><span id="Manifold-220"><a href="#Manifold-220"><span class="linenos">220</span></a><span class="sd">        simple faces. &quot;&quot;&quot;</span>
</span><span id="Manifold-221"><a href="#Manifold-221"><span class="linenos">221</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_stitch_boundary_edges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">h0</span><span class="p">,</span> <span class="n">h1</span><span class="p">)</span>
</span><span id="Manifold-222"><a href="#Manifold-222"><span class="linenos">222</span></a>    <span class="k">def</span> <span class="nf">merge_faces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hid</span><span class="p">):</span>
</span><span id="Manifold-223"><a href="#Manifold-223"><span class="linenos">223</span></a>        <span class="sd">&quot;&quot;&quot;   Merges two faces into a single polygon. The merged faces are those shared</span>
</span><span id="Manifold-224"><a href="#Manifold-224"><span class="linenos">224</span></a><span class="sd">        by the edge for which hid is one of the two corresponding halfedges. This function returns</span>
</span><span id="Manifold-225"><a href="#Manifold-225"><span class="linenos">225</span></a><span class="sd">        true if the merging was possible and false otherwise. Currently merge</span>
</span><span id="Manifold-226"><a href="#Manifold-226"><span class="linenos">226</span></a><span class="sd">        only fails if the mesh is already illegal. Thus it should, in fact,</span>
</span><span id="Manifold-227"><a href="#Manifold-227"><span class="linenos">227</span></a><span class="sd">        never fail. &quot;&quot;&quot;</span>
</span><span id="Manifold-228"><a href="#Manifold-228"><span class="linenos">228</span></a>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_halfedge_at_boundary</span><span class="p">(</span><span class="n">hid</span><span class="p">):</span>
</span><span id="Manifold-229"><a href="#Manifold-229"><span class="linenos">229</span></a>            <span class="k">return</span> <span class="kc">False</span>
</span><span id="Manifold-230"><a href="#Manifold-230"><span class="linenos">230</span></a>        <span class="n">fid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">incident_face</span><span class="p">(</span><span class="n">hid</span><span class="p">)</span>
</span><span id="Manifold-231"><a href="#Manifold-231"><span class="linenos">231</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_merge_faces</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">hid</span><span class="p">)</span>
</span><span id="Manifold-232"><a href="#Manifold-232"><span class="linenos">232</span></a>    <span class="k">def</span> <span class="nf">close_hole</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hid</span><span class="p">):</span>
</span><span id="Manifold-233"><a href="#Manifold-233"><span class="linenos">233</span></a>        <span class="sd">&quot;&quot;&quot; Close hole given by hid (i.e. the face referenced by hid). Returns</span>
</span><span id="Manifold-234"><a href="#Manifold-234"><span class="linenos">234</span></a><span class="sd">        index of the created face or the face that was already there if, in</span>
</span><span id="Manifold-235"><a href="#Manifold-235"><span class="linenos">235</span></a><span class="sd">        fact, hid was not next to a hole. &quot;&quot;&quot;</span>
</span><span id="Manifold-236"><a href="#Manifold-236"><span class="linenos">236</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_close_hole</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">hid</span><span class="p">)</span>
</span><span id="Manifold-237"><a href="#Manifold-237"><span class="linenos">237</span></a>    <span class="k">def</span> <span class="nf">cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="Manifold-238"><a href="#Manifold-238"><span class="linenos">238</span></a>        <span class="sd">&quot;&quot;&quot; Remove unused items from Mesh. This function remaps all vertices, halfedges</span>
</span><span id="Manifold-239"><a href="#Manifold-239"><span class="linenos">239</span></a><span class="sd">        and faces such that the arrays do not contain any holes left by unused mesh</span>
</span><span id="Manifold-240"><a href="#Manifold-240"><span class="linenos">240</span></a><span class="sd">        entities. It is a good idea to call this function when a mesh has been simplified</span>
</span><span id="Manifold-241"><a href="#Manifold-241"><span class="linenos">241</span></a><span class="sd">        or changed in other ways such that mesh entities have been removed. However, note</span>
</span><span id="Manifold-242"><a href="#Manifold-242"><span class="linenos">242</span></a><span class="sd">        that it invalidates any attributes that you might have stored in auxilliary arrays.&quot;&quot;&quot;</span>
</span><span id="Manifold-243"><a href="#Manifold-243"><span class="linenos">243</span></a>        <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_cleanup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="Manifold-244"><a href="#Manifold-244"><span class="linenos">244</span></a>    <span class="k">def</span> <span class="nf">is_halfedge_at_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hid</span><span class="p">):</span>
</span><span id="Manifold-245"><a href="#Manifold-245"><span class="linenos">245</span></a>        <span class="sd">&quot;&quot;&quot; Returns True if hid is a boundary halfedge, i.e. face on either</span>
</span><span id="Manifold-246"><a href="#Manifold-246"><span class="linenos">246</span></a><span class="sd">        side is invalid. &quot;&quot;&quot;</span>
</span><span id="Manifold-247"><a href="#Manifold-247"><span class="linenos">247</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">is_halfedge_at_boundary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">hid</span><span class="p">)</span>
</span><span id="Manifold-248"><a href="#Manifold-248"><span class="linenos">248</span></a>    <span class="k">def</span> <span class="nf">is_vertex_at_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vid</span><span class="p">):</span>
</span><span id="Manifold-249"><a href="#Manifold-249"><span class="linenos">249</span></a>        <span class="sd">&quot;&quot;&quot; Returns True if vid lies on a boundary. &quot;&quot;&quot;</span>
</span><span id="Manifold-250"><a href="#Manifold-250"><span class="linenos">250</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">is_vertex_at_boundary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">vid</span><span class="p">)</span>
</span><span id="Manifold-251"><a href="#Manifold-251"><span class="linenos">251</span></a>    <span class="k">def</span> <span class="nf">edge_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hid</span><span class="p">):</span>
</span><span id="Manifold-252"><a href="#Manifold-252"><span class="linenos">252</span></a>        <span class="sd">&quot;&quot;&quot; Returns length of edge given by halfedge hid which is passed as argument. &quot;&quot;&quot;</span>
</span><span id="Manifold-253"><a href="#Manifold-253"><span class="linenos">253</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">length</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">hid</span><span class="p">)</span>
</span><span id="Manifold-254"><a href="#Manifold-254"><span class="linenos">254</span></a>    <span class="k">def</span> <span class="nf">valency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">vid</span><span class="p">):</span>
</span><span id="Manifold-255"><a href="#Manifold-255"><span class="linenos">255</span></a>        <span class="sd">&quot;&quot;&quot; Returns valency of vid, i.e. number of incident edges.&quot;&quot;&quot;</span>
</span><span id="Manifold-256"><a href="#Manifold-256"><span class="linenos">256</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">valency</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span><span class="n">vid</span><span class="p">)</span>
</span><span id="Manifold-257"><a href="#Manifold-257"><span class="linenos">257</span></a>    <span class="k">def</span> <span class="nf">vertex_normal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vid</span><span class="p">):</span>
</span><span id="Manifold-258"><a href="#Manifold-258"><span class="linenos">258</span></a>        <span class="sd">&quot;&quot;&quot; Returns vertex normal (angle weighted) of vertex given by vid &quot;&quot;&quot;</span>
</span><span id="Manifold-259"><a href="#Manifold-259"><span class="linenos">259</span></a>        <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">c_double</span><span class="o">*</span><span class="mi">3</span><span class="p">)()</span>
</span><span id="Manifold-260"><a href="#Manifold-260"><span class="linenos">260</span></a>        <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">vertex_normal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">vid</span><span class="p">,</span> <span class="n">ct</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
</span><span id="Manifold-261"><a href="#Manifold-261"><span class="linenos">261</span></a>        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
</span><span id="Manifold-262"><a href="#Manifold-262"><span class="linenos">262</span></a>    <span class="k">def</span> <span class="nf">connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">):</span>
</span><span id="Manifold-263"><a href="#Manifold-263"><span class="linenos">263</span></a>        <span class="sd">&quot;&quot;&quot; Returns true if the two argument vertices, v0 and v1, are in each other&#39;s one-rings.&quot;&quot;&quot;</span>
</span><span id="Manifold-264"><a href="#Manifold-264"><span class="linenos">264</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">connected</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span><span class="n">v0</span><span class="p">,</span><span class="n">v1</span><span class="p">)</span>
</span><span id="Manifold-265"><a href="#Manifold-265"><span class="linenos">265</span></a>    <span class="k">def</span> <span class="nf">no_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fid</span><span class="p">):</span>
</span><span id="Manifold-266"><a href="#Manifold-266"><span class="linenos">266</span></a>        <span class="sd">&quot;&quot;&quot; Compute the number of edges of a face fid &quot;&quot;&quot;</span>
</span><span id="Manifold-267"><a href="#Manifold-267"><span class="linenos">267</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">no_edges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">fid</span><span class="p">)</span>
</span><span id="Manifold-268"><a href="#Manifold-268"><span class="linenos">268</span></a>    <span class="k">def</span> <span class="nf">face_normal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fid</span><span class="p">):</span>
</span><span id="Manifold-269"><a href="#Manifold-269"><span class="linenos">269</span></a>        <span class="sd">&quot;&quot;&quot; Compute the normal of a face fid. If the face is not a triangle,</span>
</span><span id="Manifold-270"><a href="#Manifold-270"><span class="linenos">270</span></a><span class="sd">        the normal is not defined, but computed using the first three</span>
</span><span id="Manifold-271"><a href="#Manifold-271"><span class="linenos">271</span></a><span class="sd">        vertices of the face. &quot;&quot;&quot;</span>
</span><span id="Manifold-272"><a href="#Manifold-272"><span class="linenos">272</span></a>        <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">c_double</span><span class="o">*</span><span class="mi">3</span><span class="p">)()</span>
</span><span id="Manifold-273"><a href="#Manifold-273"><span class="linenos">273</span></a>        <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">face_normal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">ct</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
</span><span id="Manifold-274"><a href="#Manifold-274"><span class="linenos">274</span></a>        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
</span><span id="Manifold-275"><a href="#Manifold-275"><span class="linenos">275</span></a>    <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fid</span><span class="p">):</span>
</span><span id="Manifold-276"><a href="#Manifold-276"><span class="linenos">276</span></a>        <span class="sd">&quot;&quot;&quot; Returns the area of a face fid. &quot;&quot;&quot;</span>
</span><span id="Manifold-277"><a href="#Manifold-277"><span class="linenos">277</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">area</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">fid</span><span class="p">)</span>
</span><span id="Manifold-278"><a href="#Manifold-278"><span class="linenos">278</span></a>    <span class="k">def</span> <span class="nf">perimeter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fid</span><span class="p">):</span>
</span><span id="Manifold-279"><a href="#Manifold-279"><span class="linenos">279</span></a>        <span class="sd">&quot;&quot;&quot; Returns the perimeter of a face fid. &quot;&quot;&quot;</span>
</span><span id="Manifold-280"><a href="#Manifold-280"><span class="linenos">280</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">perimeter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">fid</span><span class="p">)</span>
</span><span id="Manifold-281"><a href="#Manifold-281"><span class="linenos">281</span></a>    <span class="k">def</span> <span class="nf">centre</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fid</span><span class="p">):</span>
</span><span id="Manifold-282"><a href="#Manifold-282"><span class="linenos">282</span></a>        <span class="sd">&quot;&quot;&quot; Returns the centre of a face. &quot;&quot;&quot;</span>
</span><span id="Manifold-283"><a href="#Manifold-283"><span class="linenos">283</span></a>        <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">c_double</span><span class="o">*</span><span class="mi">3</span><span class="p">)()</span>
</span><span id="Manifold-284"><a href="#Manifold-284"><span class="linenos">284</span></a>        <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">centre</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">ct</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
</span><span id="Manifold-285"><a href="#Manifold-285"><span class="linenos">285</span></a>        <span class="k">return</span> <span class="n">v</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>The Manifold class represents a halfedge based mesh. It is maybe a bit grand to call
a mesh class Manifold, but meshes based on the halfedge representation are manifold (if we
ignore a few corner cases) unlike some other representations. This class contains a number of
methods for mesh manipulation and inspection. Note also that numerous further functions are
available to manipulate meshes stored as Manifolds.</p>

<p>Many of the functions below accept arguments called hid, fid, or vid. These are simply indices
of halfedges, faces and vertices, respectively: integer numbers that identify the corresponding
mesh element. Using a plain integer to identify a mesh entity means that, for instance, a
vertex index can also be used as an index into, say, a NumPy array without any conversion.</p>
</div>


                            <div id="Manifold.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">Manifold</span><span class="signature">(orig=None)</span>
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.__init__-20"><a href="#Manifold.__init__-20"><span class="linenos">20</span></a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">orig</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
</span><span id="Manifold.__init__-21"><a href="#Manifold.__init__-21"><span class="linenos">21</span></a>        <span class="k">if</span> <span class="n">orig</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="Manifold.__init__-22"><a href="#Manifold.__init__-22"><span class="linenos">22</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">obj</span> <span class="o">=</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_new</span><span class="p">()</span>
</span><span id="Manifold.__init__-23"><a href="#Manifold.__init__-23"><span class="linenos">23</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="Manifold.__init__-24"><a href="#Manifold.__init__-24"><span class="linenos">24</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">obj</span> <span class="o">=</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_copy</span><span class="p">(</span><span class="n">orig</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span></pre></div>

        </details>

    

                            </div>
                            <div id="Manifold.from_triangles" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.from_triangles">#&nbsp;&nbsp</a>

                <div class="decorator">@classmethod</div>

            <span class="def">def</span>
            <span class="name">from_triangles</span><span class="signature">(cls, vertices, faces)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.from_triangles-25"><a href="#Manifold.from_triangles-25"><span class="linenos">25</span></a>    <span class="nd">@classmethod</span>
</span><span id="Manifold.from_triangles-26"><a href="#Manifold.from_triangles-26"><span class="linenos">26</span></a>    <span class="k">def</span> <span class="nf">from_triangles</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span><span class="n">vertices</span><span class="p">,</span> <span class="n">faces</span><span class="p">):</span>
</span><span id="Manifold.from_triangles-27"><a href="#Manifold.from_triangles-27"><span class="linenos">27</span></a>        <span class="sd">&quot;&quot;&quot; Given a list of vertices and triangles (faces), this function produces </span>
</span><span id="Manifold.from_triangles-28"><a href="#Manifold.from_triangles-28"><span class="linenos">28</span></a><span class="sd">        a Manifold mesh.&quot;&quot;&quot;</span>
</span><span id="Manifold.from_triangles-29"><a href="#Manifold.from_triangles-29"><span class="linenos">29</span></a>        <span class="n">m</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>
</span><span id="Manifold.from_triangles-30"><a href="#Manifold.from_triangles-30"><span class="linenos">30</span></a>        <span class="n">m</span><span class="o">.</span><span class="n">obj</span> <span class="o">=</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_from_triangles</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">faces</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">faces</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">ct</span><span class="o">.</span><span class="n">c_int</span><span class="p">))</span>
</span><span id="Manifold.from_triangles-31"><a href="#Manifold.from_triangles-31"><span class="linenos">31</span></a>        <span class="k">return</span> <span class="n">m</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Given a list of vertices and triangles (faces), this function produces 
a Manifold mesh.</p>
</div>


                            </div>
                            <div id="Manifold.from_points" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.from_points">#&nbsp;&nbsp</a>

                <div class="decorator">@classmethod</div>

            <span class="def">def</span>
            <span class="name">from_points</span><span class="signature">(cls, pts, xaxis=array([1, 0, 0]), yaxis=array([0, 1, 0]))</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.from_points-32"><a href="#Manifold.from_points-32"><span class="linenos">32</span></a>    <span class="nd">@classmethod</span>
</span><span id="Manifold.from_points-33"><a href="#Manifold.from_points-33"><span class="linenos">33</span></a>    <span class="k">def</span> <span class="nf">from_points</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span><span class="n">pts</span><span class="p">,</span><span class="n">xaxis</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span><span class="n">yaxis</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])):</span>
</span><span id="Manifold.from_points-34"><a href="#Manifold.from_points-34"><span class="linenos">34</span></a>        <span class="sd">&quot;&quot;&quot; This function computes the Delaunay triangulation of pts. You need</span>
</span><span id="Manifold.from_points-35"><a href="#Manifold.from_points-35"><span class="linenos">35</span></a><span class="sd">        to specify xaxis and yaxis if they are not canonical. The function returns</span>
</span><span id="Manifold.from_points-36"><a href="#Manifold.from_points-36"><span class="linenos">36</span></a><span class="sd">        a Manifold with the resulting triangles. Clearly, this function will</span>
</span><span id="Manifold.from_points-37"><a href="#Manifold.from_points-37"><span class="linenos">37</span></a><span class="sd">        give surprising results if the surface represented by the points is not</span>
</span><span id="Manifold.from_points-38"><a href="#Manifold.from_points-38"><span class="linenos">38</span></a><span class="sd">        well represented as a 2.5D surface, aka a height field. &quot;&quot;&quot;</span>
</span><span id="Manifold.from_points-39"><a href="#Manifold.from_points-39"><span class="linenos">39</span></a>        <span class="n">m</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>
</span><span id="Manifold.from_points-40"><a href="#Manifold.from_points-40"><span class="linenos">40</span></a>        <span class="n">m</span><span class="o">.</span><span class="n">obj</span> <span class="o">=</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_from_points</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pts</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xaxis</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">yaxis</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>
</span><span id="Manifold.from_points-41"><a href="#Manifold.from_points-41"><span class="linenos">41</span></a>        <span class="k">return</span> <span class="n">m</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>This function computes the Delaunay triangulation of pts. You need
to specify xaxis and yaxis if they are not canonical. The function returns
a Manifold with the resulting triangles. Clearly, this function will
give surprising results if the surface represented by the points is not
well represented as a 2.5D surface, aka a height field.</p>
</div>


                            </div>
                            <div id="Manifold.add_face" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.add_face">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">add_face</span><span class="signature">(self, pts)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.add_face-44"><a href="#Manifold.add_face-44"><span class="linenos">44</span></a>    <span class="k">def</span> <span class="nf">add_face</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pts</span><span class="p">):</span>
</span><span id="Manifold.add_face-45"><a href="#Manifold.add_face-45"><span class="linenos">45</span></a>        <span class="sd">&quot;&quot;&quot; Add a face to the Manifold.</span>
</span><span id="Manifold.add_face-46"><a href="#Manifold.add_face-46"><span class="linenos">46</span></a><span class="sd">        This function takes a list of 3D points, pts, as argument and creates a face</span>
</span><span id="Manifold.add_face-47"><a href="#Manifold.add_face-47"><span class="linenos">47</span></a><span class="sd">        in the mesh with those points as vertices. The function returns the index</span>
</span><span id="Manifold.add_face-48"><a href="#Manifold.add_face-48"><span class="linenos">48</span></a><span class="sd">        of the created face.</span>
</span><span id="Manifold.add_face-49"><a href="#Manifold.add_face-49"><span class="linenos">49</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="Manifold.add_face-50"><a href="#Manifold.add_face-50"><span class="linenos">50</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_add_face</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">pts</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pts</span><span class="p">))</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Add a face to the Manifold.
This function takes a list of 3D points, pts, as argument and creates a face
in the mesh with those points as vertices. The function returns the index
of the created face.</p>
</div>


                            </div>
                            <div id="Manifold.positions" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.positions">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">positions</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.positions-51"><a href="#Manifold.positions-51"><span class="linenos">51</span></a>    <span class="k">def</span> <span class="nf">positions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="Manifold.positions-52"><a href="#Manifold.positions-52"><span class="linenos">52</span></a>        <span class="sd">&quot;&quot;&quot; Retrieve an array containing the vertex positions of the Manifold.</span>
</span><span id="Manifold.positions-53"><a href="#Manifold.positions-53"><span class="linenos">53</span></a><span class="sd">        It is not a copy: any changes are made to the actual vertex positions. &quot;&quot;&quot;</span>
</span><span id="Manifold.positions-54"><a href="#Manifold.positions-54"><span class="linenos">54</span></a>        <span class="n">pos</span> <span class="o">=</span> <span class="n">ct</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">c_double</span><span class="p">)()</span>
</span><span id="Manifold.positions-55"><a href="#Manifold.positions-55"><span class="linenos">55</span></a>        <span class="n">n</span> <span class="o">=</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_positions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">ct</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">pos</span><span class="p">))</span>
</span><span id="Manifold.positions-56"><a href="#Manifold.positions-56"><span class="linenos">56</span></a>        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">as_array</span><span class="p">(</span><span class="n">pos</span><span class="p">,(</span><span class="n">n</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Retrieve an array containing the vertex positions of the Manifold.
It is not a copy: any changes are made to the actual vertex positions.</p>
</div>


                            </div>
                            <div id="Manifold.no_allocated_vertices" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.no_allocated_vertices">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">no_allocated_vertices</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.no_allocated_vertices-57"><a href="#Manifold.no_allocated_vertices-57"><span class="linenos">57</span></a>    <span class="k">def</span> <span class="nf">no_allocated_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="Manifold.no_allocated_vertices-58"><a href="#Manifold.no_allocated_vertices-58"><span class="linenos">58</span></a>        <span class="sd">&quot;&quot;&quot; Number of vertices.</span>
</span><span id="Manifold.no_allocated_vertices-59"><a href="#Manifold.no_allocated_vertices-59"><span class="linenos">59</span></a><span class="sd">        This number could be higher than the number of actually</span>
</span><span id="Manifold.no_allocated_vertices-60"><a href="#Manifold.no_allocated_vertices-60"><span class="linenos">60</span></a><span class="sd">        used vertices, but corresponds to the size of the array allocated</span>
</span><span id="Manifold.no_allocated_vertices-61"><a href="#Manifold.no_allocated_vertices-61"><span class="linenos">61</span></a><span class="sd">        for vertices.&quot;&quot;&quot;</span>
</span><span id="Manifold.no_allocated_vertices-62"><a href="#Manifold.no_allocated_vertices-62"><span class="linenos">62</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_no_allocated_vertices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Number of vertices.
This number could be higher than the number of actually
used vertices, but corresponds to the size of the array allocated
for vertices.</p>
</div>


                            </div>
                            <div id="Manifold.no_allocated_faces" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.no_allocated_faces">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">no_allocated_faces</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.no_allocated_faces-63"><a href="#Manifold.no_allocated_faces-63"><span class="linenos">63</span></a>    <span class="k">def</span> <span class="nf">no_allocated_faces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="Manifold.no_allocated_faces-64"><a href="#Manifold.no_allocated_faces-64"><span class="linenos">64</span></a>        <span class="sd">&quot;&quot;&quot; Number of faces.</span>
</span><span id="Manifold.no_allocated_faces-65"><a href="#Manifold.no_allocated_faces-65"><span class="linenos">65</span></a><span class="sd">        This number could be higher than the number of actually</span>
</span><span id="Manifold.no_allocated_faces-66"><a href="#Manifold.no_allocated_faces-66"><span class="linenos">66</span></a><span class="sd">        used faces, but corresponds to the size of the array allocated</span>
</span><span id="Manifold.no_allocated_faces-67"><a href="#Manifold.no_allocated_faces-67"><span class="linenos">67</span></a><span class="sd">        for faces.&quot;&quot;&quot;</span>
</span><span id="Manifold.no_allocated_faces-68"><a href="#Manifold.no_allocated_faces-68"><span class="linenos">68</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_no_allocated_faces</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Number of faces.
This number could be higher than the number of actually
used faces, but corresponds to the size of the array allocated
for faces.</p>
</div>


                            </div>
                            <div id="Manifold.no_allocated_halfedges" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.no_allocated_halfedges">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">no_allocated_halfedges</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.no_allocated_halfedges-69"><a href="#Manifold.no_allocated_halfedges-69"><span class="linenos">69</span></a>    <span class="k">def</span> <span class="nf">no_allocated_halfedges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="Manifold.no_allocated_halfedges-70"><a href="#Manifold.no_allocated_halfedges-70"><span class="linenos">70</span></a>        <span class="sd">&quot;&quot;&quot; Number of halfedges.</span>
</span><span id="Manifold.no_allocated_halfedges-71"><a href="#Manifold.no_allocated_halfedges-71"><span class="linenos">71</span></a><span class="sd">        This number could be higher than the number of actually</span>
</span><span id="Manifold.no_allocated_halfedges-72"><a href="#Manifold.no_allocated_halfedges-72"><span class="linenos">72</span></a><span class="sd">        used halfedges, but corresponds to the size of the array allocated</span>
</span><span id="Manifold.no_allocated_halfedges-73"><a href="#Manifold.no_allocated_halfedges-73"><span class="linenos">73</span></a><span class="sd">        for halfedges.&quot;&quot;&quot;</span>
</span><span id="Manifold.no_allocated_halfedges-74"><a href="#Manifold.no_allocated_halfedges-74"><span class="linenos">74</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_no_allocated_halfedges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Number of halfedges.
This number could be higher than the number of actually
used halfedges, but corresponds to the size of the array allocated
for halfedges.</p>
</div>


                            </div>
                            <div id="Manifold.vertices" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.vertices">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">vertices</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.vertices-75"><a href="#Manifold.vertices-75"><span class="linenos">75</span></a>    <span class="k">def</span> <span class="nf">vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="Manifold.vertices-76"><a href="#Manifold.vertices-76"><span class="linenos">76</span></a>        <span class="sd">&quot;&quot;&quot; Returns an iterable containing all vertex indices&quot;&quot;&quot;</span>
</span><span id="Manifold.vertices-77"><a href="#Manifold.vertices-77"><span class="linenos">77</span></a>        <span class="n">verts</span> <span class="o">=</span> <span class="n">IntVector</span><span class="p">()</span>
</span><span id="Manifold.vertices-78"><a href="#Manifold.vertices-78"><span class="linenos">78</span></a>        <span class="n">n</span> <span class="o">=</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_vertices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">verts</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="Manifold.vertices-79"><a href="#Manifold.vertices-79"><span class="linenos">79</span></a>        <span class="k">return</span> <span class="n">verts</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Returns an iterable containing all vertex indices</p>
</div>


                            </div>
                            <div id="Manifold.faces" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.faces">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">faces</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.faces-80"><a href="#Manifold.faces-80"><span class="linenos">80</span></a>    <span class="k">def</span> <span class="nf">faces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="Manifold.faces-81"><a href="#Manifold.faces-81"><span class="linenos">81</span></a>        <span class="sd">&quot;&quot;&quot; Returns an iterable containing all face indices&quot;&quot;&quot;</span>
</span><span id="Manifold.faces-82"><a href="#Manifold.faces-82"><span class="linenos">82</span></a>        <span class="n">faces</span> <span class="o">=</span> <span class="n">IntVector</span><span class="p">()</span>
</span><span id="Manifold.faces-83"><a href="#Manifold.faces-83"><span class="linenos">83</span></a>        <span class="n">n</span> <span class="o">=</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_faces</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">faces</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="Manifold.faces-84"><a href="#Manifold.faces-84"><span class="linenos">84</span></a>        <span class="k">return</span> <span class="n">faces</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Returns an iterable containing all face indices</p>
</div>


                            </div>
                            <div id="Manifold.halfedges" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.halfedges">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">halfedges</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.halfedges-85"><a href="#Manifold.halfedges-85"><span class="linenos">85</span></a>    <span class="k">def</span> <span class="nf">halfedges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="Manifold.halfedges-86"><a href="#Manifold.halfedges-86"><span class="linenos">86</span></a>        <span class="sd">&quot;&quot;&quot; Returns an iterable containing all halfedge indices&quot;&quot;&quot;</span>
</span><span id="Manifold.halfedges-87"><a href="#Manifold.halfedges-87"><span class="linenos">87</span></a>        <span class="n">hedges</span> <span class="o">=</span> <span class="n">IntVector</span><span class="p">()</span>
</span><span id="Manifold.halfedges-88"><a href="#Manifold.halfedges-88"><span class="linenos">88</span></a>        <span class="n">n</span> <span class="o">=</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_halfedges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">hedges</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="Manifold.halfedges-89"><a href="#Manifold.halfedges-89"><span class="linenos">89</span></a>        <span class="k">return</span> <span class="n">hedges</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Returns an iterable containing all halfedge indices</p>
</div>


                            </div>
                            <div id="Manifold.circulate_vertex" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.circulate_vertex">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">circulate_vertex</span><span class="signature">(self, vid, mode=&#39;v&#39;)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.circulate_vertex-90"><a href="#Manifold.circulate_vertex-90"><span class="linenos">90</span></a>    <span class="k">def</span> <span class="nf">circulate_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vid</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">):</span>
</span><span id="Manifold.circulate_vertex-91"><a href="#Manifold.circulate_vertex-91"><span class="linenos">91</span></a>        <span class="sd">&quot;&quot;&quot; Circulate a vertex. Passed a vertex index, vid, and second argument,</span>
</span><span id="Manifold.circulate_vertex-92"><a href="#Manifold.circulate_vertex-92"><span class="linenos">92</span></a><span class="sd">        mode=&#39;f&#39;, this function will return an iterable with all faces incident</span>
</span><span id="Manifold.circulate_vertex-93"><a href="#Manifold.circulate_vertex-93"><span class="linenos">93</span></a><span class="sd">        on vid arranged in counter clockwise order. Similarly, if mode is &#39;h&#39;,</span>
</span><span id="Manifold.circulate_vertex-94"><a href="#Manifold.circulate_vertex-94"><span class="linenos">94</span></a><span class="sd">        incident halfedges (outgoing) are returned, and for mode = &#39;v&#39;, all</span>
</span><span id="Manifold.circulate_vertex-95"><a href="#Manifold.circulate_vertex-95"><span class="linenos">95</span></a><span class="sd">        neighboring vertices are returned. &quot;&quot;&quot;</span>
</span><span id="Manifold.circulate_vertex-96"><a href="#Manifold.circulate_vertex-96"><span class="linenos">96</span></a>        <span class="n">nbrs</span> <span class="o">=</span> <span class="n">IntVector</span><span class="p">()</span>
</span><span id="Manifold.circulate_vertex-97"><a href="#Manifold.circulate_vertex-97"><span class="linenos">97</span></a>        <span class="n">n</span> <span class="o">=</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_circulate_vertex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">vid</span><span class="p">,</span> <span class="n">ct</span><span class="o">.</span><span class="n">c_char</span><span class="p">(</span><span class="n">mode</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)),</span> <span class="n">nbrs</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="Manifold.circulate_vertex-98"><a href="#Manifold.circulate_vertex-98"><span class="linenos">98</span></a>        <span class="k">return</span> <span class="n">nbrs</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Circulate a vertex. Passed a vertex index, vid, and second argument,
mode='f', this function will return an iterable with all faces incident
on vid arranged in counter clockwise order. Similarly, if mode is 'h',
incident halfedges (outgoing) are returned, and for mode = 'v', all
neighboring vertices are returned.</p>
</div>


                            </div>
                            <div id="Manifold.circulate_face" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.circulate_face">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">circulate_face</span><span class="signature">(self, fid, mode=&#39;v&#39;)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.circulate_face-99"><a href="#Manifold.circulate_face-99"><span class="linenos"> 99</span></a>    <span class="k">def</span> <span class="nf">circulate_face</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">):</span>
</span><span id="Manifold.circulate_face-100"><a href="#Manifold.circulate_face-100"><span class="linenos">100</span></a>        <span class="sd">&quot;&quot;&quot; Circulate a face. Passed a face index, fid, and second argument,</span>
</span><span id="Manifold.circulate_face-101"><a href="#Manifold.circulate_face-101"><span class="linenos">101</span></a><span class="sd">        mode=&#39;f&#39;, this function will return an iterable with all faces that</span>
</span><span id="Manifold.circulate_face-102"><a href="#Manifold.circulate_face-102"><span class="linenos">102</span></a><span class="sd">        share an edge with fid (in counter clockwise order). If the argument is</span>
</span><span id="Manifold.circulate_face-103"><a href="#Manifold.circulate_face-103"><span class="linenos">103</span></a><span class="sd">        mode=&#39;h&#39;, the halfedges themselves are returned. For mode=&#39;v&#39;, the</span>
</span><span id="Manifold.circulate_face-104"><a href="#Manifold.circulate_face-104"><span class="linenos">104</span></a><span class="sd">        incident vertices of the face are returned. &quot;&quot;&quot;</span>
</span><span id="Manifold.circulate_face-105"><a href="#Manifold.circulate_face-105"><span class="linenos">105</span></a>        <span class="n">nbrs</span> <span class="o">=</span> <span class="n">IntVector</span><span class="p">()</span>
</span><span id="Manifold.circulate_face-106"><a href="#Manifold.circulate_face-106"><span class="linenos">106</span></a>        <span class="n">n</span> <span class="o">=</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_circulate_face</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">ct</span><span class="o">.</span><span class="n">c_char</span><span class="p">(</span><span class="n">mode</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)),</span> <span class="n">nbrs</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="Manifold.circulate_face-107"><a href="#Manifold.circulate_face-107"><span class="linenos">107</span></a>        <span class="k">return</span> <span class="n">nbrs</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Circulate a face. Passed a face index, fid, and second argument,
mode='f', this function will return an iterable with all faces that
share an edge with fid (in counter clockwise order). If the argument is
mode='h', the halfedges themselves are returned. For mode='v', the
incident vertices of the face are returned.</p>
</div>


                            </div>
                            <div id="Manifold.next_halfedge" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.next_halfedge">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">next_halfedge</span><span class="signature">(self, hid)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.next_halfedge-108"><a href="#Manifold.next_halfedge-108"><span class="linenos">108</span></a>    <span class="k">def</span> <span class="nf">next_halfedge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hid</span><span class="p">):</span>
</span><span id="Manifold.next_halfedge-109"><a href="#Manifold.next_halfedge-109"><span class="linenos">109</span></a>        <span class="sd">&quot;&quot;&quot; Returns next halfedge to hid. &quot;&quot;&quot;</span>
</span><span id="Manifold.next_halfedge-110"><a href="#Manifold.next_halfedge-110"><span class="linenos">110</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Walker_next_halfedge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">hid</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Returns next halfedge to hid.</p>
</div>


                            </div>
                            <div id="Manifold.prev_halfedge" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.prev_halfedge">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">prev_halfedge</span><span class="signature">(self, hid)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.prev_halfedge-111"><a href="#Manifold.prev_halfedge-111"><span class="linenos">111</span></a>    <span class="k">def</span> <span class="nf">prev_halfedge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hid</span><span class="p">):</span>
</span><span id="Manifold.prev_halfedge-112"><a href="#Manifold.prev_halfedge-112"><span class="linenos">112</span></a>        <span class="sd">&quot;&quot;&quot; Returns previous halfedge to hid. &quot;&quot;&quot;</span>
</span><span id="Manifold.prev_halfedge-113"><a href="#Manifold.prev_halfedge-113"><span class="linenos">113</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Walker_prev_halfedge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">hid</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Returns previous halfedge to hid.</p>
</div>


                            </div>
                            <div id="Manifold.opposite_halfedge" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.opposite_halfedge">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">opposite_halfedge</span><span class="signature">(self, hid)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.opposite_halfedge-114"><a href="#Manifold.opposite_halfedge-114"><span class="linenos">114</span></a>    <span class="k">def</span> <span class="nf">opposite_halfedge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hid</span><span class="p">):</span>
</span><span id="Manifold.opposite_halfedge-115"><a href="#Manifold.opposite_halfedge-115"><span class="linenos">115</span></a>        <span class="sd">&quot;&quot;&quot; Returns opposite halfedge to hid. &quot;&quot;&quot;</span>
</span><span id="Manifold.opposite_halfedge-116"><a href="#Manifold.opposite_halfedge-116"><span class="linenos">116</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Walker_opposite_halfedge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">hid</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Returns opposite halfedge to hid.</p>
</div>


                            </div>
                            <div id="Manifold.incident_face" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.incident_face">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">incident_face</span><span class="signature">(self, hid)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.incident_face-117"><a href="#Manifold.incident_face-117"><span class="linenos">117</span></a>    <span class="k">def</span> <span class="nf">incident_face</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hid</span><span class="p">):</span>
</span><span id="Manifold.incident_face-118"><a href="#Manifold.incident_face-118"><span class="linenos">118</span></a>        <span class="sd">&quot;&quot;&quot; Returns face corresponding to hid. &quot;&quot;&quot;</span>
</span><span id="Manifold.incident_face-119"><a href="#Manifold.incident_face-119"><span class="linenos">119</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Walker_incident_face</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">hid</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Returns face corresponding to hid.</p>
</div>


                            </div>
                            <div id="Manifold.incident_vertex" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.incident_vertex">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">incident_vertex</span><span class="signature">(self, hid)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.incident_vertex-120"><a href="#Manifold.incident_vertex-120"><span class="linenos">120</span></a>    <span class="k">def</span> <span class="nf">incident_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hid</span><span class="p">):</span>
</span><span id="Manifold.incident_vertex-121"><a href="#Manifold.incident_vertex-121"><span class="linenos">121</span></a>        <span class="sd">&quot;&quot;&quot; Returns vertex corresponding to (or pointed to by) hid. &quot;&quot;&quot;</span>
</span><span id="Manifold.incident_vertex-122"><a href="#Manifold.incident_vertex-122"><span class="linenos">122</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Walker_incident_vertex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">hid</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Returns vertex corresponding to (or pointed to by) hid.</p>
</div>


                            </div>
                            <div id="Manifold.remove_vertex" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.remove_vertex">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">remove_vertex</span><span class="signature">(self, vid)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.remove_vertex-123"><a href="#Manifold.remove_vertex-123"><span class="linenos">123</span></a>    <span class="k">def</span> <span class="nf">remove_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">vid</span><span class="p">):</span>
</span><span id="Manifold.remove_vertex-124"><a href="#Manifold.remove_vertex-124"><span class="linenos">124</span></a>        <span class="sd">&quot;&quot;&quot; Remove vertex vid from the Manifold. This function merges all faces</span>
</span><span id="Manifold.remove_vertex-125"><a href="#Manifold.remove_vertex-125"><span class="linenos">125</span></a><span class="sd">        around the vertex into one and then removes this resulting face. &quot;&quot;&quot;</span>
</span><span id="Manifold.remove_vertex-126"><a href="#Manifold.remove_vertex-126"><span class="linenos">126</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_remove_vertex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">vid</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Remove vertex vid from the Manifold. This function merges all faces
around the vertex into one and then removes this resulting face.</p>
</div>


                            </div>
                            <div id="Manifold.remove_face" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.remove_face">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">remove_face</span><span class="signature">(self, fid)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.remove_face-127"><a href="#Manifold.remove_face-127"><span class="linenos">127</span></a>    <span class="k">def</span> <span class="nf">remove_face</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fid</span><span class="p">):</span>
</span><span id="Manifold.remove_face-128"><a href="#Manifold.remove_face-128"><span class="linenos">128</span></a>        <span class="sd">&quot;&quot;&quot; Removes a face, fid, from the Manifold. If it is an interior face it is</span>
</span><span id="Manifold.remove_face-129"><a href="#Manifold.remove_face-129"><span class="linenos">129</span></a><span class="sd">        simply replaced by an invalid index. If the face contains boundary</span>
</span><span id="Manifold.remove_face-130"><a href="#Manifold.remove_face-130"><span class="linenos">130</span></a><span class="sd">        edges, these are removed. Situations may arise where the mesh is no</span>
</span><span id="Manifold.remove_face-131"><a href="#Manifold.remove_face-131"><span class="linenos">131</span></a><span class="sd">        longer manifold because the situation at a boundary vertex is not</span>
</span><span id="Manifold.remove_face-132"><a href="#Manifold.remove_face-132"><span class="linenos">132</span></a><span class="sd">        homeomorphic to a half disk. This, we can probably ignore since from the</span>
</span><span id="Manifold.remove_face-133"><a href="#Manifold.remove_face-133"><span class="linenos">133</span></a><span class="sd">        data structure point of view it is not really a problem that a vertex is</span>
</span><span id="Manifold.remove_face-134"><a href="#Manifold.remove_face-134"><span class="linenos">134</span></a><span class="sd">        incident on two holes - a hole can be seen as a special type of face.</span>
</span><span id="Manifold.remove_face-135"><a href="#Manifold.remove_face-135"><span class="linenos">135</span></a><span class="sd">        The function returns false if the index of the face is not valid,</span>
</span><span id="Manifold.remove_face-136"><a href="#Manifold.remove_face-136"><span class="linenos">136</span></a><span class="sd">        otherwise the function must complete. &quot;&quot;&quot;</span>
</span><span id="Manifold.remove_face-137"><a href="#Manifold.remove_face-137"><span class="linenos">137</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_remove_face</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">fid</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Removes a face, fid, from the Manifold. If it is an interior face it is
simply replaced by an invalid index. If the face contains boundary
edges, these are removed. Situations may arise where the mesh is no
longer manifold because the situation at a boundary vertex is not
homeomorphic to a half disk. This, we can probably ignore since from the
data structure point of view it is not really a problem that a vertex is
incident on two holes - a hole can be seen as a special type of face.
The function returns false if the index of the face is not valid,
otherwise the function must complete.</p>
</div>


                            </div>
                            <div id="Manifold.remove_edge" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.remove_edge">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">remove_edge</span><span class="signature">(self, hid)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.remove_edge-138"><a href="#Manifold.remove_edge-138"><span class="linenos">138</span></a>    <span class="k">def</span> <span class="nf">remove_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hid</span><span class="p">):</span>
</span><span id="Manifold.remove_edge-139"><a href="#Manifold.remove_edge-139"><span class="linenos">139</span></a>        <span class="sd">&quot;&quot;&quot; Remove an edge, hid, from the Manifold. This function will remove the</span>
</span><span id="Manifold.remove_edge-140"><a href="#Manifold.remove_edge-140"><span class="linenos">140</span></a><span class="sd">        faces on either side and the edge itself in the process. Thus, it is a</span>
</span><span id="Manifold.remove_edge-141"><a href="#Manifold.remove_edge-141"><span class="linenos">141</span></a><span class="sd">        simple application of remove_face. &quot;&quot;&quot;</span>
</span><span id="Manifold.remove_edge-142"><a href="#Manifold.remove_edge-142"><span class="linenos">142</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_remove_edge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">hid</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Remove an edge, hid, from the Manifold. This function will remove the
faces on either side and the edge itself in the process. Thus, it is a
simple application of remove_face.</p>
</div>


                            </div>
                            <div id="Manifold.vertex_in_use" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.vertex_in_use">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">vertex_in_use</span><span class="signature">(self, vid)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.vertex_in_use-143"><a href="#Manifold.vertex_in_use-143"><span class="linenos">143</span></a>    <span class="k">def</span> <span class="nf">vertex_in_use</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">vid</span><span class="p">):</span>
</span><span id="Manifold.vertex_in_use-144"><a href="#Manifold.vertex_in_use-144"><span class="linenos">144</span></a>        <span class="sd">&quot;&quot;&quot; check if vertex, vid, is in use. This function returns true if the id corresponds</span>
</span><span id="Manifold.vertex_in_use-145"><a href="#Manifold.vertex_in_use-145"><span class="linenos">145</span></a><span class="sd">        to a vertex that is currently in the mesh and false otherwise. vid could</span>
</span><span id="Manifold.vertex_in_use-146"><a href="#Manifold.vertex_in_use-146"><span class="linenos">146</span></a><span class="sd">        be outside the range of used ids and it could also correspond to a vertex</span>
</span><span id="Manifold.vertex_in_use-147"><a href="#Manifold.vertex_in_use-147"><span class="linenos">147</span></a><span class="sd">        which is not active. The function returns false in both cases. &quot;&quot;&quot;</span>
</span><span id="Manifold.vertex_in_use-148"><a href="#Manifold.vertex_in_use-148"><span class="linenos">148</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_vertex_in_use</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">vid</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>check if vertex, vid, is in use. This function returns true if the id corresponds
to a vertex that is currently in the mesh and false otherwise. vid could
be outside the range of used ids and it could also correspond to a vertex
which is not active. The function returns false in both cases.</p>
</div>


                            </div>
                            <div id="Manifold.face_in_use" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.face_in_use">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">face_in_use</span><span class="signature">(self, fid)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.face_in_use-149"><a href="#Manifold.face_in_use-149"><span class="linenos">149</span></a>    <span class="k">def</span> <span class="nf">face_in_use</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fid</span><span class="p">):</span>
</span><span id="Manifold.face_in_use-150"><a href="#Manifold.face_in_use-150"><span class="linenos">150</span></a>        <span class="sd">&quot;&quot;&quot; check if face, fid, is in use. This function returns true if the id corresponds</span>
</span><span id="Manifold.face_in_use-151"><a href="#Manifold.face_in_use-151"><span class="linenos">151</span></a><span class="sd">        to a face that is currently in the mesh and false otherwise. fid could</span>
</span><span id="Manifold.face_in_use-152"><a href="#Manifold.face_in_use-152"><span class="linenos">152</span></a><span class="sd">        be outside the range of used ids and it could also correspond to a face</span>
</span><span id="Manifold.face_in_use-153"><a href="#Manifold.face_in_use-153"><span class="linenos">153</span></a><span class="sd">        which is not active. The function returns false in both cases. &quot;&quot;&quot;</span>
</span><span id="Manifold.face_in_use-154"><a href="#Manifold.face_in_use-154"><span class="linenos">154</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_face_in_use</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">fid</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>check if face, fid, is in use. This function returns true if the id corresponds
to a face that is currently in the mesh and false otherwise. fid could
be outside the range of used ids and it could also correspond to a face
which is not active. The function returns false in both cases.</p>
</div>


                            </div>
                            <div id="Manifold.halfedge_in_use" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.halfedge_in_use">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">halfedge_in_use</span><span class="signature">(self, hid)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.halfedge_in_use-155"><a href="#Manifold.halfedge_in_use-155"><span class="linenos">155</span></a>    <span class="k">def</span> <span class="nf">halfedge_in_use</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hid</span><span class="p">):</span>
</span><span id="Manifold.halfedge_in_use-156"><a href="#Manifold.halfedge_in_use-156"><span class="linenos">156</span></a>        <span class="sd">&quot;&quot;&quot; check if halfedge hid is in use. This function returns true if the id corresponds</span>
</span><span id="Manifold.halfedge_in_use-157"><a href="#Manifold.halfedge_in_use-157"><span class="linenos">157</span></a><span class="sd">        to a halfedge that is currently in the mesh and false otherwise. hid could</span>
</span><span id="Manifold.halfedge_in_use-158"><a href="#Manifold.halfedge_in_use-158"><span class="linenos">158</span></a><span class="sd">        be outside the range of used ids and it could also correspond to a halfedge</span>
</span><span id="Manifold.halfedge_in_use-159"><a href="#Manifold.halfedge_in_use-159"><span class="linenos">159</span></a><span class="sd">        which is not active. The function returns false in both cases. &quot;&quot;&quot;</span>
</span><span id="Manifold.halfedge_in_use-160"><a href="#Manifold.halfedge_in_use-160"><span class="linenos">160</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_halfedge_in_use</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">hid</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>check if halfedge hid is in use. This function returns true if the id corresponds
to a halfedge that is currently in the mesh and false otherwise. hid could
be outside the range of used ids and it could also correspond to a halfedge
which is not active. The function returns false in both cases.</p>
</div>


                            </div>
                            <div id="Manifold.flip_edge" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.flip_edge">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">flip_edge</span><span class="signature">(self, hid)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.flip_edge-161"><a href="#Manifold.flip_edge-161"><span class="linenos">161</span></a>    <span class="k">def</span> <span class="nf">flip_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hid</span><span class="p">):</span>
</span><span id="Manifold.flip_edge-162"><a href="#Manifold.flip_edge-162"><span class="linenos">162</span></a>        <span class="sd">&quot;&quot;&quot; Flip the edge, hid, separating two faces. The function first verifies that</span>
</span><span id="Manifold.flip_edge-163"><a href="#Manifold.flip_edge-163"><span class="linenos">163</span></a><span class="sd">        the edge is flippable. This entails making sure that all of the</span>
</span><span id="Manifold.flip_edge-164"><a href="#Manifold.flip_edge-164"><span class="linenos">164</span></a><span class="sd">        following are true.</span>
</span><span id="Manifold.flip_edge-165"><a href="#Manifold.flip_edge-165"><span class="linenos">165</span></a><span class="sd">        1. adjacent faces are triangles.</span>
</span><span id="Manifold.flip_edge-166"><a href="#Manifold.flip_edge-166"><span class="linenos">166</span></a><span class="sd">        2. neither end point has valency three or less.</span>
</span><span id="Manifold.flip_edge-167"><a href="#Manifold.flip_edge-167"><span class="linenos">167</span></a><span class="sd">        3. the vertices that will be connected are not already.</span>
</span><span id="Manifold.flip_edge-168"><a href="#Manifold.flip_edge-168"><span class="linenos">168</span></a><span class="sd">        If the tests are passed, the flip is performed and the function</span>
</span><span id="Manifold.flip_edge-169"><a href="#Manifold.flip_edge-169"><span class="linenos">169</span></a><span class="sd">        returns True. Otherwise False.&quot;&quot;&quot;</span>
</span><span id="Manifold.flip_edge-170"><a href="#Manifold.flip_edge-170"><span class="linenos">170</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_flip_edge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span><span class="n">hid</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Flip the edge, hid, separating two faces. The function first verifies that
the edge is flippable. This entails making sure that all of the
following are true.</p>

<ol>
<li>adjacent faces are triangles.</li>
<li>neither end point has valency three or less.</li>
<li>the vertices that will be connected are not already.
If the tests are passed, the flip is performed and the function
returns True. Otherwise False.</li>
</ol>
</div>


                            </div>
                            <div id="Manifold.collapse_edge" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.collapse_edge">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">collapse_edge</span><span class="signature">(self, hid, avg_vertices=False)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.collapse_edge-171"><a href="#Manifold.collapse_edge-171"><span class="linenos">171</span></a>    <span class="k">def</span> <span class="nf">collapse_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hid</span><span class="p">,</span> <span class="n">avg_vertices</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="Manifold.collapse_edge-172"><a href="#Manifold.collapse_edge-172"><span class="linenos">172</span></a>        <span class="sd">&quot;&quot;&quot; Collapse an edge hid.</span>
</span><span id="Manifold.collapse_edge-173"><a href="#Manifold.collapse_edge-173"><span class="linenos">173</span></a><span class="sd">        Before collapsing hid, a number of tests are made:</span>
</span><span id="Manifold.collapse_edge-174"><a href="#Manifold.collapse_edge-174"><span class="linenos">174</span></a><span class="sd">        ---</span>
</span><span id="Manifold.collapse_edge-175"><a href="#Manifold.collapse_edge-175"><span class="linenos">175</span></a><span class="sd">        1.  For the two vertices adjacent to the edge, we generate a list of all their neighbouring vertices.</span>
</span><span id="Manifold.collapse_edge-176"><a href="#Manifold.collapse_edge-176"><span class="linenos">176</span></a><span class="sd">        We then generate a  list of the vertices that occur in both these lists.</span>
</span><span id="Manifold.collapse_edge-177"><a href="#Manifold.collapse_edge-177"><span class="linenos">177</span></a><span class="sd">        That is, we find all vertices connected by edges to both endpoints of the edge and store these in a list.</span>
</span><span id="Manifold.collapse_edge-178"><a href="#Manifold.collapse_edge-178"><span class="linenos">178</span></a><span class="sd">        2.  For both faces incident on the edge, check whether they are triangular.</span>
</span><span id="Manifold.collapse_edge-179"><a href="#Manifold.collapse_edge-179"><span class="linenos">179</span></a><span class="sd">        If this is the case, the face will be removed, and it is ok that the the third vertex is connected to both endpoints.</span>
</span><span id="Manifold.collapse_edge-180"><a href="#Manifold.collapse_edge-180"><span class="linenos">180</span></a><span class="sd">        Thus the third vertex in such a face is removed from the list generated in 1.</span>
</span><span id="Manifold.collapse_edge-181"><a href="#Manifold.collapse_edge-181"><span class="linenos">181</span></a><span class="sd">        3.  If the list is now empty, all is well.</span>
</span><span id="Manifold.collapse_edge-182"><a href="#Manifold.collapse_edge-182"><span class="linenos">182</span></a><span class="sd">        Otherwise, there would be a vertex in the new mesh with two edges connecting it to the same vertex. Return false.</span>
</span><span id="Manifold.collapse_edge-183"><a href="#Manifold.collapse_edge-183"><span class="linenos">183</span></a><span class="sd">        4.  TETRAHEDRON TEST:</span>
</span><span id="Manifold.collapse_edge-184"><a href="#Manifold.collapse_edge-184"><span class="linenos">184</span></a><span class="sd">        If the valency of both vertices is three, and the incident faces are triangles, we also disallow the operation.</span>
</span><span id="Manifold.collapse_edge-185"><a href="#Manifold.collapse_edge-185"><span class="linenos">185</span></a><span class="sd">        Reason: A vertex valency of two and two triangles incident on the adjacent vertices makes the construction collapse.</span>
</span><span id="Manifold.collapse_edge-186"><a href="#Manifold.collapse_edge-186"><span class="linenos">186</span></a><span class="sd">        5.  VALENCY 4 TEST:</span>
</span><span id="Manifold.collapse_edge-187"><a href="#Manifold.collapse_edge-187"><span class="linenos">187</span></a><span class="sd">        If a triangle is adjacent to the edge being collapsed, it disappears.</span>
</span><span id="Manifold.collapse_edge-188"><a href="#Manifold.collapse_edge-188"><span class="linenos">188</span></a><span class="sd">        This means the valency of the remaining edge vertex is decreased by one.</span>
</span><span id="Manifold.collapse_edge-189"><a href="#Manifold.collapse_edge-189"><span class="linenos">189</span></a><span class="sd">        A valency two vertex reduced to a valency one vertex is considered illegal.</span>
</span><span id="Manifold.collapse_edge-190"><a href="#Manifold.collapse_edge-190"><span class="linenos">190</span></a><span class="sd">        6.  PREVENT MERGING HOLES:</span>
</span><span id="Manifold.collapse_edge-191"><a href="#Manifold.collapse_edge-191"><span class="linenos">191</span></a><span class="sd">        Collapsing an edge with boundary endpoints and valid faces results in the creation where two holes meet.</span>
</span><span id="Manifold.collapse_edge-192"><a href="#Manifold.collapse_edge-192"><span class="linenos">192</span></a><span class="sd">        A non manifold situation. We could relax this...</span>
</span><span id="Manifold.collapse_edge-193"><a href="#Manifold.collapse_edge-193"><span class="linenos">193</span></a><span class="sd">        7. New test: if the same face is in the one-ring of both vertices but not adjacent to the common edge,</span>
</span><span id="Manifold.collapse_edge-194"><a href="#Manifold.collapse_edge-194"><span class="linenos">194</span></a><span class="sd">        then the result of a collapse would be a one ring where the same face occurs twice. This is disallowed as the resulting</span>
</span><span id="Manifold.collapse_edge-195"><a href="#Manifold.collapse_edge-195"><span class="linenos">195</span></a><span class="sd">        face would be non-simple.</span>
</span><span id="Manifold.collapse_edge-196"><a href="#Manifold.collapse_edge-196"><span class="linenos">196</span></a><span class="sd">        If the tests are passed, the collapse is performed and the function</span>
</span><span id="Manifold.collapse_edge-197"><a href="#Manifold.collapse_edge-197"><span class="linenos">197</span></a><span class="sd">        returns True. Otherwise False.&quot;&quot;&quot;</span>
</span><span id="Manifold.collapse_edge-198"><a href="#Manifold.collapse_edge-198"><span class="linenos">198</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_collapse_edge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">hid</span><span class="p">,</span> <span class="n">avg_vertices</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Collapse an edge hid.</p>

<h2 id="before-collapsing-hid-a-number-of-tests-are-made">Before collapsing hid, a number of tests are made:</h2>

<ol>
<li>For the two vertices adjacent to the edge, we generate a list of all their neighbouring vertices.
We then generate a  list of the vertices that occur in both these lists.
That is, we find all vertices connected by edges to both endpoints of the edge and store these in a list.</li>
<li>For both faces incident on the edge, check whether they are triangular.
If this is the case, the face will be removed, and it is ok that the the third vertex is connected to both endpoints.
Thus the third vertex in such a face is removed from the list generated in 1.</li>
<li>If the list is now empty, all is well.
Otherwise, there would be a vertex in the new mesh with two edges connecting it to the same vertex. Return false.</li>
<li>TETRAHEDRON TEST:
If the valency of both vertices is three, and the incident faces are triangles, we also disallow the operation.
Reason: A vertex valency of two and two triangles incident on the adjacent vertices makes the construction collapse.</li>
<li>VALENCY 4 TEST:
If a triangle is adjacent to the edge being collapsed, it disappears.
This means the valency of the remaining edge vertex is decreased by one.
A valency two vertex reduced to a valency one vertex is considered illegal.</li>
<li>PREVENT MERGING HOLES:
Collapsing an edge with boundary endpoints and valid faces results in the creation where two holes meet.
A non manifold situation. We could relax this...</li>
<li>New test: if the same face is in the one-ring of both vertices but not adjacent to the common edge,
then the result of a collapse would be a one ring where the same face occurs twice. This is disallowed as the resulting
face would be non-simple.
If the tests are passed, the collapse is performed and the function
returns True. Otherwise False.</li>
</ol>
</div>


                            </div>
                            <div id="Manifold.split_face_by_edge" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.split_face_by_edge">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">split_face_by_edge</span><span class="signature">(self, fid, v0, v1)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.split_face_by_edge-199"><a href="#Manifold.split_face_by_edge-199"><span class="linenos">199</span></a>    <span class="k">def</span> <span class="nf">split_face_by_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fid</span><span class="p">,</span><span class="n">v0</span><span class="p">,</span><span class="n">v1</span><span class="p">):</span>
</span><span id="Manifold.split_face_by_edge-200"><a href="#Manifold.split_face_by_edge-200"><span class="linenos">200</span></a>        <span class="sd">&quot;&quot;&quot;   Split a face. The face, fid, is split by creating an edge with</span>
</span><span id="Manifold.split_face_by_edge-201"><a href="#Manifold.split_face_by_edge-201"><span class="linenos">201</span></a><span class="sd">        endpoints v0 and v1 (the next two arguments). The vertices of the old</span>
</span><span id="Manifold.split_face_by_edge-202"><a href="#Manifold.split_face_by_edge-202"><span class="linenos">202</span></a><span class="sd">        face between v0 and v1 (in counter clockwise order) continue to belong</span>
</span><span id="Manifold.split_face_by_edge-203"><a href="#Manifold.split_face_by_edge-203"><span class="linenos">203</span></a><span class="sd">        to fid. The vertices between v1 and v0 belong to the new face. A handle to</span>
</span><span id="Manifold.split_face_by_edge-204"><a href="#Manifold.split_face_by_edge-204"><span class="linenos">204</span></a><span class="sd">        the new face is returned. &quot;&quot;&quot;</span>
</span><span id="Manifold.split_face_by_edge-205"><a href="#Manifold.split_face_by_edge-205"><span class="linenos">205</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_split_face_by_edge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Split a face. The face, fid, is split by creating an edge with
endpoints v0 and v1 (the next two arguments). The vertices of the old
face between v0 and v1 (in counter clockwise order) continue to belong
to fid. The vertices between v1 and v0 belong to the new face. A handle to
the new face is returned.</p>
</div>


                            </div>
                            <div id="Manifold.split_face_by_vertex" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.split_face_by_vertex">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">split_face_by_vertex</span><span class="signature">(self, fid)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.split_face_by_vertex-206"><a href="#Manifold.split_face_by_vertex-206"><span class="linenos">206</span></a>    <span class="k">def</span> <span class="nf">split_face_by_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fid</span><span class="p">):</span>
</span><span id="Manifold.split_face_by_vertex-207"><a href="#Manifold.split_face_by_vertex-207"><span class="linenos">207</span></a>        <span class="sd">&quot;&quot;&quot;   Split a polygon, fid, by inserting a vertex at the barycenter. This</span>
</span><span id="Manifold.split_face_by_vertex-208"><a href="#Manifold.split_face_by_vertex-208"><span class="linenos">208</span></a><span class="sd">        function is less likely to create flipped triangles than the</span>
</span><span id="Manifold.split_face_by_vertex-209"><a href="#Manifold.split_face_by_vertex-209"><span class="linenos">209</span></a><span class="sd">        split_face_triangulate function. On the other hand, it introduces more</span>
</span><span id="Manifold.split_face_by_vertex-210"><a href="#Manifold.split_face_by_vertex-210"><span class="linenos">210</span></a><span class="sd">        vertices and probably makes the triangles more acute. The vertex id of the</span>
</span><span id="Manifold.split_face_by_vertex-211"><a href="#Manifold.split_face_by_vertex-211"><span class="linenos">211</span></a><span class="sd">        inserted vertex is returned. &quot;&quot;&quot;</span>
</span><span id="Manifold.split_face_by_vertex-212"><a href="#Manifold.split_face_by_vertex-212"><span class="linenos">212</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_split_face_by_vertex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span><span class="n">fid</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Split a polygon, fid, by inserting a vertex at the barycenter. This
function is less likely to create flipped triangles than the
split_face_triangulate function. On the other hand, it introduces more
vertices and probably makes the triangles more acute. The vertex id of the
inserted vertex is returned.</p>
</div>


                            </div>
                            <div id="Manifold.split_edge" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.split_edge">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">split_edge</span><span class="signature">(self, hid)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.split_edge-213"><a href="#Manifold.split_edge-213"><span class="linenos">213</span></a>    <span class="k">def</span> <span class="nf">split_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hid</span><span class="p">):</span>
</span><span id="Manifold.split_edge-214"><a href="#Manifold.split_edge-214"><span class="linenos">214</span></a>        <span class="sd">&quot;&quot;&quot;   Insert a new vertex on halfedge hid. The new halfedge is insterted</span>
</span><span id="Manifold.split_edge-215"><a href="#Manifold.split_edge-215"><span class="linenos">215</span></a><span class="sd">        as the previous edge to hid. The vertex id of the inserted vertex is returned. &quot;&quot;&quot;</span>
</span><span id="Manifold.split_edge-216"><a href="#Manifold.split_edge-216"><span class="linenos">216</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_split_edge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span><span class="n">hid</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Insert a new vertex on halfedge hid. The new halfedge is insterted
as the previous edge to hid. The vertex id of the inserted vertex is returned.</p>
</div>


                            </div>
                            <div id="Manifold.stitch_boundary_edges" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.stitch_boundary_edges">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">stitch_boundary_edges</span><span class="signature">(self, h0, h1)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.stitch_boundary_edges-217"><a href="#Manifold.stitch_boundary_edges-217"><span class="linenos">217</span></a>    <span class="k">def</span> <span class="nf">stitch_boundary_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">h0</span><span class="p">,</span><span class="n">h1</span><span class="p">):</span>
</span><span id="Manifold.stitch_boundary_edges-218"><a href="#Manifold.stitch_boundary_edges-218"><span class="linenos">218</span></a>        <span class="sd">&quot;&quot;&quot;   Stitch two halfedges. Two boundary halfedges, h0 and h1, can be stitched</span>
</span><span id="Manifold.stitch_boundary_edges-219"><a href="#Manifold.stitch_boundary_edges-219"><span class="linenos">219</span></a><span class="sd">        together. This can be used to build a complex mesh from a bunch of</span>
</span><span id="Manifold.stitch_boundary_edges-220"><a href="#Manifold.stitch_boundary_edges-220"><span class="linenos">220</span></a><span class="sd">        simple faces. &quot;&quot;&quot;</span>
</span><span id="Manifold.stitch_boundary_edges-221"><a href="#Manifold.stitch_boundary_edges-221"><span class="linenos">221</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_stitch_boundary_edges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">h0</span><span class="p">,</span> <span class="n">h1</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Stitch two halfedges. Two boundary halfedges, h0 and h1, can be stitched
together. This can be used to build a complex mesh from a bunch of
simple faces.</p>
</div>


                            </div>
                            <div id="Manifold.merge_faces" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.merge_faces">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">merge_faces</span><span class="signature">(self, hid)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.merge_faces-222"><a href="#Manifold.merge_faces-222"><span class="linenos">222</span></a>    <span class="k">def</span> <span class="nf">merge_faces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hid</span><span class="p">):</span>
</span><span id="Manifold.merge_faces-223"><a href="#Manifold.merge_faces-223"><span class="linenos">223</span></a>        <span class="sd">&quot;&quot;&quot;   Merges two faces into a single polygon. The merged faces are those shared</span>
</span><span id="Manifold.merge_faces-224"><a href="#Manifold.merge_faces-224"><span class="linenos">224</span></a><span class="sd">        by the edge for which hid is one of the two corresponding halfedges. This function returns</span>
</span><span id="Manifold.merge_faces-225"><a href="#Manifold.merge_faces-225"><span class="linenos">225</span></a><span class="sd">        true if the merging was possible and false otherwise. Currently merge</span>
</span><span id="Manifold.merge_faces-226"><a href="#Manifold.merge_faces-226"><span class="linenos">226</span></a><span class="sd">        only fails if the mesh is already illegal. Thus it should, in fact,</span>
</span><span id="Manifold.merge_faces-227"><a href="#Manifold.merge_faces-227"><span class="linenos">227</span></a><span class="sd">        never fail. &quot;&quot;&quot;</span>
</span><span id="Manifold.merge_faces-228"><a href="#Manifold.merge_faces-228"><span class="linenos">228</span></a>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_halfedge_at_boundary</span><span class="p">(</span><span class="n">hid</span><span class="p">):</span>
</span><span id="Manifold.merge_faces-229"><a href="#Manifold.merge_faces-229"><span class="linenos">229</span></a>            <span class="k">return</span> <span class="kc">False</span>
</span><span id="Manifold.merge_faces-230"><a href="#Manifold.merge_faces-230"><span class="linenos">230</span></a>        <span class="n">fid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">incident_face</span><span class="p">(</span><span class="n">hid</span><span class="p">)</span>
</span><span id="Manifold.merge_faces-231"><a href="#Manifold.merge_faces-231"><span class="linenos">231</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_merge_faces</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">hid</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Merges two faces into a single polygon. The merged faces are those shared
by the edge for which hid is one of the two corresponding halfedges. This function returns
true if the merging was possible and false otherwise. Currently merge
only fails if the mesh is already illegal. Thus it should, in fact,
never fail.</p>
</div>


                            </div>
                            <div id="Manifold.close_hole" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.close_hole">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">close_hole</span><span class="signature">(self, hid)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.close_hole-232"><a href="#Manifold.close_hole-232"><span class="linenos">232</span></a>    <span class="k">def</span> <span class="nf">close_hole</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">hid</span><span class="p">):</span>
</span><span id="Manifold.close_hole-233"><a href="#Manifold.close_hole-233"><span class="linenos">233</span></a>        <span class="sd">&quot;&quot;&quot; Close hole given by hid (i.e. the face referenced by hid). Returns</span>
</span><span id="Manifold.close_hole-234"><a href="#Manifold.close_hole-234"><span class="linenos">234</span></a><span class="sd">        index of the created face or the face that was already there if, in</span>
</span><span id="Manifold.close_hole-235"><a href="#Manifold.close_hole-235"><span class="linenos">235</span></a><span class="sd">        fact, hid was not next to a hole. &quot;&quot;&quot;</span>
</span><span id="Manifold.close_hole-236"><a href="#Manifold.close_hole-236"><span class="linenos">236</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_close_hole</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">hid</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Close hole given by hid (i.e. the face referenced by hid). Returns
index of the created face or the face that was already there if, in
fact, hid was not next to a hole.</p>
</div>


                            </div>
                            <div id="Manifold.cleanup" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.cleanup">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">cleanup</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.cleanup-237"><a href="#Manifold.cleanup-237"><span class="linenos">237</span></a>    <span class="k">def</span> <span class="nf">cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="Manifold.cleanup-238"><a href="#Manifold.cleanup-238"><span class="linenos">238</span></a>        <span class="sd">&quot;&quot;&quot; Remove unused items from Mesh. This function remaps all vertices, halfedges</span>
</span><span id="Manifold.cleanup-239"><a href="#Manifold.cleanup-239"><span class="linenos">239</span></a><span class="sd">        and faces such that the arrays do not contain any holes left by unused mesh</span>
</span><span id="Manifold.cleanup-240"><a href="#Manifold.cleanup-240"><span class="linenos">240</span></a><span class="sd">        entities. It is a good idea to call this function when a mesh has been simplified</span>
</span><span id="Manifold.cleanup-241"><a href="#Manifold.cleanup-241"><span class="linenos">241</span></a><span class="sd">        or changed in other ways such that mesh entities have been removed. However, note</span>
</span><span id="Manifold.cleanup-242"><a href="#Manifold.cleanup-242"><span class="linenos">242</span></a><span class="sd">        that it invalidates any attributes that you might have stored in auxilliary arrays.&quot;&quot;&quot;</span>
</span><span id="Manifold.cleanup-243"><a href="#Manifold.cleanup-243"><span class="linenos">243</span></a>        <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">Manifold_cleanup</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Remove unused items from Mesh. This function remaps all vertices, halfedges
and faces such that the arrays do not contain any holes left by unused mesh
entities. It is a good idea to call this function when a mesh has been simplified
or changed in other ways such that mesh entities have been removed. However, note
that it invalidates any attributes that you might have stored in auxilliary arrays.</p>
</div>


                            </div>
                            <div id="Manifold.is_halfedge_at_boundary" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.is_halfedge_at_boundary">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">is_halfedge_at_boundary</span><span class="signature">(self, hid)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.is_halfedge_at_boundary-244"><a href="#Manifold.is_halfedge_at_boundary-244"><span class="linenos">244</span></a>    <span class="k">def</span> <span class="nf">is_halfedge_at_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hid</span><span class="p">):</span>
</span><span id="Manifold.is_halfedge_at_boundary-245"><a href="#Manifold.is_halfedge_at_boundary-245"><span class="linenos">245</span></a>        <span class="sd">&quot;&quot;&quot; Returns True if hid is a boundary halfedge, i.e. face on either</span>
</span><span id="Manifold.is_halfedge_at_boundary-246"><a href="#Manifold.is_halfedge_at_boundary-246"><span class="linenos">246</span></a><span class="sd">        side is invalid. &quot;&quot;&quot;</span>
</span><span id="Manifold.is_halfedge_at_boundary-247"><a href="#Manifold.is_halfedge_at_boundary-247"><span class="linenos">247</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">is_halfedge_at_boundary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">hid</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Returns True if hid is a boundary halfedge, i.e. face on either
side is invalid.</p>
</div>


                            </div>
                            <div id="Manifold.is_vertex_at_boundary" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.is_vertex_at_boundary">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">is_vertex_at_boundary</span><span class="signature">(self, vid)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.is_vertex_at_boundary-248"><a href="#Manifold.is_vertex_at_boundary-248"><span class="linenos">248</span></a>    <span class="k">def</span> <span class="nf">is_vertex_at_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vid</span><span class="p">):</span>
</span><span id="Manifold.is_vertex_at_boundary-249"><a href="#Manifold.is_vertex_at_boundary-249"><span class="linenos">249</span></a>        <span class="sd">&quot;&quot;&quot; Returns True if vid lies on a boundary. &quot;&quot;&quot;</span>
</span><span id="Manifold.is_vertex_at_boundary-250"><a href="#Manifold.is_vertex_at_boundary-250"><span class="linenos">250</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">is_vertex_at_boundary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">vid</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Returns True if vid lies on a boundary.</p>
</div>


                            </div>
                            <div id="Manifold.edge_length" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.edge_length">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">edge_length</span><span class="signature">(self, hid)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.edge_length-251"><a href="#Manifold.edge_length-251"><span class="linenos">251</span></a>    <span class="k">def</span> <span class="nf">edge_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hid</span><span class="p">):</span>
</span><span id="Manifold.edge_length-252"><a href="#Manifold.edge_length-252"><span class="linenos">252</span></a>        <span class="sd">&quot;&quot;&quot; Returns length of edge given by halfedge hid which is passed as argument. &quot;&quot;&quot;</span>
</span><span id="Manifold.edge_length-253"><a href="#Manifold.edge_length-253"><span class="linenos">253</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">length</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">hid</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Returns length of edge given by halfedge hid which is passed as argument.</p>
</div>


                            </div>
                            <div id="Manifold.valency" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.valency">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">valency</span><span class="signature">(self, vid)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.valency-254"><a href="#Manifold.valency-254"><span class="linenos">254</span></a>    <span class="k">def</span> <span class="nf">valency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">vid</span><span class="p">):</span>
</span><span id="Manifold.valency-255"><a href="#Manifold.valency-255"><span class="linenos">255</span></a>        <span class="sd">&quot;&quot;&quot; Returns valency of vid, i.e. number of incident edges.&quot;&quot;&quot;</span>
</span><span id="Manifold.valency-256"><a href="#Manifold.valency-256"><span class="linenos">256</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">valency</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span><span class="n">vid</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Returns valency of vid, i.e. number of incident edges.</p>
</div>


                            </div>
                            <div id="Manifold.vertex_normal" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.vertex_normal">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">vertex_normal</span><span class="signature">(self, vid)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.vertex_normal-257"><a href="#Manifold.vertex_normal-257"><span class="linenos">257</span></a>    <span class="k">def</span> <span class="nf">vertex_normal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vid</span><span class="p">):</span>
</span><span id="Manifold.vertex_normal-258"><a href="#Manifold.vertex_normal-258"><span class="linenos">258</span></a>        <span class="sd">&quot;&quot;&quot; Returns vertex normal (angle weighted) of vertex given by vid &quot;&quot;&quot;</span>
</span><span id="Manifold.vertex_normal-259"><a href="#Manifold.vertex_normal-259"><span class="linenos">259</span></a>        <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">c_double</span><span class="o">*</span><span class="mi">3</span><span class="p">)()</span>
</span><span id="Manifold.vertex_normal-260"><a href="#Manifold.vertex_normal-260"><span class="linenos">260</span></a>        <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">vertex_normal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">vid</span><span class="p">,</span> <span class="n">ct</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
</span><span id="Manifold.vertex_normal-261"><a href="#Manifold.vertex_normal-261"><span class="linenos">261</span></a>        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Returns vertex normal (angle weighted) of vertex given by vid</p>
</div>


                            </div>
                            <div id="Manifold.connected" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.connected">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">connected</span><span class="signature">(self, v0, v1)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.connected-262"><a href="#Manifold.connected-262"><span class="linenos">262</span></a>    <span class="k">def</span> <span class="nf">connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">):</span>
</span><span id="Manifold.connected-263"><a href="#Manifold.connected-263"><span class="linenos">263</span></a>        <span class="sd">&quot;&quot;&quot; Returns true if the two argument vertices, v0 and v1, are in each other&#39;s one-rings.&quot;&quot;&quot;</span>
</span><span id="Manifold.connected-264"><a href="#Manifold.connected-264"><span class="linenos">264</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">connected</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span><span class="n">v0</span><span class="p">,</span><span class="n">v1</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Returns true if the two argument vertices, v0 and v1, are in each other's one-rings.</p>
</div>


                            </div>
                            <div id="Manifold.no_edges" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.no_edges">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">no_edges</span><span class="signature">(self, fid)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.no_edges-265"><a href="#Manifold.no_edges-265"><span class="linenos">265</span></a>    <span class="k">def</span> <span class="nf">no_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fid</span><span class="p">):</span>
</span><span id="Manifold.no_edges-266"><a href="#Manifold.no_edges-266"><span class="linenos">266</span></a>        <span class="sd">&quot;&quot;&quot; Compute the number of edges of a face fid &quot;&quot;&quot;</span>
</span><span id="Manifold.no_edges-267"><a href="#Manifold.no_edges-267"><span class="linenos">267</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">no_edges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">fid</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Compute the number of edges of a face fid</p>
</div>


                            </div>
                            <div id="Manifold.face_normal" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.face_normal">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">face_normal</span><span class="signature">(self, fid)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.face_normal-268"><a href="#Manifold.face_normal-268"><span class="linenos">268</span></a>    <span class="k">def</span> <span class="nf">face_normal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fid</span><span class="p">):</span>
</span><span id="Manifold.face_normal-269"><a href="#Manifold.face_normal-269"><span class="linenos">269</span></a>        <span class="sd">&quot;&quot;&quot; Compute the normal of a face fid. If the face is not a triangle,</span>
</span><span id="Manifold.face_normal-270"><a href="#Manifold.face_normal-270"><span class="linenos">270</span></a><span class="sd">        the normal is not defined, but computed using the first three</span>
</span><span id="Manifold.face_normal-271"><a href="#Manifold.face_normal-271"><span class="linenos">271</span></a><span class="sd">        vertices of the face. &quot;&quot;&quot;</span>
</span><span id="Manifold.face_normal-272"><a href="#Manifold.face_normal-272"><span class="linenos">272</span></a>        <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">c_double</span><span class="o">*</span><span class="mi">3</span><span class="p">)()</span>
</span><span id="Manifold.face_normal-273"><a href="#Manifold.face_normal-273"><span class="linenos">273</span></a>        <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">face_normal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">ct</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
</span><span id="Manifold.face_normal-274"><a href="#Manifold.face_normal-274"><span class="linenos">274</span></a>        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Compute the normal of a face fid. If the face is not a triangle,
the normal is not defined, but computed using the first three
vertices of the face.</p>
</div>


                            </div>
                            <div id="Manifold.area" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.area">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">area</span><span class="signature">(self, fid)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.area-275"><a href="#Manifold.area-275"><span class="linenos">275</span></a>    <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fid</span><span class="p">):</span>
</span><span id="Manifold.area-276"><a href="#Manifold.area-276"><span class="linenos">276</span></a>        <span class="sd">&quot;&quot;&quot; Returns the area of a face fid. &quot;&quot;&quot;</span>
</span><span id="Manifold.area-277"><a href="#Manifold.area-277"><span class="linenos">277</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">area</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">fid</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Returns the area of a face fid.</p>
</div>


                            </div>
                            <div id="Manifold.perimeter" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.perimeter">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">perimeter</span><span class="signature">(self, fid)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.perimeter-278"><a href="#Manifold.perimeter-278"><span class="linenos">278</span></a>    <span class="k">def</span> <span class="nf">perimeter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fid</span><span class="p">):</span>
</span><span id="Manifold.perimeter-279"><a href="#Manifold.perimeter-279"><span class="linenos">279</span></a>        <span class="sd">&quot;&quot;&quot; Returns the perimeter of a face fid. &quot;&quot;&quot;</span>
</span><span id="Manifold.perimeter-280"><a href="#Manifold.perimeter-280"><span class="linenos">280</span></a>        <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">perimeter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">fid</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Returns the perimeter of a face fid.</p>
</div>


                            </div>
                            <div id="Manifold.centre" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Manifold.centre">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">centre</span><span class="signature">(self, fid)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="Manifold.centre-281"><a href="#Manifold.centre-281"><span class="linenos">281</span></a>    <span class="k">def</span> <span class="nf">centre</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fid</span><span class="p">):</span>
</span><span id="Manifold.centre-282"><a href="#Manifold.centre-282"><span class="linenos">282</span></a>        <span class="sd">&quot;&quot;&quot; Returns the centre of a face. &quot;&quot;&quot;</span>
</span><span id="Manifold.centre-283"><a href="#Manifold.centre-283"><span class="linenos">283</span></a>        <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">c_double</span><span class="o">*</span><span class="mi">3</span><span class="p">)()</span>
</span><span id="Manifold.centre-284"><a href="#Manifold.centre-284"><span class="linenos">284</span></a>        <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">centre</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">ct</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
</span><span id="Manifold.centre-285"><a href="#Manifold.centre-285"><span class="linenos">285</span></a>        <span class="k">return</span> <span class="n">v</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Returns the centre of a face.</p>
</div>


                            </div>
                </section>
                <section id="valid">
                            <div class="attr function"><a class="headerlink" href="#valid">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">valid</span><span class="signature">(m)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="valid-287"><a href="#valid-287"><span class="linenos">287</span></a><span class="k">def</span> <span class="nf">valid</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
</span><span id="valid-288"><a href="#valid-288"><span class="linenos">288</span></a>    <span class="sd">&quot;&quot;&quot;This function performs a series of tests to check that this</span>
</span><span id="valid-289"><a href="#valid-289"><span class="linenos">289</span></a><span class="sd">    is a valid manifold. This function is not rigorously constructed but seems</span>
</span><span id="valid-290"><a href="#valid-290"><span class="linenos">290</span></a><span class="sd">    to catch all problems so far. The function returns true if the mesh is valid</span>
</span><span id="valid-291"><a href="#valid-291"><span class="linenos">291</span></a><span class="sd">    and false otherwise. &quot;&quot;&quot;</span>
</span><span id="valid-292"><a href="#valid-292"><span class="linenos">292</span></a>    <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">valid</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>This function performs a series of tests to check that this
is a valid manifold. This function is not rigorously constructed but seems
to catch all problems so far. The function returns true if the mesh is valid
and false otherwise.</p>
</div>


                </section>
                <section id="closed">
                            <div class="attr function"><a class="headerlink" href="#closed">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">closed</span><span class="signature">(m)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="closed-294"><a href="#closed-294"><span class="linenos">294</span></a><span class="k">def</span> <span class="nf">closed</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
</span><span id="closed-295"><a href="#closed-295"><span class="linenos">295</span></a>    <span class="sd">&quot;&quot;&quot; Returns true if m is closed, i.e. has no boundary.&quot;&quot;&quot;</span>
</span><span id="closed-296"><a href="#closed-296"><span class="linenos">296</span></a>    <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">closed</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Returns true if m is closed, i.e. has no boundary.</p>
</div>


                </section>
                <section id="bbox">
                            <div class="attr function"><a class="headerlink" href="#bbox">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">bbox</span><span class="signature">(m)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="bbox-298"><a href="#bbox-298"><span class="linenos">298</span></a><span class="k">def</span> <span class="nf">bbox</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
</span><span id="bbox-299"><a href="#bbox-299"><span class="linenos">299</span></a>    <span class="sd">&quot;&quot;&quot; Returns the min and max corners of the bounding box of Manifold m. &quot;&quot;&quot;</span>
</span><span id="bbox-300"><a href="#bbox-300"><span class="linenos">300</span></a>    <span class="n">pmin</span> <span class="o">=</span> <span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">c_double</span><span class="o">*</span><span class="mi">3</span><span class="p">)()</span>
</span><span id="bbox-301"><a href="#bbox-301"><span class="linenos">301</span></a>    <span class="n">pmax</span> <span class="o">=</span> <span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">c_double</span><span class="o">*</span><span class="mi">3</span><span class="p">)()</span>
</span><span id="bbox-302"><a href="#bbox-302"><span class="linenos">302</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">bbox</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">ct</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">pmin</span><span class="p">),</span><span class="n">ct</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">pmax</span><span class="p">))</span>
</span><span id="bbox-303"><a href="#bbox-303"><span class="linenos">303</span></a>    <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">as_array</span><span class="p">(</span><span class="n">pmin</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">as_array</span><span class="p">(</span><span class="n">pmax</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Returns the min and max corners of the bounding box of Manifold m.</p>
</div>


                </section>
                <section id="bsphere">
                            <div class="attr function"><a class="headerlink" href="#bsphere">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">bsphere</span><span class="signature">(m)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="bsphere-305"><a href="#bsphere-305"><span class="linenos">305</span></a><span class="k">def</span> <span class="nf">bsphere</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
</span><span id="bsphere-306"><a href="#bsphere-306"><span class="linenos">306</span></a>    <span class="sd">&quot;&quot;&quot; Calculate the bounding sphere of the manifold m.</span>
</span><span id="bsphere-307"><a href="#bsphere-307"><span class="linenos">307</span></a><span class="sd">    Returns centre,radius &quot;&quot;&quot;</span>
</span><span id="bsphere-308"><a href="#bsphere-308"><span class="linenos">308</span></a>    <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">c_double</span><span class="o">*</span><span class="mi">3</span><span class="p">)()</span>
</span><span id="bsphere-309"><a href="#bsphere-309"><span class="linenos">309</span></a>    <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">c_double</span><span class="p">)()</span>
</span><span id="bsphere-310"><a href="#bsphere-310"><span class="linenos">310</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">bsphere</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span><span class="n">ct</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">c</span><span class="p">),</span><span class="n">ct</span><span class="o">.</span><span class="n">byref</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
</span><span id="bsphere-311"><a href="#bsphere-311"><span class="linenos">311</span></a>    <span class="k">return</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Calculate the bounding sphere of the manifold m.
Returns centre,radius</p>
</div>


                </section>
                <section id="stitch">
                            <div class="attr function"><a class="headerlink" href="#stitch">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">stitch</span><span class="signature">(m, rad=1e-30)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="stitch-313"><a href="#stitch-313"><span class="linenos">313</span></a><span class="k">def</span> <span class="nf">stitch</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">rad</span><span class="o">=</span><span class="mf">1e-30</span><span class="p">):</span>
</span><span id="stitch-314"><a href="#stitch-314"><span class="linenos">314</span></a>    <span class="sd">&quot;&quot;&quot; Stitch together edges of m whose endpoints coincide geometrically. This</span>
</span><span id="stitch-315"><a href="#stitch-315"><span class="linenos">315</span></a><span class="sd">    function allows you to create a mesh as a bunch of faces and then stitch</span>
</span><span id="stitch-316"><a href="#stitch-316"><span class="linenos">316</span></a><span class="sd">    these together to form a coherent whole. What this function adds is a</span>
</span><span id="stitch-317"><a href="#stitch-317"><span class="linenos">317</span></a><span class="sd">    spatial data structure to find out which vertices coincide. The return value</span>
</span><span id="stitch-318"><a href="#stitch-318"><span class="linenos">318</span></a><span class="sd">    is the number of edges that could not be stitched. Often this is because it</span>
</span><span id="stitch-319"><a href="#stitch-319"><span class="linenos">319</span></a><span class="sd">    would introduce a non-manifold situation.&quot;&quot;&quot;</span>
</span><span id="stitch-320"><a href="#stitch-320"><span class="linenos">320</span></a>    <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">stitch_mesh</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span><span class="n">rad</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Stitch together edges of m whose endpoints coincide geometrically. This
function allows you to create a mesh as a bunch of faces and then stitch
these together to form a coherent whole. What this function adds is a
spatial data structure to find out which vertices coincide. The return value
is the number of edges that could not be stitched. Often this is because it
would introduce a non-manifold situation.</p>
</div>


                </section>
                <section id="obj_save">
                            <div class="attr function"><a class="headerlink" href="#obj_save">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">obj_save</span><span class="signature">(fn, m)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="obj_save-322"><a href="#obj_save-322"><span class="linenos">322</span></a><span class="k">def</span> <span class="nf">obj_save</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
</span><span id="obj_save-323"><a href="#obj_save-323"><span class="linenos">323</span></a>    <span class="sd">&quot;&quot;&quot; Save Manifold m to Wavefront obj file. &quot;&quot;&quot;</span>
</span><span id="obj_save-324"><a href="#obj_save-324"><span class="linenos">324</span></a>    <span class="n">s</span> <span class="o">=</span> <span class="n">ct</span><span class="o">.</span><span class="n">c_char_p</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
</span><span id="obj_save-325"><a href="#obj_save-325"><span class="linenos">325</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">obj_save</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Save Manifold m to Wavefront obj file.</p>
</div>


                </section>
                <section id="off_save">
                            <div class="attr function"><a class="headerlink" href="#off_save">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">off_save</span><span class="signature">(fn, m)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="off_save-327"><a href="#off_save-327"><span class="linenos">327</span></a><span class="k">def</span> <span class="nf">off_save</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
</span><span id="off_save-328"><a href="#off_save-328"><span class="linenos">328</span></a>    <span class="sd">&quot;&quot;&quot; Save Manifold m to OFF file. &quot;&quot;&quot;</span>
</span><span id="off_save-329"><a href="#off_save-329"><span class="linenos">329</span></a>    <span class="n">s</span> <span class="o">=</span> <span class="n">ct</span><span class="o">.</span><span class="n">c_char_p</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
</span><span id="off_save-330"><a href="#off_save-330"><span class="linenos">330</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">off_save</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Save Manifold m to OFF file.</p>
</div>


                </section>
                <section id="x3d_save">
                            <div class="attr function"><a class="headerlink" href="#x3d_save">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">x3d_save</span><span class="signature">(fn, m)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="x3d_save-332"><a href="#x3d_save-332"><span class="linenos">332</span></a><span class="k">def</span> <span class="nf">x3d_save</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
</span><span id="x3d_save-333"><a href="#x3d_save-333"><span class="linenos">333</span></a>    <span class="sd">&quot;&quot;&quot; Save Manifold m to X3D file. &quot;&quot;&quot;</span>
</span><span id="x3d_save-334"><a href="#x3d_save-334"><span class="linenos">334</span></a>    <span class="n">s</span> <span class="o">=</span> <span class="n">ct</span><span class="o">.</span><span class="n">c_char_p</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
</span><span id="x3d_save-335"><a href="#x3d_save-335"><span class="linenos">335</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">x3d_save</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Save Manifold m to X3D file.</p>
</div>


                </section>
                <section id="obj_load">
                            <div class="attr function"><a class="headerlink" href="#obj_load">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">obj_load</span><span class="signature">(fn)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="obj_load-337"><a href="#obj_load-337"><span class="linenos">337</span></a><span class="k">def</span> <span class="nf">obj_load</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
</span><span id="obj_load-338"><a href="#obj_load-338"><span class="linenos">338</span></a>    <span class="sd">&quot;&quot;&quot; Load and return Manifold from Wavefront obj file.</span>
</span><span id="obj_load-339"><a href="#obj_load-339"><span class="linenos">339</span></a><span class="sd">    Returns None if loading failed. &quot;&quot;&quot;</span>
</span><span id="obj_load-340"><a href="#obj_load-340"><span class="linenos">340</span></a>    <span class="n">m</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">()</span>
</span><span id="obj_load-341"><a href="#obj_load-341"><span class="linenos">341</span></a>    <span class="n">s</span> <span class="o">=</span> <span class="n">ct</span><span class="o">.</span><span class="n">c_char_p</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
</span><span id="obj_load-342"><a href="#obj_load-342"><span class="linenos">342</span></a>    <span class="k">if</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">obj_load</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">):</span>
</span><span id="obj_load-343"><a href="#obj_load-343"><span class="linenos">343</span></a>        <span class="k">return</span> <span class="n">m</span>
</span><span id="obj_load-344"><a href="#obj_load-344"><span class="linenos">344</span></a>    <span class="k">return</span> <span class="kc">None</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Load and return Manifold from Wavefront obj file.
Returns None if loading failed.</p>
</div>


                </section>
                <section id="off_load">
                            <div class="attr function"><a class="headerlink" href="#off_load">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">off_load</span><span class="signature">(fn)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="off_load-346"><a href="#off_load-346"><span class="linenos">346</span></a><span class="k">def</span> <span class="nf">off_load</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
</span><span id="off_load-347"><a href="#off_load-347"><span class="linenos">347</span></a>    <span class="sd">&quot;&quot;&quot; Load and return Manifold from OFF file.</span>
</span><span id="off_load-348"><a href="#off_load-348"><span class="linenos">348</span></a><span class="sd">    Returns None if loading failed.&quot;&quot;&quot;</span>
</span><span id="off_load-349"><a href="#off_load-349"><span class="linenos">349</span></a>    <span class="n">m</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">()</span>
</span><span id="off_load-350"><a href="#off_load-350"><span class="linenos">350</span></a>    <span class="n">s</span> <span class="o">=</span> <span class="n">ct</span><span class="o">.</span><span class="n">c_char_p</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
</span><span id="off_load-351"><a href="#off_load-351"><span class="linenos">351</span></a>    <span class="k">if</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">off_load</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">):</span>
</span><span id="off_load-352"><a href="#off_load-352"><span class="linenos">352</span></a>        <span class="k">return</span> <span class="n">m</span>
</span><span id="off_load-353"><a href="#off_load-353"><span class="linenos">353</span></a>    <span class="k">return</span> <span class="kc">None</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Load and return Manifold from OFF file.
Returns None if loading failed.</p>
</div>


                </section>
                <section id="ply_load">
                            <div class="attr function"><a class="headerlink" href="#ply_load">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ply_load</span><span class="signature">(fn)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="ply_load-355"><a href="#ply_load-355"><span class="linenos">355</span></a><span class="k">def</span> <span class="nf">ply_load</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
</span><span id="ply_load-356"><a href="#ply_load-356"><span class="linenos">356</span></a>    <span class="sd">&quot;&quot;&quot; Load and return Manifold from Stanford PLY file.</span>
</span><span id="ply_load-357"><a href="#ply_load-357"><span class="linenos">357</span></a><span class="sd">    Returns None if loading failed. &quot;&quot;&quot;</span>
</span><span id="ply_load-358"><a href="#ply_load-358"><span class="linenos">358</span></a>    <span class="n">m</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">()</span>
</span><span id="ply_load-359"><a href="#ply_load-359"><span class="linenos">359</span></a>    <span class="n">s</span> <span class="o">=</span> <span class="n">ct</span><span class="o">.</span><span class="n">c_char_p</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
</span><span id="ply_load-360"><a href="#ply_load-360"><span class="linenos">360</span></a>    <span class="k">if</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">ply_load</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">):</span>
</span><span id="ply_load-361"><a href="#ply_load-361"><span class="linenos">361</span></a>        <span class="k">return</span> <span class="n">m</span>
</span><span id="ply_load-362"><a href="#ply_load-362"><span class="linenos">362</span></a>    <span class="k">return</span> <span class="kc">None</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Load and return Manifold from Stanford PLY file.
Returns None if loading failed.</p>
</div>


                </section>
                <section id="x3d_load">
                            <div class="attr function"><a class="headerlink" href="#x3d_load">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">x3d_load</span><span class="signature">(fn)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="x3d_load-364"><a href="#x3d_load-364"><span class="linenos">364</span></a><span class="k">def</span> <span class="nf">x3d_load</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
</span><span id="x3d_load-365"><a href="#x3d_load-365"><span class="linenos">365</span></a>    <span class="sd">&quot;&quot;&quot; Load and return Manifold from X3D file.</span>
</span><span id="x3d_load-366"><a href="#x3d_load-366"><span class="linenos">366</span></a><span class="sd">    Returns None if loading failed.&quot;&quot;&quot;</span>
</span><span id="x3d_load-367"><a href="#x3d_load-367"><span class="linenos">367</span></a>    <span class="n">m</span> <span class="o">=</span> <span class="n">Manifold</span><span class="p">()</span>
</span><span id="x3d_load-368"><a href="#x3d_load-368"><span class="linenos">368</span></a>    <span class="n">s</span> <span class="o">=</span> <span class="n">ct</span><span class="o">.</span><span class="n">c_char_p</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
</span><span id="x3d_load-369"><a href="#x3d_load-369"><span class="linenos">369</span></a>    <span class="k">if</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">x3d_load</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">):</span>
</span><span id="x3d_load-370"><a href="#x3d_load-370"><span class="linenos">370</span></a>        <span class="k">return</span> <span class="n">m</span>
</span><span id="x3d_load-371"><a href="#x3d_load-371"><span class="linenos">371</span></a>    <span class="k">return</span> <span class="kc">None</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Load and return Manifold from X3D file.
Returns None if loading failed.</p>
</div>


                </section>
                <section id="load">
                            <div class="attr function"><a class="headerlink" href="#load">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">load</span><span class="signature">(fn)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="load-374"><a href="#load-374"><span class="linenos">374</span></a><span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
</span><span id="load-375"><a href="#load-375"><span class="linenos">375</span></a>    <span class="sd">&quot;&quot;&quot; Load a Manifold from an X3D/OBJ/OFF/PLY file. Return the</span>
</span><span id="load-376"><a href="#load-376"><span class="linenos">376</span></a><span class="sd">    loaded Manifold. Returns None if loading failed.&quot;&quot;&quot;</span>
</span><span id="load-377"><a href="#load-377"><span class="linenos">377</span></a>    <span class="n">name</span><span class="p">,</span> <span class="n">extension</span> <span class="o">=</span> <span class="n">splitext</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
</span><span id="load-378"><a href="#load-378"><span class="linenos">378</span></a>    <span class="k">if</span> <span class="n">extension</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;.x3d&quot;</span><span class="p">:</span>
</span><span id="load-379"><a href="#load-379"><span class="linenos">379</span></a>        <span class="k">return</span> <span class="n">x3d_load</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
</span><span id="load-380"><a href="#load-380"><span class="linenos">380</span></a>    <span class="k">if</span> <span class="n">extension</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;.obj&quot;</span><span class="p">:</span>
</span><span id="load-381"><a href="#load-381"><span class="linenos">381</span></a>        <span class="k">return</span> <span class="n">obj_load</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
</span><span id="load-382"><a href="#load-382"><span class="linenos">382</span></a>    <span class="k">if</span> <span class="n">extension</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;.off&quot;</span><span class="p">:</span>
</span><span id="load-383"><a href="#load-383"><span class="linenos">383</span></a>        <span class="k">return</span> <span class="n">off_load</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
</span><span id="load-384"><a href="#load-384"><span class="linenos">384</span></a>    <span class="k">if</span> <span class="n">extension</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;.ply&quot;</span><span class="p">:</span>
</span><span id="load-385"><a href="#load-385"><span class="linenos">385</span></a>        <span class="k">return</span> <span class="n">ply_load</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
</span><span id="load-386"><a href="#load-386"><span class="linenos">386</span></a>    <span class="k">return</span> <span class="kc">None</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Load a Manifold from an X3D/OBJ/OFF/PLY file. Return the
loaded Manifold. Returns None if loading failed.</p>
</div>


                </section>
                <section id="save">
                            <div class="attr function"><a class="headerlink" href="#save">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">save</span><span class="signature">(fn, m)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="save-388"><a href="#save-388"><span class="linenos">388</span></a><span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
</span><span id="save-389"><a href="#save-389"><span class="linenos">389</span></a>    <span class="sd">&quot;&quot;&quot; Save a Manifold, m, to an X3D/OBJ/OFF file. &quot;&quot;&quot;</span>
</span><span id="save-390"><a href="#save-390"><span class="linenos">390</span></a>    <span class="n">name</span><span class="p">,</span> <span class="n">extension</span> <span class="o">=</span> <span class="n">splitext</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
</span><span id="save-391"><a href="#save-391"><span class="linenos">391</span></a>    <span class="k">if</span> <span class="n">extension</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;.x3d&quot;</span><span class="p">:</span>
</span><span id="save-392"><a href="#save-392"><span class="linenos">392</span></a>        <span class="n">x3d_save</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</span><span id="save-393"><a href="#save-393"><span class="linenos">393</span></a>    <span class="k">elif</span> <span class="n">extension</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;.obj&quot;</span><span class="p">:</span>
</span><span id="save-394"><a href="#save-394"><span class="linenos">394</span></a>        <span class="n">obj_save</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</span><span id="save-395"><a href="#save-395"><span class="linenos">395</span></a>    <span class="k">elif</span> <span class="n">extension</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;.off&quot;</span><span class="p">:</span>
</span><span id="save-396"><a href="#save-396"><span class="linenos">396</span></a>        <span class="n">off_save</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Save a Manifold, m, to an X3D/OBJ/OFF file.</p>
</div>


                </section>
                <section id="remove_caps">
                            <div class="attr function"><a class="headerlink" href="#remove_caps">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">remove_caps</span><span class="signature">(m, thresh=2.9)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="remove_caps-399"><a href="#remove_caps-399"><span class="linenos">399</span></a><span class="k">def</span> <span class="nf">remove_caps</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mf">2.9</span><span class="p">):</span>
</span><span id="remove_caps-400"><a href="#remove_caps-400"><span class="linenos">400</span></a>    <span class="sd">&quot;&quot;&quot; Remove caps from a manifold, m, consisting of only triangles. A cap is a</span>
</span><span id="remove_caps-401"><a href="#remove_caps-401"><span class="linenos">401</span></a><span class="sd">    triangle with two very small angles and an angle close to pi, however a cap</span>
</span><span id="remove_caps-402"><a href="#remove_caps-402"><span class="linenos">402</span></a><span class="sd">    does not necessarily have a very short edge. Set the ang_thresh to a value</span>
</span><span id="remove_caps-403"><a href="#remove_caps-403"><span class="linenos">403</span></a><span class="sd">    close to pi. The closer to pi the _less_ sensitive the cap removal. A cap is</span>
</span><span id="remove_caps-404"><a href="#remove_caps-404"><span class="linenos">404</span></a><span class="sd">    removed by flipping the (long) edge E opposite to the vertex V with the</span>
</span><span id="remove_caps-405"><a href="#remove_caps-405"><span class="linenos">405</span></a><span class="sd">    angle close to pi. However, the function is more complex. Read code and</span>
</span><span id="remove_caps-406"><a href="#remove_caps-406"><span class="linenos">406</span></a><span class="sd">    document more carefully !!! &quot;&quot;&quot;</span>
</span><span id="remove_caps-407"><a href="#remove_caps-407"><span class="linenos">407</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">remove_caps</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span><span class="n">thresh</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Remove caps from a manifold, m, consisting of only triangles. A cap is a
triangle with two very small angles and an angle close to pi, however a cap
does not necessarily have a very short edge. Set the ang_thresh to a value
close to pi. The closer to pi the _less_ sensitive the cap removal. A cap is
removed by flipping the (long) edge E opposite to the vertex V with the
angle close to pi. However, the function is more complex. Read code and
document more carefully !!!</p>
</div>


                </section>
                <section id="remove_needles">
                            <div class="attr function"><a class="headerlink" href="#remove_needles">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">remove_needles</span><span class="signature">(m, thresh=0.05, average_positions=False)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="remove_needles-409"><a href="#remove_needles-409"><span class="linenos">409</span></a><span class="k">def</span> <span class="nf">remove_needles</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">average_positions</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="remove_needles-410"><a href="#remove_needles-410"><span class="linenos">410</span></a>    <span class="sd">&quot;&quot;&quot;  Remove needles from a manifold, m, consisting of only triangles. A needle</span>
</span><span id="remove_needles-411"><a href="#remove_needles-411"><span class="linenos">411</span></a><span class="sd">    is a triangle with a single very short edge. It is moved by collapsing the</span>
</span><span id="remove_needles-412"><a href="#remove_needles-412"><span class="linenos">412</span></a><span class="sd">    short edge. The thresh parameter sets the length threshold (in terms of the average edge length</span>
</span><span id="remove_needles-413"><a href="#remove_needles-413"><span class="linenos">413</span></a><span class="sd">    in the mesh). If average_positions is true then the collapsed vertex is placed at the average position of the end points.&quot;&quot;&quot;</span>
</span><span id="remove_needles-414"><a href="#remove_needles-414"><span class="linenos">414</span></a>    <span class="n">abs_thresh</span> <span class="o">=</span> <span class="n">thresh</span> <span class="o">*</span> <span class="n">average_edge_length</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
</span><span id="remove_needles-415"><a href="#remove_needles-415"><span class="linenos">415</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">remove_needles</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span><span class="n">abs_thresh</span><span class="p">,</span> <span class="n">average_positions</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Remove needles from a manifold, m, consisting of only triangles. A needle
is a triangle with a single very short edge. It is moved by collapsing the
short edge. The thresh parameter sets the length threshold (in terms of the average edge length
in the mesh). If average_positions is true then the collapsed vertex is placed at the average position of the end points.</p>
</div>


                </section>
                <section id="close_holes">
                            <div class="attr function"><a class="headerlink" href="#close_holes">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">close_holes</span><span class="signature">(m, max_size=100)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="close_holes-417"><a href="#close_holes-417"><span class="linenos">417</span></a><span class="k">def</span> <span class="nf">close_holes</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">max_size</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
</span><span id="close_holes-418"><a href="#close_holes-418"><span class="linenos">418</span></a>    <span class="sd">&quot;&quot;&quot;  This function replaces holes in m by faces. It is really a simple function</span>
</span><span id="close_holes-419"><a href="#close_holes-419"><span class="linenos">419</span></a><span class="sd">    that just finds all loops of edges next to missing faces. &quot;&quot;&quot;</span>
</span><span id="close_holes-420"><a href="#close_holes-420"><span class="linenos">420</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">close_holes</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">max_size</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>This function replaces holes in m by faces. It is really a simple function
that just finds all loops of edges next to missing faces.</p>
</div>


                </section>
                <section id="flip_orientation">
                            <div class="attr function"><a class="headerlink" href="#flip_orientation">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">flip_orientation</span><span class="signature">(m)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="flip_orientation-422"><a href="#flip_orientation-422"><span class="linenos">422</span></a><span class="k">def</span> <span class="nf">flip_orientation</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
</span><span id="flip_orientation-423"><a href="#flip_orientation-423"><span class="linenos">423</span></a>    <span class="sd">&quot;&quot;&quot;  Flip the orientation of a mesh, m. After calling this function, normals</span>
</span><span id="flip_orientation-424"><a href="#flip_orientation-424"><span class="linenos">424</span></a><span class="sd">    will point the other way and clockwise becomes counter clockwise &quot;&quot;&quot;</span>
</span><span id="flip_orientation-425"><a href="#flip_orientation-425"><span class="linenos">425</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">flip_orientation</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Flip the orientation of a mesh, m. After calling this function, normals
will point the other way and clockwise becomes counter clockwise</p>
</div>


                </section>
                <section id="merge_coincident_boundary_vertices">
                            <div class="attr function"><a class="headerlink" href="#merge_coincident_boundary_vertices">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">merge_coincident_boundary_vertices</span><span class="signature">(m, rad=1e-30)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="merge_coincident_boundary_vertices-427"><a href="#merge_coincident_boundary_vertices-427"><span class="linenos">427</span></a><span class="k">def</span> <span class="nf">merge_coincident_boundary_vertices</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">rad</span> <span class="o">=</span> <span class="mf">1.0e-30</span><span class="p">):</span>
</span><span id="merge_coincident_boundary_vertices-428"><a href="#merge_coincident_boundary_vertices-428"><span class="linenos">428</span></a>    <span class="sd">&quot;&quot;&quot;  Merge vertices of m that are boundary vertices and coincident.</span>
</span><span id="merge_coincident_boundary_vertices-429"><a href="#merge_coincident_boundary_vertices-429"><span class="linenos">429</span></a><span class="sd">        However, if one belongs to the other&#39;s one ring or the one</span>
</span><span id="merge_coincident_boundary_vertices-430"><a href="#merge_coincident_boundary_vertices-430"><span class="linenos">430</span></a><span class="sd">        rings share a vertex, they will not be merged. &quot;&quot;&quot;</span>
</span><span id="merge_coincident_boundary_vertices-431"><a href="#merge_coincident_boundary_vertices-431"><span class="linenos">431</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">merge_coincident_boundary_vertices</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">rad</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Merge vertices of m that are boundary vertices and coincident.
However, if one belongs to the other's one ring or the one
rings share a vertex, they will not be merged.</p>
</div>


                </section>
                <section id="minimize_curvature">
                            <div class="attr function"><a class="headerlink" href="#minimize_curvature">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">minimize_curvature</span><span class="signature">(m, anneal=False)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="minimize_curvature-433"><a href="#minimize_curvature-433"><span class="linenos">433</span></a><span class="k">def</span> <span class="nf">minimize_curvature</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">anneal</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="minimize_curvature-434"><a href="#minimize_curvature-434"><span class="linenos">434</span></a>    <span class="sd">&quot;&quot;&quot; Minimizes mean curvature of m by flipping edges. Hence, no vertices are moved.</span>
</span><span id="minimize_curvature-435"><a href="#minimize_curvature-435"><span class="linenos">435</span></a><span class="sd">     This is really the same as dihedral angle minimization, except that we weight by edge length. &quot;&quot;&quot;</span>
</span><span id="minimize_curvature-436"><a href="#minimize_curvature-436"><span class="linenos">436</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">minimize_curvature</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">anneal</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Minimizes mean curvature of m by flipping edges. Hence, no vertices are moved.
This is really the same as dihedral angle minimization, except that we weight by edge length.</p>
</div>


                </section>
                <section id="minimize_dihedral_angle">
                            <div class="attr function"><a class="headerlink" href="#minimize_dihedral_angle">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">minimize_dihedral_angle</span><span class="signature">(m, max_iter=10000, anneal=False, alpha=False, gamma=4.0)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="minimize_dihedral_angle-438"><a href="#minimize_dihedral_angle-438"><span class="linenos">438</span></a><span class="k">def</span> <span class="nf">minimize_dihedral_angle</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">anneal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mf">4.0</span><span class="p">):</span>
</span><span id="minimize_dihedral_angle-439"><a href="#minimize_dihedral_angle-439"><span class="linenos">439</span></a>    <span class="sd">&quot;&quot;&quot; Minimizes dihedral angles in m by flipping edges.</span>
</span><span id="minimize_dihedral_angle-440"><a href="#minimize_dihedral_angle-440"><span class="linenos">440</span></a><span class="sd">        Arguments:</span>
</span><span id="minimize_dihedral_angle-441"><a href="#minimize_dihedral_angle-441"><span class="linenos">441</span></a><span class="sd">        max_iter is the maximum number of iterations for simulated annealing.</span>
</span><span id="minimize_dihedral_angle-442"><a href="#minimize_dihedral_angle-442"><span class="linenos">442</span></a><span class="sd">        anneal tells us the code whether to apply simulated annealing</span>
</span><span id="minimize_dihedral_angle-443"><a href="#minimize_dihedral_angle-443"><span class="linenos">443</span></a><span class="sd">        alpha=False means that we use the cosine of angles rather than true angles (faster)</span>
</span><span id="minimize_dihedral_angle-444"><a href="#minimize_dihedral_angle-444"><span class="linenos">444</span></a><span class="sd">        gamma is the power to which the angles are raised.&quot;&quot;&quot;</span>
</span><span id="minimize_dihedral_angle-445"><a href="#minimize_dihedral_angle-445"><span class="linenos">445</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">minimize_dihedral_angle</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">,</span> <span class="n">anneal</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span><span class="n">ct</span><span class="o">.</span><span class="n">c_double</span><span class="p">(</span><span class="n">gamma</span><span class="p">))</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Minimizes dihedral angles in m by flipping edges.
Arguments:
max_iter is the maximum number of iterations for simulated annealing.
anneal tells us the code whether to apply simulated annealing
alpha=False means that we use the cosine of angles rather than true angles (faster)
gamma is the power to which the angles are raised.</p>
</div>


                </section>
                <section id="maximize_min_angle">
                            <div class="attr function"><a class="headerlink" href="#maximize_min_angle">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">maximize_min_angle</span><span class="signature">(m, dihedral_thresh=0.95, anneal=False)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="maximize_min_angle-448"><a href="#maximize_min_angle-448"><span class="linenos">448</span></a><span class="k">def</span> <span class="nf">maximize_min_angle</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">dihedral_thresh</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span><span class="n">anneal</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="maximize_min_angle-449"><a href="#maximize_min_angle-449"><span class="linenos">449</span></a>    <span class="sd">&quot;&quot;&quot; Maximizes the minimum angle of triangles by flipping edges of m. Makes the mesh more Delaunay.&quot;&quot;&quot;</span>
</span><span id="maximize_min_angle-450"><a href="#maximize_min_angle-450"><span class="linenos">450</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">maximize_min_angle</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span><span class="n">dihedral_thresh</span><span class="p">,</span><span class="n">anneal</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Maximizes the minimum angle of triangles by flipping edges of m. Makes the mesh more Delaunay.</p>
</div>


                </section>
                <section id="optimize_valency">
                            <div class="attr function"><a class="headerlink" href="#optimize_valency">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">optimize_valency</span><span class="signature">(m, anneal=False)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="optimize_valency-452"><a href="#optimize_valency-452"><span class="linenos">452</span></a><span class="k">def</span> <span class="nf">optimize_valency</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">anneal</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="optimize_valency-453"><a href="#optimize_valency-453"><span class="linenos">453</span></a>    <span class="sd">&quot;&quot;&quot; Tries to achieve valence 6 internally and 4 along edges by flipping edges of m. &quot;&quot;&quot;</span>
</span><span id="optimize_valency-454"><a href="#optimize_valency-454"><span class="linenos">454</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">optimize_valency</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">anneal</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Tries to achieve valence 6 internally and 4 along edges by flipping edges of m.</p>
</div>


                </section>
                <section id="randomize_mesh">
                            <div class="attr function"><a class="headerlink" href="#randomize_mesh">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">randomize_mesh</span><span class="signature">(m, max_iter=1)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="randomize_mesh-456"><a href="#randomize_mesh-456"><span class="linenos">456</span></a><span class="k">def</span> <span class="nf">randomize_mesh</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
</span><span id="randomize_mesh-457"><a href="#randomize_mesh-457"><span class="linenos">457</span></a>    <span class="sd">&quot;&quot;&quot;  Make random flips in m. Useful for generating synthetic test cases. &quot;&quot;&quot;</span>
</span><span id="randomize_mesh-458"><a href="#randomize_mesh-458"><span class="linenos">458</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">randomize_mesh</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Make random flips in m. Useful for generating synthetic test cases.</p>
</div>


                </section>
                <section id="quadric_simplify">
                            <div class="attr function"><a class="headerlink" href="#quadric_simplify">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">quadric_simplify</span><span class="signature">(m, keep_fraction, singular_thresh=0.0001, optimal_positions=True)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="quadric_simplify-460"><a href="#quadric_simplify-460"><span class="linenos">460</span></a><span class="k">def</span> <span class="nf">quadric_simplify</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">keep_fraction</span><span class="p">,</span><span class="n">singular_thresh</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span><span class="n">optimal_positions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
</span><span id="quadric_simplify-461"><a href="#quadric_simplify-461"><span class="linenos">461</span></a>    <span class="sd">&quot;&quot;&quot; Garland Heckbert simplification of mesh m in our own implementation. keep_fraction</span>
</span><span id="quadric_simplify-462"><a href="#quadric_simplify-462"><span class="linenos">462</span></a><span class="sd">    is the fraction of vertices to retain. The singular_thresh defines how small</span>
</span><span id="quadric_simplify-463"><a href="#quadric_simplify-463"><span class="linenos">463</span></a><span class="sd">    singular values from the SVD we accept. It is relative to the greatest</span>
</span><span id="quadric_simplify-464"><a href="#quadric_simplify-464"><span class="linenos">464</span></a><span class="sd">    singular value. If optimal_positions is true, we reposition vertices.</span>
</span><span id="quadric_simplify-465"><a href="#quadric_simplify-465"><span class="linenos">465</span></a><span class="sd">    Otherwise the vertices are a subset of the old vertices.&quot;&quot;&quot;</span>
</span><span id="quadric_simplify-466"><a href="#quadric_simplify-466"><span class="linenos">466</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">quadric_simplify</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">keep_fraction</span><span class="p">,</span> <span class="n">singular_thresh</span><span class="p">,</span><span class="n">optimal_positions</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Garland Heckbert simplification of mesh m in our own implementation. keep_fraction
is the fraction of vertices to retain. The singular_thresh defines how small
singular values from the SVD we accept. It is relative to the greatest
singular value. If optimal_positions is true, we reposition vertices.
Otherwise the vertices are a subset of the old vertices.</p>
</div>


                </section>
                <section id="average_edge_length">
                            <div class="attr function"><a class="headerlink" href="#average_edge_length">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">average_edge_length</span><span class="signature">(m, max_iter=1)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="average_edge_length-468"><a href="#average_edge_length-468"><span class="linenos">468</span></a><span class="k">def</span> <span class="nf">average_edge_length</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
</span><span id="average_edge_length-469"><a href="#average_edge_length-469"><span class="linenos">469</span></a>    <span class="sd">&quot;&quot;&quot; Returns the average edge length of mesh m. &quot;&quot;&quot;</span>
</span><span id="average_edge_length-470"><a href="#average_edge_length-470"><span class="linenos">470</span></a>    <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">average_edge_length</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Returns the average edge length of mesh m.</p>
</div>


                </section>
                <section id="median_edge_length">
                            <div class="attr function"><a class="headerlink" href="#median_edge_length">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">median_edge_length</span><span class="signature">(m, max_iter=1)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="median_edge_length-472"><a href="#median_edge_length-472"><span class="linenos">472</span></a><span class="k">def</span> <span class="nf">median_edge_length</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
</span><span id="median_edge_length-473"><a href="#median_edge_length-473"><span class="linenos">473</span></a>    <span class="sd">&quot;&quot;&quot; Returns the median edge length of m&quot;&quot;&quot;</span>
</span><span id="median_edge_length-474"><a href="#median_edge_length-474"><span class="linenos">474</span></a>    <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">median_edge_length</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Returns the median edge length of m</p>
</div>


                </section>
                <section id="refine_edges">
                            <div class="attr function"><a class="headerlink" href="#refine_edges">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">refine_edges</span><span class="signature">(m, threshold)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="refine_edges-476"><a href="#refine_edges-476"><span class="linenos">476</span></a><span class="k">def</span> <span class="nf">refine_edges</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">threshold</span><span class="p">):</span>
</span><span id="refine_edges-477"><a href="#refine_edges-477"><span class="linenos">477</span></a>    <span class="sd">&quot;&quot;&quot; Split all edges in m which are longer</span>
</span><span id="refine_edges-478"><a href="#refine_edges-478"><span class="linenos">478</span></a><span class="sd">    than the threshold (second arg) length. A split edge</span>
</span><span id="refine_edges-479"><a href="#refine_edges-479"><span class="linenos">479</span></a><span class="sd">    results in a new vertex of valence two.&quot;&quot;&quot;</span>
</span><span id="refine_edges-480"><a href="#refine_edges-480"><span class="linenos">480</span></a>    <span class="k">return</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">refine_edges</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Split all edges in m which are longer
than the threshold (second arg) length. A split edge
results in a new vertex of valence two.</p>
</div>


                </section>
                <section id="cc_split">
                            <div class="attr function"><a class="headerlink" href="#cc_split">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">cc_split</span><span class="signature">(m)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="cc_split-482"><a href="#cc_split-482"><span class="linenos">482</span></a><span class="k">def</span> <span class="nf">cc_split</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
</span><span id="cc_split-483"><a href="#cc_split-483"><span class="linenos">483</span></a>    <span class="sd">&quot;&quot;&quot; Perform a Catmull-Clark split on m, i.e. a split where each face is divided</span>
</span><span id="cc_split-484"><a href="#cc_split-484"><span class="linenos">484</span></a><span class="sd">    into new quadrilateral faces formed by connecting a corner with a point on</span>
</span><span id="cc_split-485"><a href="#cc_split-485"><span class="linenos">485</span></a><span class="sd">    each incident edge and a point at the centre of the face.&quot;&quot;&quot;</span>
</span><span id="cc_split-486"><a href="#cc_split-486"><span class="linenos">486</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">cc_split</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Perform a Catmull-Clark split on m, i.e. a split where each face is divided
into new quadrilateral faces formed by connecting a corner with a point on
each incident edge and a point at the centre of the face.</p>
</div>


                </section>
                <section id="loop_split">
                            <div class="attr function"><a class="headerlink" href="#loop_split">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">loop_split</span><span class="signature">(m)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="loop_split-488"><a href="#loop_split-488"><span class="linenos">488</span></a><span class="k">def</span> <span class="nf">loop_split</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
</span><span id="loop_split-489"><a href="#loop_split-489"><span class="linenos">489</span></a>    <span class="sd">&quot;&quot;&quot; Perform a loop split on m where each edge is divided into two segments, and</span>
</span><span id="loop_split-490"><a href="#loop_split-490"><span class="linenos">490</span></a><span class="sd">    four new triangles are created for each original triangle. &quot;&quot;&quot;</span>
</span><span id="loop_split-491"><a href="#loop_split-491"><span class="linenos">491</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">loop_split</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Perform a loop split on m where each edge is divided into two segments, and
four new triangles are created for each original triangle.</p>
</div>


                </section>
                <section id="root3_subdivide">
                            <div class="attr function"><a class="headerlink" href="#root3_subdivide">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">root3_subdivide</span><span class="signature">(m)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="root3_subdivide-493"><a href="#root3_subdivide-493"><span class="linenos">493</span></a><span class="k">def</span> <span class="nf">root3_subdivide</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
</span><span id="root3_subdivide-494"><a href="#root3_subdivide-494"><span class="linenos">494</span></a>    <span class="sd">&quot;&quot;&quot; Leif Kobbelt&#39;s subdivision scheme applied to m. A vertex is placed in the</span>
</span><span id="root3_subdivide-495"><a href="#root3_subdivide-495"><span class="linenos">495</span></a><span class="sd">    center of each face and all old edges are flipped. &quot;&quot;&quot;</span>
</span><span id="root3_subdivide-496"><a href="#root3_subdivide-496"><span class="linenos">496</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">root3_subdivide</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Leif Kobbelt's subdivision scheme applied to m. A vertex is placed in the
center of each face and all old edges are flipped.</p>
</div>


                </section>
                <section id="rootCC_subdivide">
                            <div class="attr function"><a class="headerlink" href="#rootCC_subdivide">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">rootCC_subdivide</span><span class="signature">(m)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="rootCC_subdivide-498"><a href="#rootCC_subdivide-498"><span class="linenos">498</span></a><span class="k">def</span> <span class="nf">rootCC_subdivide</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
</span><span id="rootCC_subdivide-499"><a href="#rootCC_subdivide-499"><span class="linenos">499</span></a>    <span class="sd">&quot;&quot;&quot; This subdivision scheme creates a vertex inside each original (quad) face of m,</span>
</span><span id="rootCC_subdivide-500"><a href="#rootCC_subdivide-500"><span class="linenos">500</span></a><span class="sd">    producing four triangles. Triangles sharing an old edge are then merged.</span>
</span><span id="rootCC_subdivide-501"><a href="#rootCC_subdivide-501"><span class="linenos">501</span></a><span class="sd">    Two steps produce something similar to Catmull-Clark. &quot;&quot;&quot;</span>
</span><span id="rootCC_subdivide-502"><a href="#rootCC_subdivide-502"><span class="linenos">502</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">rootCC_subdivide</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>This subdivision scheme creates a vertex inside each original (quad) face of m,
producing four triangles. Triangles sharing an old edge are then merged.
Two steps produce something similar to Catmull-Clark.</p>
</div>


                </section>
                <section id="butterfly_subdivide">
                            <div class="attr function"><a class="headerlink" href="#butterfly_subdivide">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">butterfly_subdivide</span><span class="signature">(m)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="butterfly_subdivide-504"><a href="#butterfly_subdivide-504"><span class="linenos">504</span></a><span class="k">def</span> <span class="nf">butterfly_subdivide</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
</span><span id="butterfly_subdivide-505"><a href="#butterfly_subdivide-505"><span class="linenos">505</span></a>    <span class="sd">&quot;&quot;&quot; Butterfly subidiviosn on m. An interpolatory scheme. Creates the same connectivity as Loop. &quot;&quot;&quot;</span>
</span><span id="butterfly_subdivide-506"><a href="#butterfly_subdivide-506"><span class="linenos">506</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">butterfly_subdivide</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Butterfly subidiviosn on m. An interpolatory scheme. Creates the same connectivity as Loop.</p>
</div>


                </section>
                <section id="cc_smooth">
                            <div class="attr function"><a class="headerlink" href="#cc_smooth">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">cc_smooth</span><span class="signature">(m)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="cc_smooth-508"><a href="#cc_smooth-508"><span class="linenos">508</span></a><span class="k">def</span> <span class="nf">cc_smooth</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
</span><span id="cc_smooth-509"><a href="#cc_smooth-509"><span class="linenos">509</span></a>    <span class="sd">&quot;&quot;&quot; If called after cc_split, this function completes a step of Catmull-Clark</span>
</span><span id="cc_smooth-510"><a href="#cc_smooth-510"><span class="linenos">510</span></a><span class="sd">    subdivision of m.&quot;&quot;&quot;</span>
</span><span id="cc_smooth-511"><a href="#cc_smooth-511"><span class="linenos">511</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">cc_smooth</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>If called after cc_split, this function completes a step of Catmull-Clark
subdivision of m.</p>
</div>


                </section>
                <section id="loop_smooth">
                            <div class="attr function"><a class="headerlink" href="#loop_smooth">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">loop_smooth</span><span class="signature">(m)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="loop_smooth-513"><a href="#loop_smooth-513"><span class="linenos">513</span></a><span class="k">def</span> <span class="nf">loop_smooth</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
</span><span id="loop_smooth-514"><a href="#loop_smooth-514"><span class="linenos">514</span></a>    <span class="sd">&quot;&quot;&quot; If called after Loop split, this function completes a step of Loop</span>
</span><span id="loop_smooth-515"><a href="#loop_smooth-515"><span class="linenos">515</span></a><span class="sd">    subdivision of m. &quot;&quot;&quot;</span>
</span><span id="loop_smooth-516"><a href="#loop_smooth-516"><span class="linenos">516</span></a>    <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">loop_smooth</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>If called after Loop split, this function completes a step of Loop
subdivision of m.</p>
</div>


                </section>
                <section id="triangulate">
                            <div class="attr function"><a class="headerlink" href="#triangulate">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">triangulate</span><span class="signature">(m, clip_ear=True)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="triangulate-518"><a href="#triangulate-518"><span class="linenos">518</span></a><span class="k">def</span> <span class="nf">triangulate</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">clip_ear</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
</span><span id="triangulate-519"><a href="#triangulate-519"><span class="linenos">519</span></a>    <span class="sd">&quot;&quot;&quot; Turn a general polygonal mesh, m, into a triangle mesh by repeatedly</span>
</span><span id="triangulate-520"><a href="#triangulate-520"><span class="linenos">520</span></a><span class="sd">        splitting a polygon into smaller polygons. &quot;&quot;&quot;</span>
</span><span id="triangulate-521"><a href="#triangulate-521"><span class="linenos">521</span></a>    <span class="k">if</span> <span class="n">clip_ear</span><span class="p">:</span>
</span><span id="triangulate-522"><a href="#triangulate-522"><span class="linenos">522</span></a>        <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">ear_clip_triangulate</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="triangulate-523"><a href="#triangulate-523"><span class="linenos">523</span></a>    <span class="k">else</span><span class="p">:</span>
</span><span id="triangulate-524"><a href="#triangulate-524"><span class="linenos">524</span></a>        <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">shortest_edge_triangulate</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Turn a general polygonal mesh, m, into a triangle mesh by repeatedly
splitting a polygon into smaller polygons.</p>
</div>


                </section>
                <section id="MeshDistance">
                                <div class="attr class">
        <a class="headerlink" href="#MeshDistance">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">MeshDistance</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="MeshDistance-527"><a href="#MeshDistance-527"><span class="linenos">527</span></a><span class="k">class</span> <span class="nc">MeshDistance</span><span class="p">:</span>
</span><span id="MeshDistance-528"><a href="#MeshDistance-528"><span class="linenos">528</span></a>    <span class="sd">&quot;&quot;&quot; This class allows you to compute the distance from any point in space to</span>
</span><span id="MeshDistance-529"><a href="#MeshDistance-529"><span class="linenos">529</span></a><span class="sd">    a Manifold (which must be triangulated). The constructor creates an instance</span>
</span><span id="MeshDistance-530"><a href="#MeshDistance-530"><span class="linenos">530</span></a><span class="sd">    based on a specific mesh, and the signed_distance function computes the actual distance. &quot;&quot;&quot;</span>
</span><span id="MeshDistance-531"><a href="#MeshDistance-531"><span class="linenos">531</span></a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">m</span><span class="p">):</span>
</span><span id="MeshDistance-532"><a href="#MeshDistance-532"><span class="linenos">532</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">obj</span> <span class="o">=</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">MeshDistance_new</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="MeshDistance-533"><a href="#MeshDistance-533"><span class="linenos">533</span></a>    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="MeshDistance-534"><a href="#MeshDistance-534"><span class="linenos">534</span></a>        <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">MeshDistance_delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span><span id="MeshDistance-535"><a href="#MeshDistance-535"><span class="linenos">535</span></a>    <span class="k">def</span> <span class="nf">signed_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pts</span><span class="p">,</span><span class="n">upper</span><span class="o">=</span><span class="mf">1e30</span><span class="p">):</span>
</span><span id="MeshDistance-536"><a href="#MeshDistance-536"><span class="linenos">536</span></a>        <span class="sd">&quot;&quot;&quot; Compute the signed distance from each point in pts to the mesh stored in </span>
</span><span id="MeshDistance-537"><a href="#MeshDistance-537"><span class="linenos">537</span></a><span class="sd">        this class instance. pts should be convertible to a length N&gt;=1 array of 3D </span>
</span><span id="MeshDistance-538"><a href="#MeshDistance-538"><span class="linenos">538</span></a><span class="sd">        points. The function returns an array of N distance values with a single distance </span>
</span><span id="MeshDistance-539"><a href="#MeshDistance-539"><span class="linenos">539</span></a><span class="sd">        for each point. The distance corresponding to a point is positive if the point </span>
</span><span id="MeshDistance-540"><a href="#MeshDistance-540"><span class="linenos">540</span></a><span class="sd">        is outside and negative if inside. The upper parameter can be used to threshold </span>
</span><span id="MeshDistance-541"><a href="#MeshDistance-541"><span class="linenos">541</span></a><span class="sd">        how far away the distance is of interest. &quot;&quot;&quot;</span>
</span><span id="MeshDistance-542"><a href="#MeshDistance-542"><span class="linenos">542</span></a>        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">ct</span><span class="o">.</span><span class="n">c_float</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
</span><span id="MeshDistance-543"><a href="#MeshDistance-543"><span class="linenos">543</span></a>        <span class="n">n</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span><span id="MeshDistance-544"><a href="#MeshDistance-544"><span class="linenos">544</span></a>        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ct</span><span class="o">.</span><span class="n">c_float</span><span class="p">)</span>
</span><span id="MeshDistance-545"><a href="#MeshDistance-545"><span class="linenos">545</span></a>        <span class="n">p_ct</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">c_float</span><span class="p">))</span>
</span><span id="MeshDistance-546"><a href="#MeshDistance-546"><span class="linenos">546</span></a>        <span class="n">d_ct</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">c_float</span><span class="p">))</span>
</span><span id="MeshDistance-547"><a href="#MeshDistance-547"><span class="linenos">547</span></a>        <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">MeshDistance_signed_distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">p_ct</span><span class="p">,</span><span class="n">d_ct</span><span class="p">,</span><span class="n">upper</span><span class="p">)</span>
</span><span id="MeshDistance-548"><a href="#MeshDistance-548"><span class="linenos">548</span></a>        <span class="k">return</span> <span class="n">d</span>
</span><span id="MeshDistance-549"><a href="#MeshDistance-549"><span class="linenos">549</span></a>    <span class="k">def</span> <span class="nf">ray_inside_test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pts</span><span class="p">,</span><span class="n">no_rays</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
</span><span id="MeshDistance-550"><a href="#MeshDistance-550"><span class="linenos">550</span></a>        <span class="sd">&quot;&quot;&quot;Check whether each point in pts is inside or outside the stored mesh by </span>
</span><span id="MeshDistance-551"><a href="#MeshDistance-551"><span class="linenos">551</span></a><span class="sd">        casting rays. pts should be convertible to a length N&gt;=1 array of 3D points.</span>
</span><span id="MeshDistance-552"><a href="#MeshDistance-552"><span class="linenos">552</span></a><span class="sd">        Effectively, this is the sign of the distance. In some cases casting (multiple)</span>
</span><span id="MeshDistance-553"><a href="#MeshDistance-553"><span class="linenos">553</span></a><span class="sd">        ray is more robust than using the sign computed locally. Returns an array of </span>
</span><span id="MeshDistance-554"><a href="#MeshDistance-554"><span class="linenos">554</span></a><span class="sd">        N integers which are either 1 or 0 depending on whether the corresponding point</span>
</span><span id="MeshDistance-555"><a href="#MeshDistance-555"><span class="linenos">555</span></a><span class="sd">        is inside (1) or outside (0). &quot;&quot;&quot;</span>
</span><span id="MeshDistance-556"><a href="#MeshDistance-556"><span class="linenos">556</span></a>        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">ct</span><span class="o">.</span><span class="n">c_float</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
</span><span id="MeshDistance-557"><a href="#MeshDistance-557"><span class="linenos">557</span></a>        <span class="n">n</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span><span id="MeshDistance-558"><a href="#MeshDistance-558"><span class="linenos">558</span></a>        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ct</span><span class="o">.</span><span class="n">c_int</span><span class="p">)</span>
</span><span id="MeshDistance-559"><a href="#MeshDistance-559"><span class="linenos">559</span></a>        <span class="n">p_ct</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">c_float</span><span class="p">))</span>
</span><span id="MeshDistance-560"><a href="#MeshDistance-560"><span class="linenos">560</span></a>        <span class="n">s_ct</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">c_int</span><span class="p">))</span>
</span><span id="MeshDistance-561"><a href="#MeshDistance-561"><span class="linenos">561</span></a>        <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">MeshDistance_ray_inside_test</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">p_ct</span><span class="p">,</span><span class="n">s_ct</span><span class="p">,</span><span class="n">no_rays</span><span class="p">)</span>
</span><span id="MeshDistance-562"><a href="#MeshDistance-562"><span class="linenos">562</span></a>        <span class="k">return</span> <span class="n">s</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>This class allows you to compute the distance from any point in space to
a Manifold (which must be triangulated). The constructor creates an instance
based on a specific mesh, and the signed_distance function computes the actual distance.</p>
</div>


                            <div id="MeshDistance.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#MeshDistance.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">MeshDistance</span><span class="signature">(m)</span>
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="MeshDistance.__init__-531"><a href="#MeshDistance.__init__-531"><span class="linenos">531</span></a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">m</span><span class="p">):</span>
</span><span id="MeshDistance.__init__-532"><a href="#MeshDistance.__init__-532"><span class="linenos">532</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">obj</span> <span class="o">=</span> <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">MeshDistance_new</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
</span></pre></div>

        </details>

    

                            </div>
                            <div id="MeshDistance.signed_distance" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#MeshDistance.signed_distance">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">signed_distance</span><span class="signature">(self, pts, upper=1e+30)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="MeshDistance.signed_distance-535"><a href="#MeshDistance.signed_distance-535"><span class="linenos">535</span></a>    <span class="k">def</span> <span class="nf">signed_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pts</span><span class="p">,</span><span class="n">upper</span><span class="o">=</span><span class="mf">1e30</span><span class="p">):</span>
</span><span id="MeshDistance.signed_distance-536"><a href="#MeshDistance.signed_distance-536"><span class="linenos">536</span></a>        <span class="sd">&quot;&quot;&quot; Compute the signed distance from each point in pts to the mesh stored in </span>
</span><span id="MeshDistance.signed_distance-537"><a href="#MeshDistance.signed_distance-537"><span class="linenos">537</span></a><span class="sd">        this class instance. pts should be convertible to a length N&gt;=1 array of 3D </span>
</span><span id="MeshDistance.signed_distance-538"><a href="#MeshDistance.signed_distance-538"><span class="linenos">538</span></a><span class="sd">        points. The function returns an array of N distance values with a single distance </span>
</span><span id="MeshDistance.signed_distance-539"><a href="#MeshDistance.signed_distance-539"><span class="linenos">539</span></a><span class="sd">        for each point. The distance corresponding to a point is positive if the point </span>
</span><span id="MeshDistance.signed_distance-540"><a href="#MeshDistance.signed_distance-540"><span class="linenos">540</span></a><span class="sd">        is outside and negative if inside. The upper parameter can be used to threshold </span>
</span><span id="MeshDistance.signed_distance-541"><a href="#MeshDistance.signed_distance-541"><span class="linenos">541</span></a><span class="sd">        how far away the distance is of interest. &quot;&quot;&quot;</span>
</span><span id="MeshDistance.signed_distance-542"><a href="#MeshDistance.signed_distance-542"><span class="linenos">542</span></a>        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">ct</span><span class="o">.</span><span class="n">c_float</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
</span><span id="MeshDistance.signed_distance-543"><a href="#MeshDistance.signed_distance-543"><span class="linenos">543</span></a>        <span class="n">n</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span><span id="MeshDistance.signed_distance-544"><a href="#MeshDistance.signed_distance-544"><span class="linenos">544</span></a>        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ct</span><span class="o">.</span><span class="n">c_float</span><span class="p">)</span>
</span><span id="MeshDistance.signed_distance-545"><a href="#MeshDistance.signed_distance-545"><span class="linenos">545</span></a>        <span class="n">p_ct</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">c_float</span><span class="p">))</span>
</span><span id="MeshDistance.signed_distance-546"><a href="#MeshDistance.signed_distance-546"><span class="linenos">546</span></a>        <span class="n">d_ct</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">c_float</span><span class="p">))</span>
</span><span id="MeshDistance.signed_distance-547"><a href="#MeshDistance.signed_distance-547"><span class="linenos">547</span></a>        <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">MeshDistance_signed_distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">p_ct</span><span class="p">,</span><span class="n">d_ct</span><span class="p">,</span><span class="n">upper</span><span class="p">)</span>
</span><span id="MeshDistance.signed_distance-548"><a href="#MeshDistance.signed_distance-548"><span class="linenos">548</span></a>        <span class="k">return</span> <span class="n">d</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Compute the signed distance from each point in pts to the mesh stored in 
this class instance. pts should be convertible to a length N>=1 array of 3D 
points. The function returns an array of N distance values with a single distance 
for each point. The distance corresponding to a point is positive if the point 
is outside and negative if inside. The upper parameter can be used to threshold 
how far away the distance is of interest.</p>
</div>


                            </div>
                            <div id="MeshDistance.ray_inside_test" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#MeshDistance.ray_inside_test">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ray_inside_test</span><span class="signature">(self, pts, no_rays=3)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span id="MeshDistance.ray_inside_test-549"><a href="#MeshDistance.ray_inside_test-549"><span class="linenos">549</span></a>    <span class="k">def</span> <span class="nf">ray_inside_test</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pts</span><span class="p">,</span><span class="n">no_rays</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
</span><span id="MeshDistance.ray_inside_test-550"><a href="#MeshDistance.ray_inside_test-550"><span class="linenos">550</span></a>        <span class="sd">&quot;&quot;&quot;Check whether each point in pts is inside or outside the stored mesh by </span>
</span><span id="MeshDistance.ray_inside_test-551"><a href="#MeshDistance.ray_inside_test-551"><span class="linenos">551</span></a><span class="sd">        casting rays. pts should be convertible to a length N&gt;=1 array of 3D points.</span>
</span><span id="MeshDistance.ray_inside_test-552"><a href="#MeshDistance.ray_inside_test-552"><span class="linenos">552</span></a><span class="sd">        Effectively, this is the sign of the distance. In some cases casting (multiple)</span>
</span><span id="MeshDistance.ray_inside_test-553"><a href="#MeshDistance.ray_inside_test-553"><span class="linenos">553</span></a><span class="sd">        ray is more robust than using the sign computed locally. Returns an array of </span>
</span><span id="MeshDistance.ray_inside_test-554"><a href="#MeshDistance.ray_inside_test-554"><span class="linenos">554</span></a><span class="sd">        N integers which are either 1 or 0 depending on whether the corresponding point</span>
</span><span id="MeshDistance.ray_inside_test-555"><a href="#MeshDistance.ray_inside_test-555"><span class="linenos">555</span></a><span class="sd">        is inside (1) or outside (0). &quot;&quot;&quot;</span>
</span><span id="MeshDistance.ray_inside_test-556"><a href="#MeshDistance.ray_inside_test-556"><span class="linenos">556</span></a>        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">ct</span><span class="o">.</span><span class="n">c_float</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
</span><span id="MeshDistance.ray_inside_test-557"><a href="#MeshDistance.ray_inside_test-557"><span class="linenos">557</span></a>        <span class="n">n</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span><span id="MeshDistance.ray_inside_test-558"><a href="#MeshDistance.ray_inside_test-558"><span class="linenos">558</span></a>        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ct</span><span class="o">.</span><span class="n">c_int</span><span class="p">)</span>
</span><span id="MeshDistance.ray_inside_test-559"><a href="#MeshDistance.ray_inside_test-559"><span class="linenos">559</span></a>        <span class="n">p_ct</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">c_float</span><span class="p">))</span>
</span><span id="MeshDistance.ray_inside_test-560"><a href="#MeshDistance.ray_inside_test-560"><span class="linenos">560</span></a>        <span class="n">s_ct</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ct</span><span class="o">.</span><span class="n">c_int</span><span class="p">))</span>
</span><span id="MeshDistance.ray_inside_test-561"><a href="#MeshDistance.ray_inside_test-561"><span class="linenos">561</span></a>        <span class="n">lib_py_gel</span><span class="o">.</span><span class="n">MeshDistance_ray_inside_test</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">p_ct</span><span class="p">,</span><span class="n">s_ct</span><span class="p">,</span><span class="n">no_rays</span><span class="p">)</span>
</span><span id="MeshDistance.ray_inside_test-562"><a href="#MeshDistance.ray_inside_test-562"><span class="linenos">562</span></a>        <span class="k">return</span> <span class="n">s</span>
</span></pre></div>

        </details>

            <div class="docstring"><p>Check whether each point in pts is inside or outside the stored mesh by 
casting rays. pts should be convertible to a length N>=1 array of 3D points.
Effectively, this is the sign of the distance. In some cases casting (multiple)
ray is more robust than using the sign computed locally. Returns an array of 
N integers which are either 1 or 0 depending on whether the corresponding point
is inside (1) or outside (0).</p>
</div>


                            </div>
                </section>
    </main>
<script>
    function escapeHTML(html) {
        return document.createElement('div').appendChild(document.createTextNode(html)).parentNode.innerHTML;
    }

    const originalContent = document.querySelector("main.pdoc");
    let currentContent = originalContent;

    function setContent(innerHTML) {
        let elem;
        if (innerHTML) {
            elem = document.createElement("main");
            elem.classList.add("pdoc");
            elem.innerHTML = innerHTML;
        } else {
            elem = originalContent;
        }
        if (currentContent !== elem) {
            currentContent.replaceWith(elem);
            currentContent = elem;
        }
    }

    function getSearchTerm() {
        return (new URL(window.location)).searchParams.get("search");
    }

    const searchBox = document.querySelector(".pdoc input[type=search]");
    searchBox.addEventListener("input", function () {
        let url = new URL(window.location);
        if (searchBox.value.trim()) {
            url.hash = "";
            url.searchParams.set("search", searchBox.value);
        } else {
            url.searchParams.delete("search");
        }
        history.replaceState("", "", url.toString());
        onInput();
    });
    window.addEventListener("popstate", onInput);


    let search, searchErr;

    async function initialize() {
        try {
            search = await new Promise((resolve, reject) => {
                const script = document.createElement("script");
                script.type = "text/javascript";
                script.async = true;
                script.onload = () => resolve(window.pdocSearch);
                script.onerror = (e) => reject(e);
                script.src = "../search.js";
                document.getElementsByTagName("head")[0].appendChild(script);
            });
        } catch (e) {
            console.error("Cannot fetch pdoc search index");
            searchErr = "Cannot fetch search index.";
        }
        onInput();

        document.querySelector("nav.pdoc").addEventListener("click", e => {
            if (e.target.hash) {
                searchBox.value = "";
                searchBox.dispatchEvent(new Event("input"));
            }
        });
    }

    function onInput() {
        setContent((() => {
            const term = getSearchTerm();
            if (!term) {
                return null
            }
            if (searchErr) {
                return `<h3>Error: ${searchErr}</h3>`
            }
            if (!search) {
                return "<h3>Searching...</h3>"
            }

            window.scrollTo({top: 0, left: 0, behavior: 'auto'});

            const results = search(term);

            let html;
            if (results.length === 0) {
                html = `No search results for '${escapeHTML(term)}'.`
            } else {
                html = `<h4>${results.length} search result${results.length > 1 ? "s" : ""} for '${escapeHTML(term)}'.</h4>`;
            }
            for (let result of results.slice(0, 10)) {
                let doc = result.doc;
                let url = `../${doc.modulename.replaceAll(".", "/")}.html`;
                if (doc.qualname) {
                    url += `#${doc.qualname}`;
                }

                let heading;
                switch (result.doc.type) {
                    case "function":
                        heading = `<span class="def">${doc.funcdef}</span> <span class="name">${doc.fullname}</span><span class="signature">${doc.signature}:</span>`;
                        break;
                    case "class":
                        heading = `<span class="def">class</span> <span class="name">${doc.fullname}</span>`;
                        if (doc.bases)
                            heading += `<wbr>(<span class="base">${doc.bases}</span>)`;
                        heading += `:`;
                        break;
                    case "variable":
                        heading = `<span class="name">${doc.fullname}</span>`;
                        if (doc.annotation)
                            heading += `<span class="annotation">${doc.annotation}</span>`;
                        if (doc.default_value)
                            heading += `<span class="default_value">${doc.default_value}</span>`;
                        break;
                    default:
                        heading = `<span class="name">${doc.fullname}</span>`;
                        break;
                }
                html += `
                        <section class="search-result">
                        <a href="${url}" class="attr ${doc.type}">${heading}</a>
                        <div class="docstring">${doc.doc}</div>
                        </section>
                    `;

            }
            return html;
        })());
    }

    if (getSearchTerm()) {
        initialize();
        searchBox.value = getSearchTerm();
        onInput();
    } else {
        searchBox.addEventListener("focus", initialize, {once: true});
    }

    searchBox.addEventListener("keydown", e => {
        if (["ArrowDown", "ArrowUp", "Enter"].includes(e.key)) {
            let focused = currentContent.querySelector(".search-result.focused");
            if (!focused) {
                currentContent.querySelector(".search-result").classList.add("focused");
            } else if (
                e.key === "ArrowDown"
                && focused.nextElementSibling
                && focused.nextElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.nextElementSibling.classList.add("focused");
                focused.nextElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "ArrowUp"
                && focused.previousElementSibling
                && focused.previousElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.previousElementSibling.classList.add("focused");
                focused.previousElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "Enter"
            ) {
                focused.querySelector("a").click();
            }
        }
    });
</script></body>
</html>