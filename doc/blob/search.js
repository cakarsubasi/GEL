window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "pygel3d", "modulename": "pygel3d", "type": "module", "doc": "<p>PyGEL is a collection of classes and functions that expose features in the\nGEL library. The primary purpose of PyGEL (and GEL) is to be useful for geometry\nprocessing tasks. Especially tasks that involve 3D polygonal meshes, but there is\nalso a graph component useful e.g. for skeletonization. The PyGEL package is called\npygel3d and it contains five modules:</p>\n\n<p>hmesh provides Manifold which is a class that represents polygonal meshes using the\nhalfedge representation. hmesh also provides a slew of functions for manipulating\npolygonal meshes and the MeshDistance class which makes it simple to compute the\ndistance to a triangle mesh.</p>\n\n<p>graph contains the Graph class which is used for graphs: i.e. collections of\nvertices (in 3D) connected by edges. Unlike a Manifold, a Graph does not have to\nrepresent a surface. There are also some associated functions which may be useful:\nin particular, there is the LS_skeletonize function which computes a curve skeleton\nfrom a Graph and returns the result as a new Graph.</p>\n\n<p>gl_display provides the Viewer class which makes it simple to visualize meshes and\ngraphs.</p>\n\n<p>jupyter_display makes it easy to use PyGEL in the context of a Jupyter Notebook.\nThis module contains a function that allows you to create a widget for interactively\nvisualizing a mesh or a graph in a Notebook. The feature is based on the Plotly\nlibrary and it is possible to export the resulting notebooks to HTML while preserving\nthe interactive 3D graphics in the notebook.</p>\n\n<p>spatial contains the I3DTree class which is simply a kD-tree specialized for mapping\n3D points to integers - typically indices. Of course, scipy.spatial has a more\ngeneric class, so this is perhaps not the most important part of PyGEL.</p>\n"}, {"fullname": "pygel3d.gl_display", "modulename": "pygel3d.gl_display", "type": "module", "doc": "<p>This modules provides an OpenGL based viewer for graphs and meshes</p>\n"}, {"fullname": "pygel3d.gl_display.Viewer", "modulename": "pygel3d.gl_display", "qualname": "Viewer", "type": "class", "doc": "<p>An OpenGL Viewer for Manifolds and Graphs. Having created an instance of this\nclass, call display to show a mesh or a graph. The display function is flexible,\nallowing several types of interactive visualization. Each instance of this\nclass corresponds to a single window, but you can have several\nGLManifoldViewer and hence also several windows showing different\nvisualizations.</p>\n"}, {"fullname": "pygel3d.gl_display.Viewer.__init__", "modulename": "pygel3d.gl_display", "qualname": "Viewer.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pygel3d.gl_display.Viewer.display", "modulename": "pygel3d.gl_display", "qualname": "Viewer.display", "type": "function", "doc": "<p>Display a mesh</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<ul>\n<li>m : the Manifold mesh or Graph we want to show.</li>\n<li>g : the Graph we want to show. If you only want to show a graph, you\ncan simply pass the graph as m, so the g argument is relevant only if\nyou need to show both a Manifold _and_ a Graph.</li>\n<li>mode : a single character that determines how the mesh is visualized:\n'w' - wireframe,\n'i' - isophote,\n'g' - glazed (try it and see),\n's' - scalar field,\n'l' - line field,\n'n' - normal.\n'x' - xray or ghost rendering. Useful to show Manifold on top of Graph</li>\n<li>smooth : if True we use vertex normals. Otherwise, face normals.</li>\n<li>bg_col : background color.</li>\n<li>data : per vertex data for visualization. scalar or vector field.</li>\n<li>reset_view : if False view is as left in the previous display call. If\nTrue, the view is reset to the default.</li>\n<li>once : if True we immediately exit the event loop and return. However,\nthe window stays and if the event loop is called from this or any\nother viewer, the window will still be responsive.</li>\n</ul>\n\n<h2 id=\"interactive-controls\">Interactive controls:</h2>\n\n<p>When a viewer window is displayed on the screen, you can naviagate with\nthe mouse: Left mouse button rotates, right mouse button is used for\nzooming and (if shift is pressed) for panning. If you hold control, any\nmouse button will pick a point on the 3D model. Up to 19 of these points\nhave unique colors.  If you pick an already placed annotation point it\nwill be removed and can now be placed elsewhere. Hit space bar to clear\nthe annotation points. Hitting ESC exits the event loop causing control\nto return to the script.</p>\n", "signature": "(\n    self,\n    m,\n    g=None,\n    mode='w',\n    smooth=True,\n    bg_col=[0.3, 0.3, 0.3],\n    data=None,\n    reset_view=False,\n    once=False\n)", "funcdef": "def"}, {"fullname": "pygel3d.gl_display.Viewer.annotation_points", "modulename": "pygel3d.gl_display", "qualname": "Viewer.annotation_points", "type": "function", "doc": "<p>Retrieve a vector of annotation points. This vector is not a copy,\nso any changes made to the points will be reflected in the viewer.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pygel3d.gl_display.Viewer.set_annotation_points", "modulename": "pygel3d.gl_display", "qualname": "Viewer.set_annotation_points", "type": "function", "doc": "<p></p>\n", "signature": "(self, pts)", "funcdef": "def"}, {"fullname": "pygel3d.gl_display.Viewer.event_loop", "modulename": "pygel3d.gl_display", "qualname": "Viewer.event_loop", "type": "function", "doc": "<p>Explicit call to the event loop. This function enters the event loop.\nCall it if you want to turn on interactivity in the currently displayed\nwindow.</p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "pygel3d.graph", "modulename": "pygel3d.graph", "type": "module", "doc": "<p>This module provides a Graph class and functionality for skeletonization using graphs.</p>\n"}, {"fullname": "pygel3d.graph.Graph", "modulename": "pygel3d.graph", "qualname": "Graph", "type": "class", "doc": "<p>This class is for representing graphs embedded in 3D. The class does not in\nitself come with many features: it contains methods for creating, accessing, and\nhousekeeping. When vertices are used as parameters in the functions below, we usually\nuse the parameter name n (for node). n is simply an index (i.e. an integer) that\nrefers to a node (aka vertex).</p>\n"}, {"fullname": "pygel3d.graph.Graph.__init__", "modulename": "pygel3d.graph", "qualname": "Graph.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, orig=None)", "funcdef": "def"}, {"fullname": "pygel3d.graph.Graph.clear", "modulename": "pygel3d.graph", "qualname": "Graph.clear", "type": "function", "doc": "<p>Clear the graph.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pygel3d.graph.Graph.cleanup", "modulename": "pygel3d.graph", "qualname": "Graph.cleanup", "type": "function", "doc": "<p>Cleanup reorders the graph nodes such that there is no\ngap in the index range.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pygel3d.graph.Graph.nodes", "modulename": "pygel3d.graph", "qualname": "Graph.nodes", "type": "function", "doc": "<p>Get all nodes as an iterable range</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pygel3d.graph.Graph.neighbors", "modulename": "pygel3d.graph", "qualname": "Graph.neighbors", "type": "function", "doc": "<p>Get the neighbors of node n. The final argument is either 'n' or 'e'. If it is 'n'\nthe function returns all neighboring nodes, and if it is 'e' it returns incident edges.</p>\n", "signature": "(self, n, mode='n')", "funcdef": "def"}, {"fullname": "pygel3d.graph.Graph.positions", "modulename": "pygel3d.graph", "qualname": "Graph.positions", "type": "function", "doc": "<p>Get the vertex positions by reference. You can assign to the\npositions.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pygel3d.graph.Graph.average_edge_length", "modulename": "pygel3d.graph", "qualname": "Graph.average_edge_length", "type": "function", "doc": "<p>Returns the average edge length.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pygel3d.graph.Graph.add_node", "modulename": "pygel3d.graph", "qualname": "Graph.add_node", "type": "function", "doc": "<p>Adds node with position p to the graph and returns the\nindex of the new node.</p>\n", "signature": "(self, p)", "funcdef": "def"}, {"fullname": "pygel3d.graph.Graph.remove_node", "modulename": "pygel3d.graph", "qualname": "Graph.remove_node", "type": "function", "doc": "<p>Removes the node n passed as argument. This does not change\nany indices of other nodes, but n is then invalid.</p>\n", "signature": "(self, n)", "funcdef": "def"}, {"fullname": "pygel3d.graph.Graph.node_in_use", "modulename": "pygel3d.graph", "qualname": "Graph.node_in_use", "type": "function", "doc": "<p>Checks if n is in_use. This function returns false both\nif n has been removed and if n is an index outside the range of\nindices that are used.</p>\n", "signature": "(self, n)", "funcdef": "def"}, {"fullname": "pygel3d.graph.Graph.connect_nodes", "modulename": "pygel3d.graph", "qualname": "Graph.connect_nodes", "type": "function", "doc": "<p>Creates a new edge connecting nodes n0 and n1. The index of\nthe new edge is returned.</p>\n", "signature": "(self, n0, n1)", "funcdef": "def"}, {"fullname": "pygel3d.graph.Graph.disconnect_nodes", "modulename": "pygel3d.graph", "qualname": "Graph.disconnect_nodes", "type": "function", "doc": "<p>Disconect nodes n0 and n1</p>\n", "signature": "(self, n0, n1)", "funcdef": "def"}, {"fullname": "pygel3d.graph.Graph.merge_nodes", "modulename": "pygel3d.graph", "qualname": "Graph.merge_nodes", "type": "function", "doc": "<p>Merge nodes n0 and n1. avg_pos indicates if you want the position to be the average.</p>\n", "signature": "(self, n0, n1, avg_pos)", "funcdef": "def"}, {"fullname": "pygel3d.graph.from_mesh", "modulename": "pygel3d.graph", "qualname": "from_mesh", "type": "function", "doc": "<p>Creates a graph from a mesh. The argument, m, is the input mesh,\nand the function returns a graph with the same vertices and edges\nas m.</p>\n", "signature": "(m)", "funcdef": "def"}, {"fullname": "pygel3d.graph.load", "modulename": "pygel3d.graph", "qualname": "load", "type": "function", "doc": "<p>Load a graph from a file. The argument, fn, is the filename which\nis in a special format similar to Wavefront obj. The loaded graph is\nreturned by the function - or None if loading failed.</p>\n", "signature": "(fn)", "funcdef": "def"}, {"fullname": "pygel3d.graph.save", "modulename": "pygel3d.graph", "qualname": "save", "type": "function", "doc": "<p>Save graph to a file. The first argument, fn, is the file name,\nand g is the graph. This function returns True if saving happened and\nFalse otherwise.</p>\n", "signature": "(fn, g)", "funcdef": "def"}, {"fullname": "pygel3d.graph.to_mesh_cyl", "modulename": "pygel3d.graph", "qualname": "to_mesh_cyl", "type": "function", "doc": "<p>Creates a Manifold mesh from the graph. The first argument, g, is the\ngraph we want converted, and fudge is a constant that is used to increase the radius\nof every node. This is useful if the radii are 0.</p>\n", "signature": "(g, fudge)", "funcdef": "def"}, {"fullname": "pygel3d.graph.smooth", "modulename": "pygel3d.graph", "qualname": "smooth", "type": "function", "doc": "<p>Simple Laplacian smoothing of a graph. The first argument is the Graph, g, iter\nis the number of iterations, and alpha is the weight. If the weight is high,\neach iteration causes a lot of smoothing, and a high number of iterations\nensures that the effect of smoothing diffuses throughout the graph, i.e. that the\neffect is more global than local.</p>\n", "signature": "(g, iter=1, alpha=1.0)", "funcdef": "def"}, {"fullname": "pygel3d.graph.edge_contract", "modulename": "pygel3d.graph", "qualname": "edge_contract", "type": "function", "doc": "<p>Simplifies a graph by contracting edges. The first argument, g, is the graph,\nand only edges shorter than dist_thresh are contracted. When an edge is contracted\nthe merged vertices are moved to the average of their former positions. Thus,\nthe ordering in which contractions are carried out matters. Hence, edges are\ncontracted in the order of increasing length and edges are only considered if\nneither end point is the result of a contraction, but the process is then repeated\nuntil no more contractions are possible. Returns total number of contractions.</p>\n", "signature": "(g, dist_thresh)", "funcdef": "def"}, {"fullname": "pygel3d.graph.prune", "modulename": "pygel3d.graph", "qualname": "prune", "type": "function", "doc": "<p>Prune leaves of a graph. The graph, g, is passed as the argument. This function\nremoves leaf nodes (valency 1) whose only neighbour has valency &gt; 2. In practice\nsuch isolated leaves are frequently spurious if the graph is a skeleton. Does not\nreturn a value.</p>\n", "signature": "(g)", "funcdef": "def"}, {"fullname": "pygel3d.graph.LS_skeleton", "modulename": "pygel3d.graph", "qualname": "LS_skeleton", "type": "function", "doc": "<p>Skeletonize a graph using the local separators approach. The first argument,\ng, is the graph, and, sampling indicates whether we try to use all vertices\n(False) as starting points for finding separators or just a sampling (True).\nThe function returns a new graph which is the skeleton of the input graph.</p>\n", "signature": "(g, sampling=True)", "funcdef": "def"}, {"fullname": "pygel3d.graph.LS_skeleton_and_map", "modulename": "pygel3d.graph", "qualname": "LS_skeleton_and_map", "type": "function", "doc": "<p>Skeletonize a graph using the local separators approach. The first argument,\ng, is the graph, and, sampling indicates whether we try to use all vertices\n(False) as starting points for finding separators or just a sampling (True).\nThe function returns a tuple containing a new graph which is the skeleton of\nthe input graph and a map from the graph nodes to the skeletal nodes.</p>\n", "signature": "(g, sampling=True)", "funcdef": "def"}, {"fullname": "pygel3d.graph.front_skeleton_and_map", "modulename": "pygel3d.graph", "qualname": "front_skeleton_and_map", "type": "function", "doc": "<p>Skeletonize a graph using the front separators approach. The first argument,\ng, is the graph, and, colors is a 2D array where each row contains a sequence\nof floating point values - one for each node. We can have as many rows as needed\nfor the front separator computation. We can think of this as a coloring\nof the nodes, hence the name. In practice, a coloring might just be the x-coordinate\nof the nodes or some other function that indicates something about the structure of the\ngraph. The function returns a tuple containing a new graph which is the\nskeleton of the input graph and a map from the graph nodes to the skeletal nodes.</p>\n", "signature": "(g, colors)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh", "modulename": "pygel3d.hmesh", "type": "module", "doc": "<p>The hmesh module provides an halfedge based mesh representation.</p>\n"}, {"fullname": "pygel3d.hmesh.Manifold", "modulename": "pygel3d.hmesh", "qualname": "Manifold", "type": "class", "doc": "<p>The Manifold class represents a halfedge based mesh. It is maybe a bit grand to call\na mesh class Manifold, but meshes based on the halfedge representation are manifold (if we\nignore a few corner cases) unlike some other representations. This class contains a number of\nmethods for mesh manipulation and inspection. Note also that numerous further functions are\navailable to manipulate meshes stored as Manifolds.</p>\n\n<p>Many of the functions below accept arguments called hid, fid, or vid. These are simply indices\nof halfedges, faces and vertices, respectively: integer numbers that identify the corresponding\nmesh element. Using a plain integer to identify a mesh entity means that, for instance, a\nvertex index can also be used as an index into, say, a NumPy array without any conversion.</p>\n"}, {"fullname": "pygel3d.hmesh.Manifold.__init__", "modulename": "pygel3d.hmesh", "qualname": "Manifold.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, orig=None)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.from_triangles", "modulename": "pygel3d.hmesh", "qualname": "Manifold.from_triangles", "type": "function", "doc": "<p>Given a list of vertices and triangles (faces), this function produces \na Manifold mesh.</p>\n", "signature": "(cls, vertices, faces)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.from_points", "modulename": "pygel3d.hmesh", "qualname": "Manifold.from_points", "type": "function", "doc": "<p>This function computes the Delaunay triangulation of pts. You need\nto specify xaxis and yaxis if they are not canonical. The function returns\na Manifold with the resulting triangles. Clearly, this function will\ngive surprising results if the surface represented by the points is not\nwell represented as a 2.5D surface, aka a height field.</p>\n", "signature": "(cls, pts, xaxis=array([1, 0, 0]), yaxis=array([0, 1, 0]))", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.add_face", "modulename": "pygel3d.hmesh", "qualname": "Manifold.add_face", "type": "function", "doc": "<p>Add a face to the Manifold.\nThis function takes a list of 3D points, pts, as argument and creates a face\nin the mesh with those points as vertices. The function returns the index\nof the created face.</p>\n", "signature": "(self, pts)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.positions", "modulename": "pygel3d.hmesh", "qualname": "Manifold.positions", "type": "function", "doc": "<p>Retrieve an array containing the vertex positions of the Manifold.\nIt is not a copy: any changes are made to the actual vertex positions.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.no_allocated_vertices", "modulename": "pygel3d.hmesh", "qualname": "Manifold.no_allocated_vertices", "type": "function", "doc": "<p>Number of vertices.\nThis number could be higher than the number of actually\nused vertices, but corresponds to the size of the array allocated\nfor vertices.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.no_allocated_faces", "modulename": "pygel3d.hmesh", "qualname": "Manifold.no_allocated_faces", "type": "function", "doc": "<p>Number of faces.\nThis number could be higher than the number of actually\nused faces, but corresponds to the size of the array allocated\nfor faces.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.no_allocated_halfedges", "modulename": "pygel3d.hmesh", "qualname": "Manifold.no_allocated_halfedges", "type": "function", "doc": "<p>Number of halfedges.\nThis number could be higher than the number of actually\nused halfedges, but corresponds to the size of the array allocated\nfor halfedges.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.vertices", "modulename": "pygel3d.hmesh", "qualname": "Manifold.vertices", "type": "function", "doc": "<p>Returns an iterable containing all vertex indices</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.faces", "modulename": "pygel3d.hmesh", "qualname": "Manifold.faces", "type": "function", "doc": "<p>Returns an iterable containing all face indices</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.halfedges", "modulename": "pygel3d.hmesh", "qualname": "Manifold.halfedges", "type": "function", "doc": "<p>Returns an iterable containing all halfedge indices</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.circulate_vertex", "modulename": "pygel3d.hmesh", "qualname": "Manifold.circulate_vertex", "type": "function", "doc": "<p>Circulate a vertex. Passed a vertex index, vid, and second argument,\nmode='f', this function will return an iterable with all faces incident\non vid arranged in counter clockwise order. Similarly, if mode is 'h',\nincident halfedges (outgoing) are returned, and for mode = 'v', all\nneighboring vertices are returned.</p>\n", "signature": "(self, vid, mode='v')", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.circulate_face", "modulename": "pygel3d.hmesh", "qualname": "Manifold.circulate_face", "type": "function", "doc": "<p>Circulate a face. Passed a face index, fid, and second argument,\nmode='f', this function will return an iterable with all faces that\nshare an edge with fid (in counter clockwise order). If the argument is\nmode='h', the halfedges themselves are returned. For mode='v', the\nincident vertices of the face are returned.</p>\n", "signature": "(self, fid, mode='v')", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.next_halfedge", "modulename": "pygel3d.hmesh", "qualname": "Manifold.next_halfedge", "type": "function", "doc": "<p>Returns next halfedge to hid.</p>\n", "signature": "(self, hid)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.prev_halfedge", "modulename": "pygel3d.hmesh", "qualname": "Manifold.prev_halfedge", "type": "function", "doc": "<p>Returns previous halfedge to hid.</p>\n", "signature": "(self, hid)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.opposite_halfedge", "modulename": "pygel3d.hmesh", "qualname": "Manifold.opposite_halfedge", "type": "function", "doc": "<p>Returns opposite halfedge to hid.</p>\n", "signature": "(self, hid)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.incident_face", "modulename": "pygel3d.hmesh", "qualname": "Manifold.incident_face", "type": "function", "doc": "<p>Returns face corresponding to hid.</p>\n", "signature": "(self, hid)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.incident_vertex", "modulename": "pygel3d.hmesh", "qualname": "Manifold.incident_vertex", "type": "function", "doc": "<p>Returns vertex corresponding to (or pointed to by) hid.</p>\n", "signature": "(self, hid)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.remove_vertex", "modulename": "pygel3d.hmesh", "qualname": "Manifold.remove_vertex", "type": "function", "doc": "<p>Remove vertex vid from the Manifold. This function merges all faces\naround the vertex into one and then removes this resulting face.</p>\n", "signature": "(self, vid)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.remove_face", "modulename": "pygel3d.hmesh", "qualname": "Manifold.remove_face", "type": "function", "doc": "<p>Removes a face, fid, from the Manifold. If it is an interior face it is\nsimply replaced by an invalid index. If the face contains boundary\nedges, these are removed. Situations may arise where the mesh is no\nlonger manifold because the situation at a boundary vertex is not\nhomeomorphic to a half disk. This, we can probably ignore since from the\ndata structure point of view it is not really a problem that a vertex is\nincident on two holes - a hole can be seen as a special type of face.\nThe function returns false if the index of the face is not valid,\notherwise the function must complete.</p>\n", "signature": "(self, fid)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.remove_edge", "modulename": "pygel3d.hmesh", "qualname": "Manifold.remove_edge", "type": "function", "doc": "<p>Remove an edge, hid, from the Manifold. This function will remove the\nfaces on either side and the edge itself in the process. Thus, it is a\nsimple application of remove_face.</p>\n", "signature": "(self, hid)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.vertex_in_use", "modulename": "pygel3d.hmesh", "qualname": "Manifold.vertex_in_use", "type": "function", "doc": "<p>check if vertex, vid, is in use. This function returns true if the id corresponds\nto a vertex that is currently in the mesh and false otherwise. vid could\nbe outside the range of used ids and it could also correspond to a vertex\nwhich is not active. The function returns false in both cases.</p>\n", "signature": "(self, vid)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.face_in_use", "modulename": "pygel3d.hmesh", "qualname": "Manifold.face_in_use", "type": "function", "doc": "<p>check if face, fid, is in use. This function returns true if the id corresponds\nto a face that is currently in the mesh and false otherwise. fid could\nbe outside the range of used ids and it could also correspond to a face\nwhich is not active. The function returns false in both cases.</p>\n", "signature": "(self, fid)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.halfedge_in_use", "modulename": "pygel3d.hmesh", "qualname": "Manifold.halfedge_in_use", "type": "function", "doc": "<p>check if halfedge hid is in use. This function returns true if the id corresponds\nto a halfedge that is currently in the mesh and false otherwise. hid could\nbe outside the range of used ids and it could also correspond to a halfedge\nwhich is not active. The function returns false in both cases.</p>\n", "signature": "(self, hid)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.flip_edge", "modulename": "pygel3d.hmesh", "qualname": "Manifold.flip_edge", "type": "function", "doc": "<p>Flip the edge, hid, separating two faces. The function first verifies that\nthe edge is flippable. This entails making sure that all of the\nfollowing are true.</p>\n\n<ol>\n<li>adjacent faces are triangles.</li>\n<li>neither end point has valency three or less.</li>\n<li>the vertices that will be connected are not already.\nIf the tests are passed, the flip is performed and the function\nreturns True. Otherwise False.</li>\n</ol>\n", "signature": "(self, hid)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.collapse_edge", "modulename": "pygel3d.hmesh", "qualname": "Manifold.collapse_edge", "type": "function", "doc": "<p>Collapse an edge hid.</p>\n\n<h2 id=\"before-collapsing-hid-a-number-of-tests-are-made\">Before collapsing hid, a number of tests are made:</h2>\n\n<ol>\n<li>For the two vertices adjacent to the edge, we generate a list of all their neighbouring vertices.\nWe then generate a  list of the vertices that occur in both these lists.\nThat is, we find all vertices connected by edges to both endpoints of the edge and store these in a list.</li>\n<li>For both faces incident on the edge, check whether they are triangular.\nIf this is the case, the face will be removed, and it is ok that the the third vertex is connected to both endpoints.\nThus the third vertex in such a face is removed from the list generated in 1.</li>\n<li>If the list is now empty, all is well.\nOtherwise, there would be a vertex in the new mesh with two edges connecting it to the same vertex. Return false.</li>\n<li>TETRAHEDRON TEST:\nIf the valency of both vertices is three, and the incident faces are triangles, we also disallow the operation.\nReason: A vertex valency of two and two triangles incident on the adjacent vertices makes the construction collapse.</li>\n<li>VALENCY 4 TEST:\nIf a triangle is adjacent to the edge being collapsed, it disappears.\nThis means the valency of the remaining edge vertex is decreased by one.\nA valency two vertex reduced to a valency one vertex is considered illegal.</li>\n<li>PREVENT MERGING HOLES:\nCollapsing an edge with boundary endpoints and valid faces results in the creation where two holes meet.\nA non manifold situation. We could relax this...</li>\n<li>New test: if the same face is in the one-ring of both vertices but not adjacent to the common edge,\nthen the result of a collapse would be a one ring where the same face occurs twice. This is disallowed as the resulting\nface would be non-simple.\nIf the tests are passed, the collapse is performed and the function\nreturns True. Otherwise False.</li>\n</ol>\n", "signature": "(self, hid, avg_vertices=False)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.split_face_by_edge", "modulename": "pygel3d.hmesh", "qualname": "Manifold.split_face_by_edge", "type": "function", "doc": "<p>Split a face. The face, fid, is split by creating an edge with\nendpoints v0 and v1 (the next two arguments). The vertices of the old\nface between v0 and v1 (in counter clockwise order) continue to belong\nto fid. The vertices between v1 and v0 belong to the new face. A handle to\nthe new face is returned.</p>\n", "signature": "(self, fid, v0, v1)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.split_face_by_vertex", "modulename": "pygel3d.hmesh", "qualname": "Manifold.split_face_by_vertex", "type": "function", "doc": "<p>Split a polygon, fid, by inserting a vertex at the barycenter. This\nfunction is less likely to create flipped triangles than the\nsplit_face_triangulate function. On the other hand, it introduces more\nvertices and probably makes the triangles more acute. The vertex id of the\ninserted vertex is returned.</p>\n", "signature": "(self, fid)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.split_edge", "modulename": "pygel3d.hmesh", "qualname": "Manifold.split_edge", "type": "function", "doc": "<p>Insert a new vertex on halfedge hid. The new halfedge is insterted\nas the previous edge to hid. The vertex id of the inserted vertex is returned.</p>\n", "signature": "(self, hid)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.stitch_boundary_edges", "modulename": "pygel3d.hmesh", "qualname": "Manifold.stitch_boundary_edges", "type": "function", "doc": "<p>Stitch two halfedges. Two boundary halfedges, h0 and h1, can be stitched\ntogether. This can be used to build a complex mesh from a bunch of\nsimple faces.</p>\n", "signature": "(self, h0, h1)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.merge_faces", "modulename": "pygel3d.hmesh", "qualname": "Manifold.merge_faces", "type": "function", "doc": "<p>Merges two faces into a single polygon. The merged faces are those shared\nby the edge for which hid is one of the two corresponding halfedges. This function returns\ntrue if the merging was possible and false otherwise. Currently merge\nonly fails if the mesh is already illegal. Thus it should, in fact,\nnever fail.</p>\n", "signature": "(self, hid)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.close_hole", "modulename": "pygel3d.hmesh", "qualname": "Manifold.close_hole", "type": "function", "doc": "<p>Close hole given by hid (i.e. the face referenced by hid). Returns\nindex of the created face or the face that was already there if, in\nfact, hid was not next to a hole.</p>\n", "signature": "(self, hid)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.cleanup", "modulename": "pygel3d.hmesh", "qualname": "Manifold.cleanup", "type": "function", "doc": "<p>Remove unused items from Mesh. This function remaps all vertices, halfedges\nand faces such that the arrays do not contain any holes left by unused mesh\nentities. It is a good idea to call this function when a mesh has been simplified\nor changed in other ways such that mesh entities have been removed. However, note\nthat it invalidates any attributes that you might have stored in auxilliary arrays.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.is_halfedge_at_boundary", "modulename": "pygel3d.hmesh", "qualname": "Manifold.is_halfedge_at_boundary", "type": "function", "doc": "<p>Returns True if hid is a boundary halfedge, i.e. face on either\nside is invalid.</p>\n", "signature": "(self, hid)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.is_vertex_at_boundary", "modulename": "pygel3d.hmesh", "qualname": "Manifold.is_vertex_at_boundary", "type": "function", "doc": "<p>Returns True if vid lies on a boundary.</p>\n", "signature": "(self, vid)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.edge_length", "modulename": "pygel3d.hmesh", "qualname": "Manifold.edge_length", "type": "function", "doc": "<p>Returns length of edge given by halfedge hid which is passed as argument.</p>\n", "signature": "(self, hid)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.valency", "modulename": "pygel3d.hmesh", "qualname": "Manifold.valency", "type": "function", "doc": "<p>Returns valency of vid, i.e. number of incident edges.</p>\n", "signature": "(self, vid)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.vertex_normal", "modulename": "pygel3d.hmesh", "qualname": "Manifold.vertex_normal", "type": "function", "doc": "<p>Returns vertex normal (angle weighted) of vertex given by vid</p>\n", "signature": "(self, vid)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.connected", "modulename": "pygel3d.hmesh", "qualname": "Manifold.connected", "type": "function", "doc": "<p>Returns true if the two argument vertices, v0 and v1, are in each other's one-rings.</p>\n", "signature": "(self, v0, v1)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.no_edges", "modulename": "pygel3d.hmesh", "qualname": "Manifold.no_edges", "type": "function", "doc": "<p>Compute the number of edges of a face fid</p>\n", "signature": "(self, fid)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.face_normal", "modulename": "pygel3d.hmesh", "qualname": "Manifold.face_normal", "type": "function", "doc": "<p>Compute the normal of a face fid. If the face is not a triangle,\nthe normal is not defined, but computed using the first three\nvertices of the face.</p>\n", "signature": "(self, fid)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.area", "modulename": "pygel3d.hmesh", "qualname": "Manifold.area", "type": "function", "doc": "<p>Returns the area of a face fid.</p>\n", "signature": "(self, fid)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.perimeter", "modulename": "pygel3d.hmesh", "qualname": "Manifold.perimeter", "type": "function", "doc": "<p>Returns the perimeter of a face fid.</p>\n", "signature": "(self, fid)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.Manifold.centre", "modulename": "pygel3d.hmesh", "qualname": "Manifold.centre", "type": "function", "doc": "<p>Returns the centre of a face.</p>\n", "signature": "(self, fid)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.valid", "modulename": "pygel3d.hmesh", "qualname": "valid", "type": "function", "doc": "<p>This function performs a series of tests to check that this\nis a valid manifold. This function is not rigorously constructed but seems\nto catch all problems so far. The function returns true if the mesh is valid\nand false otherwise.</p>\n", "signature": "(m)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.closed", "modulename": "pygel3d.hmesh", "qualname": "closed", "type": "function", "doc": "<p>Returns true if m is closed, i.e. has no boundary.</p>\n", "signature": "(m)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.bbox", "modulename": "pygel3d.hmesh", "qualname": "bbox", "type": "function", "doc": "<p>Returns the min and max corners of the bounding box of Manifold m.</p>\n", "signature": "(m)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.bsphere", "modulename": "pygel3d.hmesh", "qualname": "bsphere", "type": "function", "doc": "<p>Calculate the bounding sphere of the manifold m.\nReturns centre,radius</p>\n", "signature": "(m)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.stitch", "modulename": "pygel3d.hmesh", "qualname": "stitch", "type": "function", "doc": "<p>Stitch together edges of m whose endpoints coincide geometrically. This\nfunction allows you to create a mesh as a bunch of faces and then stitch\nthese together to form a coherent whole. What this function adds is a\nspatial data structure to find out which vertices coincide. The return value\nis the number of edges that could not be stitched. Often this is because it\nwould introduce a non-manifold situation.</p>\n", "signature": "(m, rad=1e-30)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.obj_save", "modulename": "pygel3d.hmesh", "qualname": "obj_save", "type": "function", "doc": "<p>Save Manifold m to Wavefront obj file.</p>\n", "signature": "(fn, m)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.off_save", "modulename": "pygel3d.hmesh", "qualname": "off_save", "type": "function", "doc": "<p>Save Manifold m to OFF file.</p>\n", "signature": "(fn, m)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.x3d_save", "modulename": "pygel3d.hmesh", "qualname": "x3d_save", "type": "function", "doc": "<p>Save Manifold m to X3D file.</p>\n", "signature": "(fn, m)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.obj_load", "modulename": "pygel3d.hmesh", "qualname": "obj_load", "type": "function", "doc": "<p>Load and return Manifold from Wavefront obj file.\nReturns None if loading failed.</p>\n", "signature": "(fn)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.off_load", "modulename": "pygel3d.hmesh", "qualname": "off_load", "type": "function", "doc": "<p>Load and return Manifold from OFF file.\nReturns None if loading failed.</p>\n", "signature": "(fn)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.ply_load", "modulename": "pygel3d.hmesh", "qualname": "ply_load", "type": "function", "doc": "<p>Load and return Manifold from Stanford PLY file.\nReturns None if loading failed.</p>\n", "signature": "(fn)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.x3d_load", "modulename": "pygel3d.hmesh", "qualname": "x3d_load", "type": "function", "doc": "<p>Load and return Manifold from X3D file.\nReturns None if loading failed.</p>\n", "signature": "(fn)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.load", "modulename": "pygel3d.hmesh", "qualname": "load", "type": "function", "doc": "<p>Load a Manifold from an X3D/OBJ/OFF/PLY file. Return the\nloaded Manifold. Returns None if loading failed.</p>\n", "signature": "(fn)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.save", "modulename": "pygel3d.hmesh", "qualname": "save", "type": "function", "doc": "<p>Save a Manifold, m, to an X3D/OBJ/OFF file.</p>\n", "signature": "(fn, m)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.remove_caps", "modulename": "pygel3d.hmesh", "qualname": "remove_caps", "type": "function", "doc": "<p>Remove caps from a manifold, m, consisting of only triangles. A cap is a\ntriangle with two very small angles and an angle close to pi, however a cap\ndoes not necessarily have a very short edge. Set the ang_thresh to a value\nclose to pi. The closer to pi the _less_ sensitive the cap removal. A cap is\nremoved by flipping the (long) edge E opposite to the vertex V with the\nangle close to pi. However, the function is more complex. Read code and\ndocument more carefully !!!</p>\n", "signature": "(m, thresh=2.9)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.remove_needles", "modulename": "pygel3d.hmesh", "qualname": "remove_needles", "type": "function", "doc": "<p>Remove needles from a manifold, m, consisting of only triangles. A needle\nis a triangle with a single very short edge. It is moved by collapsing the\nshort edge. The thresh parameter sets the length threshold (in terms of the average edge length\nin the mesh). If average_positions is true then the collapsed vertex is placed at the average position of the end points.</p>\n", "signature": "(m, thresh=0.05, average_positions=False)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.close_holes", "modulename": "pygel3d.hmesh", "qualname": "close_holes", "type": "function", "doc": "<p>This function replaces holes in m by faces. It is really a simple function\nthat just finds all loops of edges next to missing faces.</p>\n", "signature": "(m, max_size=100)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.flip_orientation", "modulename": "pygel3d.hmesh", "qualname": "flip_orientation", "type": "function", "doc": "<p>Flip the orientation of a mesh, m. After calling this function, normals\nwill point the other way and clockwise becomes counter clockwise</p>\n", "signature": "(m)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.merge_coincident_boundary_vertices", "modulename": "pygel3d.hmesh", "qualname": "merge_coincident_boundary_vertices", "type": "function", "doc": "<p>Merge vertices of m that are boundary vertices and coincident.\nHowever, if one belongs to the other's one ring or the one\nrings share a vertex, they will not be merged.</p>\n", "signature": "(m, rad=1e-30)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.minimize_curvature", "modulename": "pygel3d.hmesh", "qualname": "minimize_curvature", "type": "function", "doc": "<p>Minimizes mean curvature of m by flipping edges. Hence, no vertices are moved.\nThis is really the same as dihedral angle minimization, except that we weight by edge length.</p>\n", "signature": "(m, anneal=False)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.minimize_dihedral_angle", "modulename": "pygel3d.hmesh", "qualname": "minimize_dihedral_angle", "type": "function", "doc": "<p>Minimizes dihedral angles in m by flipping edges.\nArguments:\nmax_iter is the maximum number of iterations for simulated annealing.\nanneal tells us the code whether to apply simulated annealing\nalpha=False means that we use the cosine of angles rather than true angles (faster)\ngamma is the power to which the angles are raised.</p>\n", "signature": "(m, max_iter=10000, anneal=False, alpha=False, gamma=4.0)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.maximize_min_angle", "modulename": "pygel3d.hmesh", "qualname": "maximize_min_angle", "type": "function", "doc": "<p>Maximizes the minimum angle of triangles by flipping edges of m. Makes the mesh more Delaunay.</p>\n", "signature": "(m, dihedral_thresh=0.95, anneal=False)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.optimize_valency", "modulename": "pygel3d.hmesh", "qualname": "optimize_valency", "type": "function", "doc": "<p>Tries to achieve valence 6 internally and 4 along edges by flipping edges of m.</p>\n", "signature": "(m, anneal=False)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.randomize_mesh", "modulename": "pygel3d.hmesh", "qualname": "randomize_mesh", "type": "function", "doc": "<p>Make random flips in m. Useful for generating synthetic test cases.</p>\n", "signature": "(m, max_iter=1)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.quadric_simplify", "modulename": "pygel3d.hmesh", "qualname": "quadric_simplify", "type": "function", "doc": "<p>Garland Heckbert simplification of mesh m in our own implementation. keep_fraction\nis the fraction of vertices to retain. The singular_thresh defines how small\nsingular values from the SVD we accept. It is relative to the greatest\nsingular value. If optimal_positions is true, we reposition vertices.\nOtherwise the vertices are a subset of the old vertices.</p>\n", "signature": "(m, keep_fraction, singular_thresh=0.0001, optimal_positions=True)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.average_edge_length", "modulename": "pygel3d.hmesh", "qualname": "average_edge_length", "type": "function", "doc": "<p>Returns the average edge length of mesh m.</p>\n", "signature": "(m, max_iter=1)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.median_edge_length", "modulename": "pygel3d.hmesh", "qualname": "median_edge_length", "type": "function", "doc": "<p>Returns the median edge length of m</p>\n", "signature": "(m, max_iter=1)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.refine_edges", "modulename": "pygel3d.hmesh", "qualname": "refine_edges", "type": "function", "doc": "<p>Split all edges in m which are longer\nthan the threshold (second arg) length. A split edge\nresults in a new vertex of valence two.</p>\n", "signature": "(m, threshold)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.cc_split", "modulename": "pygel3d.hmesh", "qualname": "cc_split", "type": "function", "doc": "<p>Perform a Catmull-Clark split on m, i.e. a split where each face is divided\ninto new quadrilateral faces formed by connecting a corner with a point on\neach incident edge and a point at the centre of the face.</p>\n", "signature": "(m)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.loop_split", "modulename": "pygel3d.hmesh", "qualname": "loop_split", "type": "function", "doc": "<p>Perform a loop split on m where each edge is divided into two segments, and\nfour new triangles are created for each original triangle.</p>\n", "signature": "(m)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.root3_subdivide", "modulename": "pygel3d.hmesh", "qualname": "root3_subdivide", "type": "function", "doc": "<p>Leif Kobbelt's subdivision scheme applied to m. A vertex is placed in the\ncenter of each face and all old edges are flipped.</p>\n", "signature": "(m)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.rootCC_subdivide", "modulename": "pygel3d.hmesh", "qualname": "rootCC_subdivide", "type": "function", "doc": "<p>This subdivision scheme creates a vertex inside each original (quad) face of m,\nproducing four triangles. Triangles sharing an old edge are then merged.\nTwo steps produce something similar to Catmull-Clark.</p>\n", "signature": "(m)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.butterfly_subdivide", "modulename": "pygel3d.hmesh", "qualname": "butterfly_subdivide", "type": "function", "doc": "<p>Butterfly subidiviosn on m. An interpolatory scheme. Creates the same connectivity as Loop.</p>\n", "signature": "(m)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.cc_smooth", "modulename": "pygel3d.hmesh", "qualname": "cc_smooth", "type": "function", "doc": "<p>If called after cc_split, this function completes a step of Catmull-Clark\nsubdivision of m.</p>\n", "signature": "(m)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.loop_smooth", "modulename": "pygel3d.hmesh", "qualname": "loop_smooth", "type": "function", "doc": "<p>If called after Loop split, this function completes a step of Loop\nsubdivision of m.</p>\n", "signature": "(m)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.triangulate", "modulename": "pygel3d.hmesh", "qualname": "triangulate", "type": "function", "doc": "<p>Turn a general polygonal mesh, m, into a triangle mesh by repeatedly\nsplitting a polygon into smaller polygons.</p>\n", "signature": "(m, clip_ear=True)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.MeshDistance", "modulename": "pygel3d.hmesh", "qualname": "MeshDistance", "type": "class", "doc": "<p>This class allows you to compute the distance from any point in space to\na Manifold (which must be triangulated). The constructor creates an instance\nbased on a specific mesh, and the signed_distance function computes the actual distance.</p>\n"}, {"fullname": "pygel3d.hmesh.MeshDistance.__init__", "modulename": "pygel3d.hmesh", "qualname": "MeshDistance.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, m)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.MeshDistance.signed_distance", "modulename": "pygel3d.hmesh", "qualname": "MeshDistance.signed_distance", "type": "function", "doc": "<p>Compute the signed distance from each point in pts to the mesh stored in \nthis class instance. pts should be convertible to a length N>=1 array of 3D \npoints. The function returns an array of N distance values with a single distance \nfor each point. The distance corresponding to a point is positive if the point \nis outside and negative if inside. The upper parameter can be used to threshold \nhow far away the distance is of interest.</p>\n", "signature": "(self, pts, upper=1e+30)", "funcdef": "def"}, {"fullname": "pygel3d.hmesh.MeshDistance.ray_inside_test", "modulename": "pygel3d.hmesh", "qualname": "MeshDistance.ray_inside_test", "type": "function", "doc": "<p>Check whether each point in pts is inside or outside the stored mesh by \ncasting rays. pts should be convertible to a length N>=1 array of 3D points.\nEffectively, this is the sign of the distance. In some cases casting (multiple)\nray is more robust than using the sign computed locally. Returns an array of \nN integers which are either 1 or 0 depending on whether the corresponding point\nis inside (1) or outside (0).</p>\n", "signature": "(self, pts, no_rays=3)", "funcdef": "def"}, {"fullname": "pygel3d.jupyter_display", "modulename": "pygel3d.jupyter_display", "type": "module", "doc": "<p>This is a module with a function, display, that provides functionality for displaying a\nManifold or a Graph as an interactive 3D model in a Jupyter Notebook.</p>\n"}, {"fullname": "pygel3d.jupyter_display.set_export_mode", "modulename": "pygel3d.jupyter_display", "qualname": "set_export_mode", "type": "function", "doc": "<p>Calling this function will set export mode to true. It is necessary\nto do so if we wish to export a notebook containing interactive\nplotly graphics (made with display below) to HTML. In other words, this function\nshould not necessarily be called in normal usage but only when we export to HTML. It is\nthen called once in the beginning of the notebook. However, as a bit of a twist on\nthis story, it appears that if we don't call this function, any call to display must\nbe the last thing that happens in a cell. So, maybe it is best to always call\nset_export_mode in the beginning of a notebook.</p>\n", "signature": "(_exp_mode=True)", "funcdef": "def"}, {"fullname": "pygel3d.jupyter_display.display", "modulename": "pygel3d.jupyter_display", "qualname": "display", "type": "function", "doc": "<p>The display function shows an interactive presentation of the Manifold, m, inside\na Jupyter Notebook. wireframe=True means that a wireframe view of the mesh is\nsuperimposed on the 3D model. If smooth=True, the mesh is rendered with vertex\nnormals. Otherwise, the mesh is rendered with face normals. If data=None, the\nmesh is shown in a light grey color. If data contains an array of scalar values\nper vertex, these are mapped to colors used to color the mesh. Finally, note that\nm can also be a Graph. In that case the display function just draws the edges as\nblack lines.</p>\n", "signature": "(m, wireframe=True, smooth=True, data=None)", "funcdef": "def"}, {"fullname": "pygel3d.spatial", "modulename": "pygel3d.spatial", "type": "module", "doc": "<p>This module provides a kD-tree implementation but specialized to 3D</p>\n"}, {"fullname": "pygel3d.spatial.I3DTree", "modulename": "pygel3d.spatial", "qualname": "I3DTree", "type": "class", "doc": "<p>kD tree specialized for 3D keys and integer values.\nThis tree data structure is useful for storing 3D points and\nassociated integer values - typically indices. There is also\na more general kd tree in scipy.spatial if this one does not\nsuit your needs.</p>\n"}, {"fullname": "pygel3d.spatial.I3DTree.__init__", "modulename": "pygel3d.spatial", "qualname": "I3DTree.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pygel3d.spatial.I3DTree.insert", "modulename": "pygel3d.spatial", "qualname": "I3DTree.insert", "type": "function", "doc": "<p>Insert v at 3D point given by p. Insert should be called before\ncalling build.</p>\n", "signature": "(self, p, v)", "funcdef": "def"}, {"fullname": "pygel3d.spatial.I3DTree.build", "modulename": "pygel3d.spatial", "qualname": "I3DTree.build", "type": "function", "doc": "<p>Build the tree. This function call makes the tree searchable. It is\nassumed that all calls to insert come before calling this function.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "pygel3d.spatial.I3DTree.closest_point", "modulename": "pygel3d.spatial", "qualname": "I3DTree.closest_point", "type": "function", "doc": "<p>Search for point closest to p within a max radius r.\nThis function should only be called after build.</p>\n", "signature": "(self, p, r)", "funcdef": "def"}, {"fullname": "pygel3d.spatial.I3DTree.in_sphere", "modulename": "pygel3d.spatial", "qualname": "I3DTree.in_sphere", "type": "function", "doc": "<p>Retrieve all points within a radius r of p.\nThis function should only be called after build.</p>\n", "signature": "(self, p, r)", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();