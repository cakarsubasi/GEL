<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GEL: Geometry Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GEL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Geometry Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A namespace for utilities related to geometry.  
<a href="namespaceGeometry.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1AABox.html">AABox</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1AncestorGrid.html">AncestorGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class template is used as abstract ancestor of voxel grids.  <a href="classGeometry_1_1AncestorGrid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometry_1_1ISectTri.html">ISectTri</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometry_1_1TriAccel.html">TriAccel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometry_1_1BBox.html">BBox</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1BoundingINode.html">BoundingINode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interior node of bounding box tree.  <a href="classGeometry_1_1BoundingINode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1BoundingLNode.html">BoundingLNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leaf node of a bounding box tree. References triangle.  <a href="classGeometry_1_1BoundingLNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1BoundingNode.html">BoundingNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract BOUNDINGNODE node.  <a href="classGeometry_1_1BoundingNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1BoundingTree.html">BoundingTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template representing a bounding hierarchy.  <a href="classGeometry_1_1BoundingTree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometry_1_1BSPNode.html">BSPNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometry_1_1BSPLeaf.html">BSPLeaf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometry_1_1BSPInner.html">BSPInner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionGeometry_1_1FastBSPNode.html">FastBSPNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1BSPTree.html">BSPTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classGeometry_1_1BSPTree.html" title="BSPTree class.">BSPTree</a> class.  <a href="classGeometry_1_1BSPTree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1Cell.html">Cell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class template for a cell in a hierarchical grid.  <a href="classGeometry_1_1Cell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1DefaultCell.html">DefaultCell</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1GradientFilter.html">GradientFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a filter that computes gradients from a grid.  <a href="classGeometry_1_1GradientFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1AMGraph.html">AMGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classGeometry_1_1AMGraph.html" title="AMGraph means adjacency map graph.">AMGraph</a> means adjacency map graph.  <a href="classGeometry_1_1AMGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classGeometry_1_1AMGraph3D.html" title="AMGraph3D extends the AMGraph class by providing attributes for position, edge and node colors.">AMGraph3D</a> extends the <a class="el" href="classGeometry_1_1AMGraph.html" title="AMGraph means adjacency map graph.">AMGraph</a> class by providing attributes for position, edge and node colors.  <a href="classGeometry_1_1AMGraph3D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometry_1_1PrimPQElem.html">PrimPQElem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1BreadthFirstSearch.html">BreadthFirstSearch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometry_1_1LineProj.html">LineProj</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1LineSegment.html">LineSegment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1__HGridCellFunctor.html">_HGridCellFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1__AssignFun.html">_AssignFun</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1__HGridCellFunctorConst.html">_HGridCellFunctorConst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1Range3D.html">Range3D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1HGrid.html">HGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hierarchical voxel grid.  <a href="classGeometry_1_1HGrid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1Implicit.html">Implicit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1VolumetricImplicit.html">VolumetricImplicit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1IndexedFaceSet.html">IndexedFaceSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the simplest possible triangle mesh data structure.  <a href="classGeometry_1_1IndexedFaceSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometry_1_1KDTreeRecord.html">KDTreeRecord</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1KDTree.html">KDTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A classic K-D tree.  <a href="classGeometry_1_1KDTree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometry_1_1Material.html">Material</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple material definitions.  <a href="structGeometry_1_1Material.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1OBox.html">OBox</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1ImplicitFunction.html">ImplicitFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classGeometry_1_1Implicit.html">Implicit</a> function.  <a href="classGeometry_1_1ImplicitFunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometry_1_1POINT.html">POINT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometry_1_1TRIANGLE.html">TRIANGLE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structGeometry_1_1TRIANGLE.html" title="TRIANGLE struct contains the indices of the vertices comprising the triangle.">TRIANGLE</a> struct contains the indices of the vertices comprising the triangle.  <a href="structGeometry_1_1TRIANGLE.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1Polygonizer.html">Polygonizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classGeometry_1_1Polygonizer.html" title="Polygonizer is the class used to perform polygonization.">Polygonizer</a> is the class used to perform polygonization.  <a href="classGeometry_1_1Polygonizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1QEM.html">QEM</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometry_1_1Ray.html">Ray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a ray as used for ray tracing.  <a href="structGeometry_1_1Ray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1RGrid.html">RGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regular voxel grid.  <a href="classGeometry_1_1RGrid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1VolSaver.html">VolSaver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1VolSaverAscii.html">VolSaverAscii</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1VolSaverFloat.html">VolSaverFloat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1ParSurf.html">ParSurf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1ThreeDDDA.html">ThreeDDDA</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGeometry_1_1ThreeDDDA.html" title="A ThreeDDDA is a class for traversing a grid of cells.">ThreeDDDA</a> is a class for traversing a grid of cells.  <a href="classGeometry_1_1ThreeDDDA.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1Triangle.html">Triangle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1TrilinFilter.html">TrilinFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trilinear filter that can be applied to voxel grids.  <a href="classGeometry_1_1TrilinFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1TriMesh.html">TriMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGeometry_1_1Triangle.html">Triangle</a> Mesh struct.  <a href="classGeometry_1_1TriMesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1XForm.html">XForm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that allows transformations between a voxel space and object coordinates.  <a href="classGeometry_1_1XForm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a270e4e99ae8867a813631758cc20f2e7"><td class="memItemLeft" align="right" valign="top"><a id="a270e4e99ae8867a813631758cc20f2e7"></a>
typedef <a class="el" href="classGeometry_1_1BoundingTree.html">BoundingTree</a>&lt; <a class="el" href="classGeometry_1_1OBox.html">OBox</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>OBBTree</b></td></tr>
<tr class="separator:a270e4e99ae8867a813631758cc20f2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0330cc6b8fa272d1cdaedbb6ee5f95"><td class="memItemLeft" align="right" valign="top"><a id="aad0330cc6b8fa272d1cdaedbb6ee5f95"></a>
typedef <a class="el" href="classGeometry_1_1BoundingTree.html">BoundingTree</a>&lt; <a class="el" href="classGeometry_1_1AABox.html">AABox</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AABBTree</b></td></tr>
<tr class="separator:aad0330cc6b8fa272d1cdaedbb6ee5f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe34546394908fb74a0c3383afaf8a20"><td class="memItemLeft" align="right" valign="top"><a id="afe34546394908fb74a0c3383afaf8a20"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NodeID</b> = <a class="el" href="classGeometry_1_1AMGraph.html#aff736ffe081b073bd0038f288ea03313">AMGraph::NodeID</a></td></tr>
<tr class="separator:afe34546394908fb74a0c3383afaf8a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d5584aace8217c8ceb615584162b3f"><td class="memItemLeft" align="right" valign="top"><a id="a80d5584aace8217c8ceb615584162b3f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NodeSet</b> = <a class="el" href="classGeometry_1_1AMGraph.html#a45bfc4e413454ca81d6cd1839d5c2bc9">AMGraph::NodeSet</a></td></tr>
<tr class="separator:a80d5584aace8217c8ceb615584162b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b1ca5dd6461b116ea70d7df5815af0"><td class="memItemLeft" align="right" valign="top"><a id="ae7b1ca5dd6461b116ea70d7df5815af0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NodeSetVec</b> = std::vector&lt; std::pair&lt; double, NodeSet &gt; &gt;</td></tr>
<tr class="separator:ae7b1ca5dd6461b116ea70d7df5815af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef7defba86c55457de5ac3d6125a8e9"><td class="memItemLeft" align="right" valign="top"><a id="a6ef7defba86c55457de5ac3d6125a8e9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>AttribVecDouble</b> = <a class="el" href="classUtil_1_1AttribVec.html">Util::AttribVec</a>&lt; NodeID, double &gt;</td></tr>
<tr class="separator:a6ef7defba86c55457de5ac3d6125a8e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b9380c2dbea5baad233ec1fb4385ea"><td class="memItemLeft" align="right" valign="top"><a id="a39b9380c2dbea5baad233ec1fb4385ea"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NodeSetUnordered</b> = std::unordered_set&lt; <a class="el" href="classGeometry_1_1AMGraph.html#aff736ffe081b073bd0038f288ea03313">AMGraph::NodeID</a> &gt;</td></tr>
<tr class="separator:a39b9380c2dbea5baad233ec1fb4385ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4380037a07c5833e65549a289683ba"><td class="memItemLeft" align="right" valign="top"><a id="abb4380037a07c5833e65549a289683ba"></a>
typedef <a class="el" href="structGeometry_1_1POINT.html">POINT</a>&#160;</td><td class="memItemRight" valign="bottom"><b>VERTEX</b></td></tr>
<tr class="separator:abb4380037a07c5833e65549a289683ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071b83000207e0bf3993cd5466d72540"><td class="memItemLeft" align="right" valign="top"><a id="a071b83000207e0bf3993cd5466d72540"></a>
typedef <a class="el" href="structGeometry_1_1POINT.html">POINT</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NORMAL</b></td></tr>
<tr class="separator:a071b83000207e0bf3993cd5466d72540"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a5f59ba1075f703a4127c9eee6357e9fa"><td class="memItemLeft" align="right" valign="top"><a id="a5f59ba1075f703a4127c9eee6357e9fa"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ToTetraHedralize</b> { <b>TET</b> = 0
, <b>NOTET</b> = 1
 }</td></tr>
<tr class="separator:a5f59ba1075f703a4127c9eee6357e9fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad2b43115a344eb48c89bcb41a2dac30b"><td class="memItemLeft" align="right" valign="top"><a id="ad2b43115a344eb48c89bcb41a2dac30b"></a>
std::pair&lt; <a class="el" href="classCGLA_1_1Vec2d.html">CGLA::Vec2d</a>, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>triangle_circumcircle</b> (const std::array&lt; <a class="el" href="classCGLA_1_1Vec2d.html">CGLA::Vec2d</a>, 3 &gt; &amp;pts)</td></tr>
<tr class="separator:ad2b43115a344eb48c89bcb41a2dac30b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc91ca29db0093ace5a09ee3ae78078c"><td class="memItemLeft" align="right" valign="top"><a id="abc91ca29db0093ace5a09ee3ae78078c"></a>
std::pair&lt; <a class="el" href="classCGLA_1_1Vec3d.html">CGLA::Vec3d</a>, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>tetrahedron_circumsphere</b> (const std::array&lt; <a class="el" href="classCGLA_1_1Vec3d.html">CGLA::Vec3d</a>, 4 &gt; &amp;pts)</td></tr>
<tr class="separator:abc91ca29db0093ace5a09ee3ae78078c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea283e861c44cd507f59fcf907e745a9"><td class="memItemLeft" align="right" valign="top"><a id="aea283e861c44cd507f59fcf907e745a9"></a>
std::pair&lt; <a class="el" href="classCGLA_1_1Vec3d.html">CGLA::Vec3d</a>, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>bounding_sphere</b> (const std::vector&lt; <a class="el" href="classCGLA_1_1Vec3d.html">CGLA::Vec3d</a> &gt; &amp;pts)</td></tr>
<tr class="separator:aea283e861c44cd507f59fcf907e745a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3d828c730a5c0d208aec01413bb23f"><td class="memItemLeft" align="right" valign="top"><a id="a8a3d828c730a5c0d208aec01413bb23f"></a>
std::pair&lt; <a class="el" href="classCGLA_1_1Vec3d.html">CGLA::Vec3d</a>, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>approximate_bounding_sphere</b> (const std::vector&lt; <a class="el" href="classCGLA_1_1Vec3d.html">CGLA::Vec3d</a> &gt; &amp;pts)</td></tr>
<tr class="separator:a8a3d828c730a5c0d208aec01413bb23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899b70420dbb128c33abd98636e5a1d9"><td class="memItemLeft" align="right" valign="top"><a id="a899b70420dbb128c33abd98636e5a1d9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>build_OBBTree</b> (<a class="el" href="classHMesh_1_1Manifold.html">HMesh::Manifold</a> &amp;m, <a class="el" href="classGeometry_1_1BoundingTree.html">OBBTree</a> &amp;tree)</td></tr>
<tr class="separator:a899b70420dbb128c33abd98636e5a1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec26a50bd3f39fb77a1e7b91c4024eb"><td class="memItemLeft" align="right" valign="top"><a id="aeec26a50bd3f39fb77a1e7b91c4024eb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>build_AABBTree</b> (<a class="el" href="classHMesh_1_1Manifold.html">HMesh::Manifold</a> &amp;m, <a class="el" href="classGeometry_1_1BoundingTree.html">AABBTree</a> &amp;tree)</td></tr>
<tr class="separator:aeec26a50bd3f39fb77a1e7b91c4024eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8cb2aa638d1c9d6c01095d41d1c9d3"><td class="memItemLeft" align="right" valign="top"><a id="a9c8cb2aa638d1c9d6c01095d41d1c9d3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="structGeometry_1_1PrimPQElem.html">PrimPQElem</a> &amp;p0, const <a class="el" href="structGeometry_1_1PrimPQElem.html">PrimPQElem</a> &amp;p1)</td></tr>
<tr class="separator:a9c8cb2aa638d1c9d6c01095d41d1c9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803eca22b2674de996b24bab6024dcd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#a803eca22b2674de996b24bab6024dcd4">clean_graph</a> (const <a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;g)</td></tr>
<tr class="memdesc:a803eca22b2674de996b24bab6024dcd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up graph, removing unused nodes and edges.  <a href="namespaceGeometry.html#a803eca22b2674de996b24bab6024dcd4">More...</a><br /></td></tr>
<tr class="separator:a803eca22b2674de996b24bab6024dcd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2ea44c44e75ba22216b4a795fd7a7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#a9f2ea44c44e75ba22216b4a795fd7a7c">minimum_spanning_tree</a> (const <a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;, <a class="el" href="classGeometry_1_1AMGraph.html#aff736ffe081b073bd0038f288ea03313">AMGraph::NodeID</a> root=<a class="el" href="classGeometry_1_1AMGraph.html#a8cb0932f79bd2ff91a17c0c82e3911d6">AMGraph::InvalidNodeID</a>)</td></tr>
<tr class="memdesc:a9f2ea44c44e75ba22216b4a795fd7a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum spanning tree of the argument using Prim's algorithm and returns the resulting graph.  <a href="namespaceGeometry.html#a9f2ea44c44e75ba22216b4a795fd7a7c">More...</a><br /></td></tr>
<tr class="separator:a9f2ea44c44e75ba22216b4a795fd7a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6091b4e18030804fc3b1249420709abf"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classGeometry_1_1AMGraph.html#a45bfc4e413454ca81d6cd1839d5c2bc9">AMGraph::NodeSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#a6091b4e18030804fc3b1249420709abf">connected_components</a> (const <a class="el" href="classGeometry_1_1AMGraph.html">AMGraph</a> &amp;g, const <a class="el" href="classGeometry_1_1AMGraph.html#a45bfc4e413454ca81d6cd1839d5c2bc9">AMGraph::NodeSet</a> &amp;s)</td></tr>
<tr class="memdesc:a6091b4e18030804fc3b1249420709abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a NodeSet s, split s into connected components and return those in a vector.  <a href="namespaceGeometry.html#a6091b4e18030804fc3b1249420709abf">More...</a><br /></td></tr>
<tr class="separator:a6091b4e18030804fc3b1249420709abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6bd8a43dc0428e91e295d69145a05c"><td class="memItemLeft" align="right" valign="top"><a id="a5f6bd8a43dc0428e91e295d69145a05c"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>vertex_separator_curvature</b> (const <a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;g, const <a class="el" href="classGeometry_1_1AMGraph.html#a45bfc4e413454ca81d6cd1839d5c2bc9">AMGraph::NodeSet</a> &amp;s, const <a class="el" href="classUtil_1_1AttribVec.html">Util::AttribVec</a>&lt; <a class="el" href="classGeometry_1_1AMGraph.html#aff736ffe081b073bd0038f288ea03313">AMGraph::NodeID</a>, int &gt; &amp;t_out)</td></tr>
<tr class="separator:a5f6bd8a43dc0428e91e295d69145a05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a81c5ba7b313660b9f21418c0c3a1f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#a3a81c5ba7b313660b9f21418c0c3a1f4">graph_load</a> (const std::string &amp;file_name)</td></tr>
<tr class="memdesc:a3a81c5ba7b313660b9f21418c0c3a1f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a graph from a file.  <a href="namespaceGeometry.html#a3a81c5ba7b313660b9f21418c0c3a1f4">More...</a><br /></td></tr>
<tr class="separator:a3a81c5ba7b313660b9f21418c0c3a1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f446c66e5c8f2f35aa4b8a26e4a319"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#ac4f446c66e5c8f2f35aa4b8a26e4a319">graph_save</a> (const std::string &amp;file_name, const <a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;g)</td></tr>
<tr class="memdesc:ac4f446c66e5c8f2f35aa4b8a26e4a319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a graph to a file.  <a href="namespaceGeometry.html#ac4f446c66e5c8f2f35aa4b8a26e4a319">More...</a><br /></td></tr>
<tr class="separator:ac4f446c66e5c8f2f35aa4b8a26e4a319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425f591ca0937c45df65dc74ce7af6a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#a425f591ca0937c45df65dc74ce7af6a3">graph_from_points</a> (const std::string &amp;file_name, double rad, int N_closest)</td></tr>
<tr class="memdesc:a425f591ca0937c45df65dc74ce7af6a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a point set from a file and convert to a graph.  <a href="namespaceGeometry.html#a425f591ca0937c45df65dc74ce7af6a3">More...</a><br /></td></tr>
<tr class="separator:a425f591ca0937c45df65dc74ce7af6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33e2c405efb457544c915ca6e09a7ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#aa33e2c405efb457544c915ca6e09a7ec">graph_to_mesh_iso</a> (const <a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;g, <a class="el" href="classHMesh_1_1Manifold.html">HMesh::Manifold</a> &amp;m, size_t grid_res, float fudge, float tau)</td></tr>
<tr class="memdesc:aa33e2c405efb457544c915ca6e09a7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a graph to a mesh using convolution surfaces.  <a href="namespaceGeometry.html#aa33e2c405efb457544c915ca6e09a7ec">More...</a><br /></td></tr>
<tr class="separator:aa33e2c405efb457544c915ca6e09a7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada16be80a3c7361258e362b34e863ce6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#ada16be80a3c7361258e362b34e863ce6">graph_to_mesh_cyl</a> (const <a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;g, <a class="el" href="classHMesh_1_1Manifold.html">HMesh::Manifold</a> &amp;m, float fudge)</td></tr>
<tr class="memdesc:ada16be80a3c7361258e362b34e863ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a graph to a mesh using cone stubs.  <a href="namespaceGeometry.html#ada16be80a3c7361258e362b34e863ce6">More...</a><br /></td></tr>
<tr class="separator:ada16be80a3c7361258e362b34e863ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243a21969755d20ef7dd70ade63069f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#a243a21969755d20ef7dd70ade63069f8">graph_save_ply</a> (const std::string &amp;fn, const <a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;g)</td></tr>
<tr class="memdesc:a243a21969755d20ef7dd70ade63069f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a graph in the ply format.  <a href="namespaceGeometry.html#a243a21969755d20ef7dd70ade63069f8">More...</a><br /></td></tr>
<tr class="separator:a243a21969755d20ef7dd70ade63069f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34fe57c2e27160c797245b192a890b1e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#a34fe57c2e27160c797245b192a890b1e">ply_load</a> (const std::string &amp;fn, <a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;_graph)</td></tr>
<tr class="memdesc:a34fe57c2e27160c797245b192a890b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the graph from a PLY file - assuming the edges are explcitly encoded!  <a href="namespaceGeometry.html#a34fe57c2e27160c797245b192a890b1e">More...</a><br /></td></tr>
<tr class="separator:a34fe57c2e27160c797245b192a890b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa899aa2f3873cd1eb42d67762e14b1dd"><td class="memItemLeft" align="right" valign="top">NodeSetVec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#aa899aa2f3873cd1eb42d67762e14b1dd">front_separators</a> (<a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;g, const std::vector&lt; <a class="el" href="classUtil_1_1AttribVec.html">AttribVecDouble</a> &gt; &amp;dvv)</td></tr>
<tr class="memdesc:aa899aa2f3873cd1eb42d67762e14b1dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute separators by marching a front along a scalar field.  <a href="namespaceGeometry.html#aa899aa2f3873cd1eb42d67762e14b1dd">More...</a><br /></td></tr>
<tr class="separator:aa899aa2f3873cd1eb42d67762e14b1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a408763e93259b49e00adc2cecc69a659"><td class="memItemLeft" align="right" valign="top">std::pair&lt; double, NodeSet &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#a408763e93259b49e00adc2cecc69a659">local_separator</a> (<a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;g, NodeID n0, double quality_noise_level, int optimization_steps)</td></tr>
<tr class="memdesc:a408763e93259b49e00adc2cecc69a659"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given graph, g, and a given node n0, we compute a local separator.  <a href="namespaceGeometry.html#a408763e93259b49e00adc2cecc69a659">More...</a><br /></td></tr>
<tr class="separator:a408763e93259b49e00adc2cecc69a659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b816419d973153f050f147ff6363f8"><td class="memItemLeft" align="right" valign="top">NodeSetVec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#a87b816419d973153f050f147ff6363f8">local_separators</a> (<a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;g, bool sampling=false, double quality_noise_level=0.09, int optimization_steps=0)</td></tr>
<tr class="memdesc:a87b816419d973153f050f147ff6363f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a set of local separators from the input graph.  <a href="namespaceGeometry.html#a87b816419d973153f050f147ff6363f8">More...</a><br /></td></tr>
<tr class="separator:a87b816419d973153f050f147ff6363f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e09438f079533770ffd7f41ab7d5462"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a>, <a class="el" href="classUtil_1_1AttribVec.html">Util::AttribVec</a>&lt; <a class="el" href="classGeometry_1_1AMGraph.html#aff736ffe081b073bd0038f288ea03313">AMGraph3D::NodeID</a>, <a class="el" href="classGeometry_1_1AMGraph.html#aff736ffe081b073bd0038f288ea03313">AMGraph3D::NodeID</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#a8e09438f079533770ffd7f41ab7d5462">skeleton_from_node_set_vec</a> (<a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;g, const NodeSetVec &amp;node_set_vec, bool merge=true, int smooth_steps=0)</td></tr>
<tr class="memdesc:a8e09438f079533770ffd7f41ab7d5462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of (non-overlapping) node sets to a skeleton graph.  <a href="namespaceGeometry.html#a8e09438f079533770ffd7f41ab7d5462">More...</a><br /></td></tr>
<tr class="separator:a8e09438f079533770ffd7f41ab7d5462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a262095996d764f7d3639d7d0506cd560"><td class="memItemLeft" align="right" valign="top">NodeSetVec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#a262095996d764f7d3639d7d0506cd560">maximize_node_set_vec</a> (<a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;g, const NodeSetVec &amp;node_set_vec)</td></tr>
<tr class="memdesc:a262095996d764f7d3639d7d0506cd560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a set of nodes into a set that partitions the graph.  <a href="namespaceGeometry.html#a262095996d764f7d3639d7d0506cd560">More...</a><br /></td></tr>
<tr class="separator:a262095996d764f7d3639d7d0506cd560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fc270d803250d35a499cb1e7aa2cf0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#a12fc270d803250d35a499cb1e7aa2cf0">test_intersection</a> (const <a class="el" href="classGeometry_1_1AMGraph.html#a45bfc4e413454ca81d6cd1839d5c2bc9">AMGraph3D::NodeSet</a> &amp;set1, const <a class="el" href="classGeometry_1_1AMGraph.html#a45bfc4e413454ca81d6cd1839d5c2bc9">AMGraph3D::NodeSet</a> &amp;set2)</td></tr>
<tr class="memdesc:a12fc270d803250d35a499cb1e7aa2cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear time counting of the number of shared members of set1 and set2.  <a href="namespaceGeometry.html#a12fc270d803250d35a499cb1e7aa2cf0">More...</a><br /></td></tr>
<tr class="separator:a12fc270d803250d35a499cb1e7aa2cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0556baae64fbb03007d542383f98bf9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; NodeSetUnordered &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#aa0556baae64fbb03007d542383f98bf9">connected_components</a> (const <a class="el" href="classGeometry_1_1AMGraph.html">AMGraph</a> &amp;g, const NodeSetUnordered &amp;s)</td></tr>
<tr class="memdesc:aa0556baae64fbb03007d542383f98bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the connected components of set s.  <a href="namespaceGeometry.html#aa0556baae64fbb03007d542383f98bf9">More...</a><br /></td></tr>
<tr class="separator:aa0556baae64fbb03007d542383f98bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46bdacfd733d8a612a4ff09efe105a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classUtil_1_1AttribVec.html">AttribVecDouble</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#ab46bdacfd733d8a612a4ff09efe105a2">smooth_dist</a> (const <a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;g, const <a class="el" href="classUtil_1_1AttribVec.html">AttribVecDouble</a> &amp;dist, int smooth_iter=0)</td></tr>
<tr class="memdesc:ab46bdacfd733d8a612a4ff09efe105a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smooth the attributes in dist associated with graph g smooth_iter times.  <a href="namespaceGeometry.html#ab46bdacfd733d8a612a4ff09efe105a2">More...</a><br /></td></tr>
<tr class="separator:ab46bdacfd733d8a612a4ff09efe105a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b352deb9d4983a957a55204c949ad0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classUtil_1_1AttribVec.html">AttribVecDouble</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#a70b352deb9d4983a957a55204c949ad0">projection</a> (const <a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;g, const <a class="el" href="classCGLA_1_1Vec3d.html">CGLA::Vec3d</a> &amp;dir, int smooth_iter=0)</td></tr>
<tr class="memdesc:a70b352deb9d4983a957a55204c949ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project the vertex positions of g onto vector dir and return the attribute vector containing the result smoothed smooth_iter times.  <a href="namespaceGeometry.html#a70b352deb9d4983a957a55204c949ad0">More...</a><br /></td></tr>
<tr class="separator:a70b352deb9d4983a957a55204c949ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0023a7dab38c9b01d3493da349764298"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classUtil_1_1AttribVec.html">AttribVecDouble</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#a0023a7dab38c9b01d3493da349764298">negate_dist</a> (const <a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;g, const <a class="el" href="classUtil_1_1AttribVec.html">AttribVecDouble</a> &amp;dist_in)</td></tr>
<tr class="memdesc:a0023a7dab38c9b01d3493da349764298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the attributes in dist_in but negated.  <a href="namespaceGeometry.html#a0023a7dab38c9b01d3493da349764298">More...</a><br /></td></tr>
<tr class="separator:a0023a7dab38c9b01d3493da349764298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0886ca3c7d6d2751a86e8baff676de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#a9c0886ca3c7d6d2751a86e8baff676de">saturate_graph</a> (<a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;g, int hops, double dist_frac=1.0001, double rad=1e300)</td></tr>
<tr class="memdesc:a9c0886ca3c7d6d2751a86e8baff676de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add edges to g.  <a href="namespaceGeometry.html#a9c0886ca3c7d6d2751a86e8baff676de">More...</a><br /></td></tr>
<tr class="separator:a9c0886ca3c7d6d2751a86e8baff676de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17b128890e3cb227e313cf93c99a169"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#ae17b128890e3cb227e313cf93c99a169">mcm_smooth_graph</a> (<a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;g, const int iter, const float alpha)</td></tr>
<tr class="memdesc:ae17b128890e3cb227e313cf93c99a169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mean curvature motion smoothing.  <a href="namespaceGeometry.html#ae17b128890e3cb227e313cf93c99a169">More...</a><br /></td></tr>
<tr class="separator:ae17b128890e3cb227e313cf93c99a169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44273334e4bbe146fc33060b3323a592"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#a44273334e4bbe146fc33060b3323a592">smooth_graph</a> (<a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;g, const int iter, const float alpha)</td></tr>
<tr class="memdesc:a44273334e4bbe146fc33060b3323a592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple Laplacian graph smoothing. iter specifies number of iterations, and alpha in range [0..1] is the weight.  <a href="namespaceGeometry.html#a44273334e4bbe146fc33060b3323a592">More...</a><br /></td></tr>
<tr class="separator:a44273334e4bbe146fc33060b3323a592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c10516264805691979b8256f10c849e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#a7c10516264805691979b8256f10c849e">graph_edge_contract</a> (<a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;g, double dist_thresh)</td></tr>
<tr class="memdesc:a7c10516264805691979b8256f10c849e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contracts edges in the graph g shorter than dist_thresh. A priority queue is used to contract shorter edges first.  <a href="namespaceGeometry.html#a7c10516264805691979b8256f10c849e">More...</a><br /></td></tr>
<tr class="separator:a7c10516264805691979b8256f10c849e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e9ab6ead2925de7711775bbdc7763b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#ac7e9ab6ead2925de7711775bbdc7763b">prune</a> (<a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;g)</td></tr>
<tr class="memdesc:ac7e9ab6ead2925de7711775bbdc7763b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function unceremoniously removes leaf vertices if they share an edge with a vertex that has valence greater than two.  <a href="namespaceGeometry.html#ac7e9ab6ead2925de7711775bbdc7763b">More...</a><br /></td></tr>
<tr class="separator:ac7e9ab6ead2925de7711775bbdc7763b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d972bf34c3f7f24e1bb78a477c291d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#a3d972bf34c3f7f24e1bb78a477c291d0">color_graph_node_sets</a> (<a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;g, const NodeSetVec &amp;node_set_vec)</td></tr>
<tr class="memdesc:a3d972bf34c3f7f24e1bb78a477c291d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the same (random) color to all nodes in node_set_vec.  <a href="namespaceGeometry.html#a3d972bf34c3f7f24e1bb78a477c291d0">More...</a><br /></td></tr>
<tr class="separator:a3d972bf34c3f7f24e1bb78a477c291d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac91c60ea3176331afb6f49302bda891"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGLA_1_1Vec3d.html">CGLA::Vec3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#aac91c60ea3176331afb6f49302bda891">geometric_median</a> (const std::vector&lt; <a class="el" href="classCGLA_1_1Vec3d.html">CGLA::Vec3d</a> &gt; &amp;pts)</td></tr>
<tr class="memdesc:aac91c60ea3176331afb6f49302bda891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the point that minimizes the sum of distance to the input points (given in pts).  <a href="namespaceGeometry.html#aac91c60ea3176331afb6f49302bda891">More...</a><br /></td></tr>
<tr class="separator:aac91c60ea3176331afb6f49302bda891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace102b2e49c1441880424026f490bc13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#ace102b2e49c1441880424026f490bc13">voxel_graph_from_mesh</a> (<a class="el" href="classHMesh_1_1Manifold.html">HMesh::Manifold</a> &amp;m, int res)</td></tr>
<tr class="memdesc:ace102b2e49c1441880424026f490bc13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a graph of voxels from input mesh.  <a href="namespaceGeometry.html#ace102b2e49c1441880424026f490bc13">More...</a><br /></td></tr>
<tr class="separator:ace102b2e49c1441880424026f490bc13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9803044c149c41e5cfee4baf7119825"><td class="memItemLeft" align="right" valign="top">NodeSet&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#ab9803044c149c41e5cfee4baf7119825">order</a> (NodeSetUnordered &amp;s)</td></tr>
<tr class="memdesc:ab9803044c149c41e5cfee4baf7119825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a node set from unordered representation to ordered.  <a href="namespaceGeometry.html#ab9803044c149c41e5cfee4baf7119825">More...</a><br /></td></tr>
<tr class="separator:ab9803044c149c41e5cfee4baf7119825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20ed7bceb4c81be99aeb6699a6a93aa"><td class="memItemLeft" align="right" valign="top">NodeSetUnordered&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#ae20ed7bceb4c81be99aeb6699a6a93aa">neighbors</a> (const <a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;g, const NodeSetUnordered &amp;s)</td></tr>
<tr class="memdesc:ae20ed7bceb4c81be99aeb6699a6a93aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the neighbors of s in g. In other words it returns the set of nodes that are connected to s but do not belong to s.  <a href="namespaceGeometry.html#ae20ed7bceb4c81be99aeb6699a6a93aa">More...</a><br /></td></tr>
<tr class="separator:ae20ed7bceb4c81be99aeb6699a6a93aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c633125eda1f3565b17ac488744f7d3"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classCGLA_1_1Vec3d.html">CGLA::Vec3d</a>, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#a6c633125eda1f3565b17ac488744f7d3">approximate_bounding_sphere</a> (const <a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;g, const NodeSetUnordered &amp;s=NodeSetUnordered({}))</td></tr>
<tr class="memdesc:a6c633125eda1f3565b17ac488744f7d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the approximate bounding sphere for the nodes in graph g optionally restricted to the node set passed as second argument.  <a href="namespaceGeometry.html#a6c633125eda1f3565b17ac488744f7d3">More...</a><br /></td></tr>
<tr class="separator:a6c633125eda1f3565b17ac488744f7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedae255ca15db2363ef55a60fb9188de"><td class="memItemLeft" align="right" valign="top">NodeSetVec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#aedae255ca15db2363ef55a60fb9188de">k_means_node_clusters</a> (<a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;g, int N, int MAX_ITER)</td></tr>
<tr class="memdesc:aedae255ca15db2363ef55a60fb9188de"><td class="mdescLeft">&#160;</td><td class="mdescRight">k means clustering of graph nodes  <a href="namespaceGeometry.html#aedae255ca15db2363ef55a60fb9188de">More...</a><br /></td></tr>
<tr class="separator:aedae255ca15db2363ef55a60fb9188de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e20bc0267a7045ec3b56093777459e2"><td class="memItemLeft" align="right" valign="top">std::pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#a4e20bc0267a7045ec3b56093777459e2">graph_H_dist</a> (const <a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;g0, const <a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;g1, size_t samples=10000)</td></tr>
<tr class="memdesc:a4e20bc0267a7045ec3b56093777459e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the distance at samples points from graph g0 to g1 and vice versa.  <a href="namespaceGeometry.html#a4e20bc0267a7045ec3b56093777459e2">More...</a><br /></td></tr>
<tr class="separator:a4e20bc0267a7045ec3b56093777459e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cdb29d3fe05cf8387de40aa1e0e1c4a"><td class="memTemplParams" colspan="2"><a id="a9cdb29d3fe05cf8387de40aa1e0e1c4a"></a>
template&lt;class T , class F &gt; </td></tr>
<tr class="memitem:a9cdb29d3fe05cf8387de40aa1e0e1c4a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_for_each_voxel</b> (T *data, int x_dim, int xy_dim, const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a> &amp;p0, const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a> &amp;p7, F &amp;functor, const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a> &amp;offset=<a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a>(0))</td></tr>
<tr class="separator:a9cdb29d3fe05cf8387de40aa1e0e1c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14cb4c1a35d68fbe3200d11547a74a69"><td class="memTemplParams" colspan="2"><a id="a14cb4c1a35d68fbe3200d11547a74a69"></a>
template&lt;class T , class F &gt; </td></tr>
<tr class="memitem:a14cb4c1a35d68fbe3200d11547a74a69"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>_for_each_voxel</b> (T *data, const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a> &amp;dims, F &amp;functor, const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a> &amp;offset=<a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a>(0))</td></tr>
<tr class="separator:a14cb4c1a35d68fbe3200d11547a74a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb810b759c250814926ba207ae34aa95"><td class="memTemplParams" colspan="2">template&lt;class T , class F &gt; </td></tr>
<tr class="memitem:adb810b759c250814926ba207ae34aa95"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#adb810b759c250814926ba207ae34aa95">for_each_voxel</a> (<a class="el" href="classGeometry_1_1RGrid.html">RGrid</a>&lt; T &gt; &amp;grid, const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a> &amp;p0, const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a> &amp;p7, F &amp;functor)</td></tr>
<tr class="memdesc:adb810b759c250814926ba207ae34aa95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loop over all voxels in a sub-region (slice) of an <a class="el" href="classGeometry_1_1RGrid.html" title="Regular voxel grid.">RGrid</a> and invoke a functor on each voxel.  <a href="namespaceGeometry.html#adb810b759c250814926ba207ae34aa95">More...</a><br /></td></tr>
<tr class="separator:adb810b759c250814926ba207ae34aa95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a909f82107e9265db99734cebf0b087"><td class="memTemplParams" colspan="2">template&lt;class T , class F &gt; </td></tr>
<tr class="memitem:a6a909f82107e9265db99734cebf0b087"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#a6a909f82107e9265db99734cebf0b087">for_each_voxel</a> (<a class="el" href="classGeometry_1_1RGrid.html">RGrid</a>&lt; T &gt; &amp;grid, F &amp;functor)</td></tr>
<tr class="memdesc:a6a909f82107e9265db99734cebf0b087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loop over all voxels in an entire <a class="el" href="classGeometry_1_1RGrid.html" title="Regular voxel grid.">RGrid</a>.  <a href="namespaceGeometry.html#a6a909f82107e9265db99734cebf0b087">More...</a><br /></td></tr>
<tr class="separator:a6a909f82107e9265db99734cebf0b087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f72bd1a4a6a1a9e42c4881afe481aa"><td class="memTemplParams" colspan="2">template&lt;class T , class F &gt; </td></tr>
<tr class="memitem:a06f72bd1a4a6a1a9e42c4881afe481aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#a06f72bd1a4a6a1a9e42c4881afe481aa">for_each_voxel_ordered</a> (<a class="el" href="classGeometry_1_1RGrid.html">RGrid</a>&lt; T &gt; &amp;grid, const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a> &amp;p0, const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a> &amp;p7, F &amp;functor)</td></tr>
<tr class="memdesc:a06f72bd1a4a6a1a9e42c4881afe481aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each voxel (ordered).  <a href="namespaceGeometry.html#a06f72bd1a4a6a1a9e42c4881afe481aa">More...</a><br /></td></tr>
<tr class="separator:a06f72bd1a4a6a1a9e42c4881afe481aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6ff9a4b82b8568b37eada78c64e10a"><td class="memTemplParams" colspan="2"><a id="add6ff9a4b82b8568b37eada78c64e10a"></a>
template&lt;class T , class F &gt; </td></tr>
<tr class="memitem:add6ff9a4b82b8568b37eada78c64e10a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>for_each_voxel_ordered</b> (<a class="el" href="classGeometry_1_1RGrid.html">RGrid</a>&lt; T &gt; &amp;grid, F &amp;functor)</td></tr>
<tr class="separator:add6ff9a4b82b8568b37eada78c64e10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d3f43bd110212ad2dc41132774984b"><td class="memTemplParams" colspan="2"><a id="a19d3f43bd110212ad2dc41132774984b"></a>
template&lt;class T , class CellT , class F &gt; </td></tr>
<tr class="memitem:a19d3f43bd110212ad2dc41132774984b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>for_each_cell</b> (<a class="el" href="classGeometry_1_1HGrid.html">HGrid</a>&lt; T, CellT &gt; &amp;grid, const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a> &amp;p0, const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a> &amp;p7, F &amp;functor)</td></tr>
<tr class="separator:a19d3f43bd110212ad2dc41132774984b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f0d2847daffff29dcd90b13d5faf1e"><td class="memTemplParams" colspan="2"><a id="a99f0d2847daffff29dcd90b13d5faf1e"></a>
template&lt;class T , class CellT , class F &gt; </td></tr>
<tr class="memitem:a99f0d2847daffff29dcd90b13d5faf1e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>for_each_cell</b> (<a class="el" href="classGeometry_1_1HGrid.html">HGrid</a>&lt; T, CellT &gt; &amp;grid, F &amp;functor)</td></tr>
<tr class="separator:a99f0d2847daffff29dcd90b13d5faf1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27786d9b14b96d350dbcc6258e7cc322"><td class="memTemplParams" colspan="2"><a id="a27786d9b14b96d350dbcc6258e7cc322"></a>
template&lt;class T , class CellT , class F &gt; </td></tr>
<tr class="memitem:a27786d9b14b96d350dbcc6258e7cc322"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>for_each_voxel</b> (<a class="el" href="classGeometry_1_1HGrid.html">HGrid</a>&lt; T, CellT &gt; &amp;grid, const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a> &amp;_p0, const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a> &amp;_p7, F &amp;functor)</td></tr>
<tr class="separator:a27786d9b14b96d350dbcc6258e7cc322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaddfa26aad4309f68f1fa707ba1b963"><td class="memTemplParams" colspan="2"><a id="acaddfa26aad4309f68f1fa707ba1b963"></a>
template&lt;class T , class CellT , class F &gt; </td></tr>
<tr class="memitem:acaddfa26aad4309f68f1fa707ba1b963"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>for_each_voxel</b> (<a class="el" href="classGeometry_1_1HGrid.html">HGrid</a>&lt; T, CellT &gt; &amp;grid, F &amp;functor)</td></tr>
<tr class="separator:acaddfa26aad4309f68f1fa707ba1b963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32bc48bd7d745762438290be770c8979"><td class="memTemplParams" colspan="2"><a id="a32bc48bd7d745762438290be770c8979"></a>
template&lt;class T , class CellT , class F &gt; </td></tr>
<tr class="memitem:a32bc48bd7d745762438290be770c8979"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>for_each_voxel_ordered</b> (<a class="el" href="classGeometry_1_1HGrid.html">HGrid</a>&lt; T, CellT &gt; &amp;grid, const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a> &amp;_p0, const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a> &amp;_p7, F &amp;functor)</td></tr>
<tr class="separator:a32bc48bd7d745762438290be770c8979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51bb5d0081dac0069b26ee78691c232"><td class="memTemplParams" colspan="2"><a id="aa51bb5d0081dac0069b26ee78691c232"></a>
template&lt;class T , class CellT , class F &gt; </td></tr>
<tr class="memitem:aa51bb5d0081dac0069b26ee78691c232"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>for_each_voxel_ordered</b> (<a class="el" href="classGeometry_1_1HGrid.html">HGrid</a>&lt; T, CellT &gt; &amp;grid, F &amp;functor)</td></tr>
<tr class="separator:aa51bb5d0081dac0069b26ee78691c232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9da85dcb99d09d205f5d6742d618fa"><td class="memTemplParams" colspan="2"><a id="a0e9da85dcb99d09d205f5d6742d618fa"></a>
template&lt;class G &gt; </td></tr>
<tr class="memitem:a0e9da85dcb99d09d205f5d6742d618fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>clear_region</b> (G &amp;grid, const typename G::DataType &amp;value)</td></tr>
<tr class="separator:a0e9da85dcb99d09d205f5d6742d618fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd765a3e1ec96cee25576e365146305"><td class="memTemplParams" colspan="2"><a id="abfd765a3e1ec96cee25576e365146305"></a>
template&lt;class G &gt; </td></tr>
<tr class="memitem:abfd765a3e1ec96cee25576e365146305"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>clear_region</b> (G &amp;grid, const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a> &amp;p0, const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a> &amp;p7, const typename G::DataType &amp;value)</td></tr>
<tr class="separator:abfd765a3e1ec96cee25576e365146305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae902bb059a3dd1e321f970e6048e1a89"><td class="memTemplParams" colspan="2">template&lt;class T , class F &gt; </td></tr>
<tr class="memitem:ae902bb059a3dd1e321f970e6048e1a89"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#ae902bb059a3dd1e321f970e6048e1a89">for_each_voxel_const</a> (const <a class="el" href="classGeometry_1_1RGrid.html">RGrid</a>&lt; T &gt; &amp;grid, const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a> &amp;p0, const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a> &amp;p7, F &amp;functor)</td></tr>
<tr class="memdesc:ae902bb059a3dd1e321f970e6048e1a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loop over all voxels in a sub-region (slice) of an <a class="el" href="classGeometry_1_1RGrid.html" title="Regular voxel grid.">RGrid</a> and invoke a functor on each voxel.  <a href="namespaceGeometry.html#ae902bb059a3dd1e321f970e6048e1a89">More...</a><br /></td></tr>
<tr class="separator:ae902bb059a3dd1e321f970e6048e1a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829bee6c0da33b746edc933c2d38ddd2"><td class="memTemplParams" colspan="2">template&lt;class T , class F &gt; </td></tr>
<tr class="memitem:a829bee6c0da33b746edc933c2d38ddd2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#a829bee6c0da33b746edc933c2d38ddd2">for_each_voxel_const</a> (const <a class="el" href="classGeometry_1_1RGrid.html">RGrid</a>&lt; T &gt; &amp;grid, F &amp;functor)</td></tr>
<tr class="memdesc:a829bee6c0da33b746edc933c2d38ddd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loop over all voxels in an entire <a class="el" href="classGeometry_1_1RGrid.html" title="Regular voxel grid.">RGrid</a>.  <a href="namespaceGeometry.html#a829bee6c0da33b746edc933c2d38ddd2">More...</a><br /></td></tr>
<tr class="separator:a829bee6c0da33b746edc933c2d38ddd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359cfa6d1e893deaf90b0a43a387959a"><td class="memTemplParams" colspan="2">template&lt;class T , class F &gt; </td></tr>
<tr class="memitem:a359cfa6d1e893deaf90b0a43a387959a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#a359cfa6d1e893deaf90b0a43a387959a">for_each_voxel_ordered_const</a> (const <a class="el" href="classGeometry_1_1RGrid.html">RGrid</a>&lt; T &gt; &amp;grid, const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a> &amp;p0, const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a> &amp;p7, F &amp;functor)</td></tr>
<tr class="memdesc:a359cfa6d1e893deaf90b0a43a387959a"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each voxel (ordered).  <a href="namespaceGeometry.html#a359cfa6d1e893deaf90b0a43a387959a">More...</a><br /></td></tr>
<tr class="separator:a359cfa6d1e893deaf90b0a43a387959a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892761cc1d439e89c2416cbec2c792dc"><td class="memTemplParams" colspan="2"><a id="a892761cc1d439e89c2416cbec2c792dc"></a>
template&lt;class T , class F &gt; </td></tr>
<tr class="memitem:a892761cc1d439e89c2416cbec2c792dc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>for_each_voxel_ordered_const</b> (const <a class="el" href="classGeometry_1_1RGrid.html">RGrid</a>&lt; T &gt; &amp;grid, F &amp;functor)</td></tr>
<tr class="separator:a892761cc1d439e89c2416cbec2c792dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c6329f73739f0b14aaa432ce19d30c"><td class="memTemplParams" colspan="2"><a id="a97c6329f73739f0b14aaa432ce19d30c"></a>
template&lt;class T , class CellT , class F &gt; </td></tr>
<tr class="memitem:a97c6329f73739f0b14aaa432ce19d30c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>for_each_cell_const</b> (const <a class="el" href="classGeometry_1_1HGrid.html">HGrid</a>&lt; T, CellT &gt; &amp;grid, const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a> &amp;p0, const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a> &amp;p7, F &amp;functor)</td></tr>
<tr class="separator:a97c6329f73739f0b14aaa432ce19d30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e772804cf5b94a79cfdd8157d4005b6"><td class="memTemplParams" colspan="2"><a id="a9e772804cf5b94a79cfdd8157d4005b6"></a>
template&lt;class T , class CellT , class F &gt; </td></tr>
<tr class="memitem:a9e772804cf5b94a79cfdd8157d4005b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>for_each_cell_const</b> (const <a class="el" href="classGeometry_1_1HGrid.html">HGrid</a>&lt; T, CellT &gt; &amp;grid, F &amp;functor)</td></tr>
<tr class="separator:a9e772804cf5b94a79cfdd8157d4005b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eeb5bfa34eaa3f909fd73cdcd2b2937"><td class="memTemplParams" colspan="2"><a id="a9eeb5bfa34eaa3f909fd73cdcd2b2937"></a>
template&lt;class T , class CellT , class F &gt; </td></tr>
<tr class="memitem:a9eeb5bfa34eaa3f909fd73cdcd2b2937"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>for_each_voxel_const</b> (const <a class="el" href="classGeometry_1_1HGrid.html">HGrid</a>&lt; T, CellT &gt; &amp;grid, const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a> &amp;_p0, const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a> &amp;_p7, F &amp;functor)</td></tr>
<tr class="separator:a9eeb5bfa34eaa3f909fd73cdcd2b2937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd1ebe3e3a6ca442f1e2c624347944f"><td class="memTemplParams" colspan="2"><a id="a7dd1ebe3e3a6ca442f1e2c624347944f"></a>
template&lt;class T , class CellT , class F &gt; </td></tr>
<tr class="memitem:a7dd1ebe3e3a6ca442f1e2c624347944f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>for_each_voxel_const</b> (const <a class="el" href="classGeometry_1_1HGrid.html">HGrid</a>&lt; T, CellT &gt; &amp;grid, F &amp;functor)</td></tr>
<tr class="separator:a7dd1ebe3e3a6ca442f1e2c624347944f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d34e069edd0332fed13881562d933d"><td class="memTemplParams" colspan="2"><a id="ae9d34e069edd0332fed13881562d933d"></a>
template&lt;class T , class CellT , class F &gt; </td></tr>
<tr class="memitem:ae9d34e069edd0332fed13881562d933d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>for_each_voxel_ordered_const</b> (const <a class="el" href="classGeometry_1_1HGrid.html">HGrid</a>&lt; T, CellT &gt; &amp;grid, const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a> &amp;_p0, const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a> &amp;_p7, F &amp;functor)</td></tr>
<tr class="separator:ae9d34e069edd0332fed13881562d933d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fe56babd659982ebcb07504779419f"><td class="memTemplParams" colspan="2"><a id="a06fe56babd659982ebcb07504779419f"></a>
template&lt;class T , class CellT , class F &gt; </td></tr>
<tr class="memitem:a06fe56babd659982ebcb07504779419f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>for_each_voxel_ordered_const</b> (const <a class="el" href="classGeometry_1_1HGrid.html">HGrid</a>&lt; T, CellT &gt; &amp;grid, F &amp;functor)</td></tr>
<tr class="separator:a06fe56babd659982ebcb07504779419f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d488a994f932051c90aff4dac2f3be"><td class="memItemLeft" align="right" valign="top"><a id="ad7d488a994f932051c90aff4dac2f3be"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>interpolate</b> (const <a class="el" href="classGeometry_1_1RGrid.html">Geometry::RGrid</a>&lt; float &gt; &amp;grid, const <a class="el" href="classCGLA_1_1Vec3d.html">CGLA::Vec3d</a> &amp;_v)</td></tr>
<tr class="separator:ad7d488a994f932051c90aff4dac2f3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b72a223c8d57af08a9b27a17727739"><td class="memItemLeft" align="right" valign="top"><a id="ac0b72a223c8d57af08a9b27a17727739"></a>
<a class="el" href="classGeometry_1_1XForm.html">XForm</a>&#160;</td><td class="memItemRight" valign="bottom"><b>grid_sample</b> (const <a class="el" href="classGeometry_1_1Implicit.html">Implicit</a> &amp;imp, const <a class="el" href="classCGLA_1_1Vec3d.html">CGLA::Vec3d</a> &amp;llf, const <a class="el" href="classCGLA_1_1Vec3d.html">CGLA::Vec3d</a> &amp;urt, <a class="el" href="classGeometry_1_1RGrid.html">Geometry::RGrid</a>&lt; float &gt; &amp;grid)</td></tr>
<tr class="separator:ac0b72a223c8d57af08a9b27a17727739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b255ad040ac5a037f98eed6e4df0e8"><td class="memItemLeft" align="right" valign="top"><a id="ab4b255ad040ac5a037f98eed6e4df0e8"></a>
const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NULL_FACE</b> (-1,-1,-1)</td></tr>
<tr class="separator:ab4b255ad040ac5a037f98eed6e4df0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57d5a8de334e0b497b3b4da9cb23c8c"><td class="memTemplParams" colspan="2"><a id="ab57d5a8de334e0b497b3b4da9cb23c8c"></a>
template&lt;class KeyT , class ValT &gt; </td></tr>
<tr class="memitem:ab57d5a8de334e0b497b3b4da9cb23c8c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="structGeometry_1_1KDTreeRecord.html">KDTreeRecord</a>&lt; KeyT, ValT &gt; &amp;a, const <a class="el" href="structGeometry_1_1KDTreeRecord.html">KDTreeRecord</a>&lt; KeyT, ValT &gt; &amp;b)</td></tr>
<tr class="separator:ab57d5a8de334e0b497b3b4da9cb23c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d19649f2491ef760023df4e07ebec7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#a68d19649f2491ef760023df4e07ebec7">load</a> (const std::string &amp;filename, <a class="el" href="classGeometry_1_1TriMesh.html">TriMesh</a> &amp;<a class="el" href="classmesh.html">mesh</a>)</td></tr>
<tr class="memdesc:a68d19649f2491ef760023df4e07ebec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a <a class="el" href="classGeometry_1_1TriMesh.html" title="A Triangle Mesh struct.">TriMesh</a> from a file. Loader chosen based on extension.  <a href="namespaceGeometry.html#a68d19649f2491ef760023df4e07ebec7">More...</a><br /></td></tr>
<tr class="separator:a68d19649f2491ef760023df4e07ebec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901cea2f4682149a63beb26032b48a84"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a901cea2f4682149a63beb26032b48a84"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#a901cea2f4682149a63beb26032b48a84">load_raw</a> (const std::string &amp;file, <a class="el" href="classGeometry_1_1RGrid.html">RGrid</a>&lt; T &gt; &amp;grid)</td></tr>
<tr class="memdesc:a901cea2f4682149a63beb26032b48a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function template for loading raw voxel data. Template arg is the grid type.  <a href="namespaceGeometry.html#a901cea2f4682149a63beb26032b48a84">More...</a><br /></td></tr>
<tr class="separator:a901cea2f4682149a63beb26032b48a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7dbb06fa2180494bac941c1937e400"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#afe7dbb06fa2180494bac941c1937e400">obj_load</a> (const std::string &amp;filename, <a class="el" href="classGeometry_1_1TriMesh.html">TriMesh</a> &amp;<a class="el" href="classmesh.html">mesh</a>)</td></tr>
<tr class="memdesc:afe7dbb06fa2180494bac941c1937e400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a <a class="el" href="classGeometry_1_1TriMesh.html" title="A Triangle Mesh struct.">TriMesh</a> from an OBJ file.  <a href="namespaceGeometry.html#afe7dbb06fa2180494bac941c1937e400">More...</a><br /></td></tr>
<tr class="separator:afe7dbb06fa2180494bac941c1937e400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d77c79fc5238a26b2005a307fd7d8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#af7d77c79fc5238a26b2005a307fd7d8c">mtl_load</a> (const std::string &amp;filename, std::vector&lt; <a class="el" href="structGeometry_1_1Material.html">Material</a> &gt; &amp;materials)</td></tr>
<tr class="memdesc:af7d77c79fc5238a26b2005a307fd7d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load materials from an MRL file.  <a href="namespaceGeometry.html#af7d77c79fc5238a26b2005a307fd7d8c">More...</a><br /></td></tr>
<tr class="separator:af7d77c79fc5238a26b2005a307fd7d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674fdb9971f492514923052f7fb44868"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGeometry.html#a674fdb9971f492514923052f7fb44868">ply_load</a> (const std::string &amp;fn, <a class="el" href="classGeometry_1_1TriMesh.html">Geometry::TriMesh</a> &amp;<a class="el" href="classmesh.html">mesh</a>)</td></tr>
<tr class="memdesc:a674fdb9971f492514923052f7fb44868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load geometry from a ply file into a <a class="el" href="classGeometry_1_1TriMesh.html" title="A Triangle Mesh struct.">TriMesh</a>.  <a href="namespaceGeometry.html#a674fdb9971f492514923052f7fb44868">More...</a><br /></td></tr>
<tr class="separator:a674fdb9971f492514923052f7fb44868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d29648beeec3a1c457bd9d5f56aeee"><td class="memTemplParams" colspan="2"><a id="a21d29648beeec3a1c457bd9d5f56aeee"></a>
template&lt;class G &gt; </td></tr>
<tr class="memitem:a21d29648beeec3a1c457bd9d5f56aeee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>save_raw_float</b> (const std::string &amp;name, G &amp;grid)</td></tr>
<tr class="separator:a21d29648beeec3a1c457bd9d5f56aeee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2679d39039cda55b02e9e689839d1a0"><td class="memTemplParams" colspan="2"><a id="af2679d39039cda55b02e9e689839d1a0"></a>
template&lt;class G &gt; </td></tr>
<tr class="memitem:af2679d39039cda55b02e9e689839d1a0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>save_raw_byte</b> (const std::string &amp;name, G &amp;grid, const typename G::DataType &amp;min_val, const typename G::DataType &amp;max_val)</td></tr>
<tr class="separator:af2679d39039cda55b02e9e689839d1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d39411f830a658db7ea7b4616092d4"><td class="memTemplParams" colspan="2"><a id="a41d39411f830a658db7ea7b4616092d4"></a>
template&lt;class G &gt; </td></tr>
<tr class="memitem:a41d39411f830a658db7ea7b4616092d4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>save_raw_ascii</b> (const std::string &amp;name, G &amp;grid, const typename G::DataType &amp;min_val, const typename G::DataType &amp;max_val)</td></tr>
<tr class="separator:a41d39411f830a658db7ea7b4616092d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a5fca3d8da915d060fa45128d46d3c"><td class="memItemLeft" align="right" valign="top"><a id="a53a5fca3d8da915d060fa45128d46d3c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tessellate</b> (<a class="el" href="classGeometry_1_1IndexedFaceSet.html">IndexedFaceSet</a> &amp;face_set, <a class="el" href="classGeometry_1_1ParSurf.html">ParSurf</a> &amp;s, float u_min, float u_max, float v_min, float v_max, int n, int m)</td></tr>
<tr class="separator:a53a5fca3d8da915d060fa45128d46d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0465ae6725a36e3606bbb458577c920"><td class="memItemLeft" align="right" valign="top"><a id="ac0465ae6725a36e3606bbb458577c920"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tessellate</b> (<a class="el" href="classGeometry_1_1IndexedFaceSet.html">IndexedFaceSet</a> &amp;face_set, <a class="el" href="classGeometry_1_1ParSurf.html">ParSurf</a> &amp;s, <a class="el" href="classUtil_1_1Grid2D.html">Util::Grid2D</a>&lt; <a class="el" href="classCGLA_1_1Vec3f.html">CGLA::Vec3f</a> &gt; &amp;inigrid)</td></tr>
<tr class="separator:ac0465ae6725a36e3606bbb458577c920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e34156aa9e7db79a365500c8370b8b"><td class="memItemLeft" align="right" valign="top"><a id="aa2e34156aa9e7db79a365500c8370b8b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tessellate</b> (<a class="el" href="classGeometry_1_1IndexedFaceSet.html">IndexedFaceSet</a> &amp;face_set, <a class="el" href="classGeometry_1_1ParSurf.html">ParSurf</a> &amp;s, std::vector&lt; <a class="el" href="classCGLA_1_1Vec2f.html">CGLA::Vec2f</a> &gt; uv_points, std::vector&lt; <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a> &gt; triangles)</td></tr>
<tr class="separator:aa2e34156aa9e7db79a365500c8370b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa06e15b2f6a7ee47c407fe3b3bae493"><td class="memItemLeft" align="right" valign="top"><a id="afa06e15b2f6a7ee47c407fe3b3bae493"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>SqrDistance</b> (const <a class="el" href="classCGLA_1_1Vec3f.html">CGLA::Vec3f</a> &amp;rkPoint, const <a class="el" href="classGeometry_1_1Triangle.html">Triangle</a> &amp;rkTri)</td></tr>
<tr class="separator:afa06e15b2f6a7ee47c407fe3b3bae493"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a74d11746066649a8eaa096c8b2653b15"><td class="memItemLeft" align="right" valign="top"><a id="a74d11746066649a8eaa096c8b2653b15"></a>
const float&#160;</td><td class="memItemRight" valign="bottom"><b>DIST_THRESH</b> = 5.0e-4f</td></tr>
<tr class="separator:a74d11746066649a8eaa096c8b2653b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366a9b362e5c1f399d95ef02120afbbf"><td class="memItemLeft" align="right" valign="top"><a id="a366a9b362e5c1f399d95ef02120afbbf"></a>
const <a class="el" href="classCGLA_1_1Vec3f.html">CGLA::Vec3f</a>&#160;</td><td class="memItemRight" valign="bottom"><b>N6f</b> [6]</td></tr>
<tr class="separator:a366a9b362e5c1f399d95ef02120afbbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56361b00a52f95535b988cb8925e9c04"><td class="memItemLeft" align="right" valign="top"><a id="a56361b00a52f95535b988cb8925e9c04"></a>
const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a>&#160;</td><td class="memItemRight" valign="bottom"><b>N6i</b> [6]</td></tr>
<tr class="separator:a56361b00a52f95535b988cb8925e9c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5adab965c3c164d295243c84a5106d8e"><td class="memItemLeft" align="right" valign="top"><a id="a5adab965c3c164d295243c84a5106d8e"></a>
const <a class="el" href="classCGLA_1_1Vec3d.html">CGLA::Vec3d</a>&#160;</td><td class="memItemRight" valign="bottom"><b>N6d</b> [6]</td></tr>
<tr class="separator:a5adab965c3c164d295243c84a5106d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ed58339dcfa7326791406219bc008a"><td class="memItemLeft" align="right" valign="top"><a id="ae3ed58339dcfa7326791406219bc008a"></a>
const <a class="el" href="classCGLA_1_1Vec3f.html">CGLA::Vec3f</a>&#160;</td><td class="memItemRight" valign="bottom"><b>N26f</b> [26]</td></tr>
<tr class="separator:ae3ed58339dcfa7326791406219bc008a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb66578a795bb1cd85128641ea07153a"><td class="memItemLeft" align="right" valign="top"><a id="acb66578a795bb1cd85128641ea07153a"></a>
const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a>&#160;</td><td class="memItemRight" valign="bottom"><b>N26i</b> [26]</td></tr>
<tr class="separator:acb66578a795bb1cd85128641ea07153a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1938c9562bd1621d5ae335ea5fcff2ab"><td class="memItemLeft" align="right" valign="top"><a id="a1938c9562bd1621d5ae335ea5fcff2ab"></a>
const <a class="el" href="classCGLA_1_1Vec3d.html">CGLA::Vec3d</a>&#160;</td><td class="memItemRight" valign="bottom"><b>N26d</b> [26]</td></tr>
<tr class="separator:a1938c9562bd1621d5ae335ea5fcff2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1240b45272c1c1336d894dd177efde7"><td class="memItemLeft" align="right" valign="top"><a id="af1240b45272c1c1336d894dd177efde7"></a>
const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CubeCorners8i</b> [8]</td></tr>
<tr class="separator:af1240b45272c1c1336d894dd177efde7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423854497184cba36153a570850d8587"><td class="memItemLeft" align="right" valign="top"><a id="a423854497184cba36153a570850d8587"></a>
const <a class="el" href="classCGLA_1_1Vec3f.html">CGLA::Vec3f</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CubeCorners8f</b> [8]</td></tr>
<tr class="separator:a423854497184cba36153a570850d8587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5e98a8131a3054b9e9c4232f447ca1"><td class="memItemLeft" align="right" valign="top"><a id="a7d5e98a8131a3054b9e9c4232f447ca1"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>d_eps</b> = 1.0e-12</td></tr>
<tr class="separator:a7d5e98a8131a3054b9e9c4232f447ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f23c35ba375e7dedcde4ee44f570b8c"><td class="memItemLeft" align="right" valign="top"><a id="a6f23c35ba375e7dedcde4ee44f570b8c"></a>
const float&#160;</td><td class="memItemRight" valign="bottom"><b>f_eps</b> = 1.0e-6f</td></tr>
<tr class="separator:a6f23c35ba375e7dedcde4ee44f570b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4d2aaefd5505d7786c0ab88df836a6"><td class="memItemLeft" align="right" valign="top"><a id="a0d4d2aaefd5505d7786c0ab88df836a6"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_ERR</b></td></tr>
<tr class="separator:a0d4d2aaefd5505d7786c0ab88df836a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0007874050977fae2b0b7f2f2c25aa06"><td class="memItemLeft" align="right" valign="top"><a id="a0007874050977fae2b0b7f2f2c25aa06"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_DIST</b></td></tr>
<tr class="separator:a0007874050977fae2b0b7f2f2c25aa06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe663ae981a821e9c3cc53faae91f2f"><td class="memItemLeft" align="right" valign="top"><a id="acbe663ae981a821e9c3cc53faae91f2f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ADAPTIVE</b></td></tr>
<tr class="separator:acbe663ae981a821e9c3cc53faae91f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A namespace for utilities related to geometry. </p>
<p>This namespace contains a wide range of stuff: Spatial datastructures voxel grids and related classes as well as a simple triangle mesh class. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a6c633125eda1f3565b17ac488744f7d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c633125eda1f3565b17ac488744f7d3">&#9670;&nbsp;</a></span>approximate_bounding_sphere()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classCGLA_1_1Vec3d.html">CGLA::Vec3d</a>, double&gt; Geometry::approximate_bounding_sphere </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NodeSetUnordered &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code>NodeSetUnordered({})</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the approximate bounding sphere for the nodes in graph g optionally restricted to the node set passed as second argument. </p>
<p>This function returns center and radius of the sphere </p>

</div>
</div>
<a id="a803eca22b2674de996b24bab6024dcd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a803eca22b2674de996b24bab6024dcd4">&#9670;&nbsp;</a></span>clean_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> Geometry::clean_graph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean up graph, removing unused nodes and edges. </p>

</div>
</div>
<a id="a3d972bf34c3f7f24e1bb78a477c291d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d972bf34c3f7f24e1bb78a477c291d0">&#9670;&nbsp;</a></span>color_graph_node_sets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geometry::color_graph_node_sets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NodeSetVec &amp;&#160;</td>
          <td class="paramname"><em>node_set_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the same (random) color to all nodes in node_set_vec. </p>

</div>
</div>
<a id="a6091b4e18030804fc3b1249420709abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6091b4e18030804fc3b1249420709abf">&#9670;&nbsp;</a></span>connected_components() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classGeometry_1_1AMGraph.html#a45bfc4e413454ca81d6cd1839d5c2bc9">AMGraph::NodeSet</a>&gt; Geometry::connected_components </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1AMGraph.html">AMGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1AMGraph.html#a45bfc4e413454ca81d6cd1839d5c2bc9">AMGraph::NodeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a NodeSet s, split s into connected components and return those in a vector. </p>

</div>
</div>
<a id="aa0556baae64fbb03007d542383f98bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0556baae64fbb03007d542383f98bf9">&#9670;&nbsp;</a></span>connected_components() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;NodeSetUnordered&gt; Geometry::connected_components </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1AMGraph.html">AMGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NodeSetUnordered &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector containing the connected components of set s. </p>

</div>
</div>
<a id="adb810b759c250814926ba207ae34aa95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb810b759c250814926ba207ae34aa95">&#9670;&nbsp;</a></span>for_each_voxel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Geometry::for_each_voxel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeometry_1_1RGrid.html">RGrid</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a> &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a> &amp;&#160;</td>
          <td class="paramname"><em>p7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loop over all voxels in a sub-region (slice) of an <a class="el" href="classGeometry_1_1RGrid.html" title="Regular voxel grid.">RGrid</a> and invoke a functor on each voxel. </p>
<p>The grid is the first argument, the slice is specified by the two subsequent args, and the functor is the last argument. </p>

</div>
</div>
<a id="a6a909f82107e9265db99734cebf0b087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a909f82107e9265db99734cebf0b087">&#9670;&nbsp;</a></span>for_each_voxel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Geometry::for_each_voxel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeometry_1_1RGrid.html">RGrid</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loop over all voxels in an entire <a class="el" href="classGeometry_1_1RGrid.html" title="Regular voxel grid.">RGrid</a>. </p>
<p>Grid is the first argument, and a functor is the second. For each voxel, an operation specified by the functor is performed. </p>

</div>
</div>
<a id="ae902bb059a3dd1e321f970e6048e1a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae902bb059a3dd1e321f970e6048e1a89">&#9670;&nbsp;</a></span>for_each_voxel_const() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Geometry::for_each_voxel_const </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1RGrid.html">RGrid</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a> &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a> &amp;&#160;</td>
          <td class="paramname"><em>p7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loop over all voxels in a sub-region (slice) of an <a class="el" href="classGeometry_1_1RGrid.html" title="Regular voxel grid.">RGrid</a> and invoke a functor on each voxel. </p>
<p>The grid is the first argument, the slice is specified by the two subsequent args, and the functor is the last argument. </p>

</div>
</div>
<a id="a829bee6c0da33b746edc933c2d38ddd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a829bee6c0da33b746edc933c2d38ddd2">&#9670;&nbsp;</a></span>for_each_voxel_const() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Geometry::for_each_voxel_const </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1RGrid.html">RGrid</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loop over all voxels in an entire <a class="el" href="classGeometry_1_1RGrid.html" title="Regular voxel grid.">RGrid</a>. </p>
<p>Grid is the first argument, and a functor is the second. For each voxel, an operation specified by the functor is performed. </p>

</div>
</div>
<a id="a06f72bd1a4a6a1a9e42c4881afe481aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f72bd1a4a6a1a9e42c4881afe481aa">&#9670;&nbsp;</a></span>for_each_voxel_ordered()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Geometry::for_each_voxel_ordered </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeometry_1_1RGrid.html">RGrid</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a> &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a> &amp;&#160;</td>
          <td class="paramname"><em>p7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For each voxel (ordered). </p>
<p>The idea of ordered traversal is that we traverse the volume in a systematic fashion as opposed to traversing simply according to the memory layout of the volume data structure. This is important e.g. if we want to save the volume in raw format. For an <a class="el" href="classGeometry_1_1RGrid.html" title="Regular voxel grid.">RGrid</a>, there is no difference though. </p>

</div>
</div>
<a id="a359cfa6d1e893deaf90b0a43a387959a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359cfa6d1e893deaf90b0a43a387959a">&#9670;&nbsp;</a></span>for_each_voxel_ordered_const()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Geometry::for_each_voxel_ordered_const </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1RGrid.html">RGrid</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a> &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1Vec3i.html">CGLA::Vec3i</a> &amp;&#160;</td>
          <td class="paramname"><em>p7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For each voxel (ordered). </p>
<p>The idea of ordered traversal is that we traverse the volume in a systematic fashion as opposed to traversing simply according to the memory layout of the volume data structure. This is important e.g. if we want to save the volume in raw format. For an <a class="el" href="classGeometry_1_1RGrid.html" title="Regular voxel grid.">RGrid</a>, there is no difference though. </p>

</div>
</div>
<a id="aa899aa2f3873cd1eb42d67762e14b1dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa899aa2f3873cd1eb42d67762e14b1dd">&#9670;&nbsp;</a></span>front_separators()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NodeSetVec Geometry::front_separators </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classUtil_1_1AttribVec.html">AttribVecDouble</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dvv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute separators by marching a front along a scalar field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>the graph that we operate on. </td></tr>
    <tr><td class="paramname">dvv</td><td>a vector of scalar fields defined on the graph vertices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns a vector of NodeSets containing a number of non-overlapping (local) separators.</dd></dl>
<p>Given the input scalar fields, the function marches along each scalar field and produces non-overlapping sets of nodes where each set of nodes represents the front at a given point in time. These are then greedily packed, producing the final vector of non-overlapping node sets which is then returned. This can be seen as a mix of Reeb graphs - or as a representation which can be turned into that. </p>

</div>
</div>
<a id="aac91c60ea3176331afb6f49302bda891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac91c60ea3176331afb6f49302bda891">&#9670;&nbsp;</a></span>geometric_median()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGLA_1_1Vec3d.html">CGLA::Vec3d</a> Geometry::geometric_median </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classCGLA_1_1Vec3d.html">CGLA::Vec3d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the point that minimizes the sum of distance to the input points (given in pts). </p>
<p>A fixed number of iterations is used. </p>

</div>
</div>
<a id="a7c10516264805691979b8256f10c849e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c10516264805691979b8256f10c849e">&#9670;&nbsp;</a></span>graph_edge_contract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Geometry::graph_edge_contract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dist_thresh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Contracts edges in the graph g shorter than dist_thresh. A priority queue is used to contract shorter edges first. </p>

</div>
</div>
<a id="a425f591ca0937c45df65dc74ce7af6a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a425f591ca0937c45df65dc74ce7af6a3">&#9670;&nbsp;</a></span>graph_from_points()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> Geometry::graph_from_points </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_closest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a point set from a file and convert to a graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_name</td><td></td></tr>
    <tr><td class="paramname">rad</td><td>the radius within which we connect two points with an edge </td></tr>
    <tr><td class="paramname">N_closest</td><td>the maximum number of points which we connect to.</td></tr>
  </table>
  </dd>
</dl>
<p>The points are assumed to be stored in a very simple text format where each point is stored as three numbers on a separate line. </p>

</div>
</div>
<a id="a4e20bc0267a7045ec3b56093777459e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e20bc0267a7045ec3b56093777459e2">&#9670;&nbsp;</a></span>graph_H_dist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;double,double&gt; Geometry::graph_H_dist </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;&#160;</td>
          <td class="paramname"><em>g0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>samples</em> = <code>10000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the distance at samples points from graph g0 to g1 and vice versa. </p>
<p>H is for Hausdorff. </p>

</div>
</div>
<a id="a3a81c5ba7b313660b9f21418c0c3a1f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a81c5ba7b313660b9f21418c0c3a1f4">&#9670;&nbsp;</a></span>graph_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> Geometry::graph_load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a graph from a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_name</td><td>Graphs are assumed to be stored in a simple format where:<ul>
<li>each vertex (aka node) is stored on a single line starting with the character 'n' followed by three decimal numbers that together give the 3D spatial coordinates of the node.</li>
<li>each edge (aka connection) is stored on a line starting with the character 'c' followed by two numbers which are interpreted as the indices of the nodes connected by the edge. node numbers are assumed to start from 0. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4f446c66e5c8f2f35aa4b8a26e4a319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4f446c66e5c8f2f35aa4b8a26e4a319">&#9670;&nbsp;</a></span>graph_save()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::graph_save </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a graph to a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_name</td><td>The graphs are saved to the same format as described above for the graph_load function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a243a21969755d20ef7dd70ade63069f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a243a21969755d20ef7dd70ade63069f8">&#9670;&nbsp;</a></span>graph_save_ply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::graph_save_ply </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a graph in the ply format. </p>
<p>This simplistic ply saver actually does not output the mesh connectivity but just the point cloud. The raison d'etre is that some codes for skeletonization of point clouds take ply files as input, so we need it for comparison. </p>

</div>
</div>
<a id="ada16be80a3c7361258e362b34e863ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada16be80a3c7361258e362b34e863ce6">&#9670;&nbsp;</a></span>graph_to_mesh_cyl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geometry::graph_to_mesh_cyl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">HMesh::Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fudge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a graph to a mesh using cone stubs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>the input graph </td></tr>
    <tr><td class="paramname">m</td><td>the output mesh </td></tr>
    <tr><td class="paramname">fudge</td><td>is the number added to node size</td></tr>
  </table>
  </dd>
</dl>
<p>This function converts a graph to a skeleton by representing each edge as a cone stub. So where do we get the radius of each node. Well, this is currently stored as the green color in the color associated with each node. That is an unfortunate hack, but there you are. </p>

</div>
</div>
<a id="aa33e2c405efb457544c915ca6e09a7ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa33e2c405efb457544c915ca6e09a7ec">&#9670;&nbsp;</a></span>graph_to_mesh_iso()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geometry::graph_to_mesh_iso </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">HMesh::Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>grid_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fudge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tau</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a graph to a mesh using convolution surfaces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>the input graph </td></tr>
    <tr><td class="paramname">m</td><td>the output mesh </td></tr>
    <tr><td class="paramname">grid_res</td><td>the resolution of the voxel grid used in the conversion </td></tr>
    <tr><td class="paramname">fudge</td><td>is the number added to node size </td></tr>
    <tr><td class="paramname">tau</td><td>is the threshold for isosurface extraction</td></tr>
  </table>
  </dd>
</dl>
<p>This function converts a graph to a skeleton by way of a convolution surface sampled on a voxel grid. So where do we get the radius of each node. Well, this is currently stored as the green color in the color associated with each node. That is an unfortunate hack, but there you are. </p>

</div>
</div>
<a id="aedae255ca15db2363ef55a60fb9188de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedae255ca15db2363ef55a60fb9188de">&#9670;&nbsp;</a></span>k_means_node_clusters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NodeSetVec Geometry::k_means_node_clusters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MAX_ITER</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>k means clustering of graph nodes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>is the input graph </td></tr>
    <tr><td class="paramname">N</td><td>is the desired number of clusters </td></tr>
    <tr><td class="paramname">MAX_ITER</td><td>is the number of iterations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a node set vector such that all graph nodes belong to precisely one cluster</dd></dl>
<p>This function iteratively clusters vertices of g according to the k-means clustering algorithm. each vertex is assigned to the closest cluster (simply using Euclidean distance). To ensure we get precisely N clusters, clusters which have a poor boundary to size ratio are ejected when there are more than N clusters. </p>

</div>
</div>
<a id="a68d19649f2491ef760023df4e07ebec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68d19649f2491ef760023df4e07ebec7">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geometry::load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGeometry_1_1TriMesh.html">TriMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a <a class="el" href="classGeometry_1_1TriMesh.html" title="A Triangle Mesh struct.">TriMesh</a> from a file. Loader chosen based on extension. </p>

</div>
</div>
<a id="a901cea2f4682149a63beb26032b48a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a901cea2f4682149a63beb26032b48a84">&#9670;&nbsp;</a></span>load_raw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::load_raw </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGeometry_1_1RGrid.html">RGrid</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>grid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function template for loading raw voxel data. Template arg is the grid type. </p>

</div>
</div>
<a id="a408763e93259b49e00adc2cecc69a659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a408763e93259b49e00adc2cecc69a659">&#9670;&nbsp;</a></span>local_separator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;double,NodeSet&gt; Geometry::local_separator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodeID&#160;</td>
          <td class="paramname"><em>n0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quality_noise_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>optimization_steps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a given graph, g, and a given node n0, we compute a local separator. </p>
<p>The algorithm proceeds in a way similar to Dijkstra, finding a set of nodes separator such that there is anoter set of nodes, front, connected to separator via edges and front consists of two connected components. thick_front indicates whether we want to add a layer of nodes to the front before checking the number of connected components. persistence is how many iterations the front must have two connected components before we consider the interior a local separator. The final node set returned is then thinned to the minimal separator. </p>

</div>
</div>
<a id="a87b816419d973153f050f147ff6363f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b816419d973153f050f147ff6363f8">&#9670;&nbsp;</a></span>local_separators()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NodeSetVec Geometry::local_separators </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sampling</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quality_noise_level</em> = <code>0.09</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>optimization_steps</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a set of local separators from the input graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>the graph which is geometrically not modified, but the node colors will be changed </td></tr>
    <tr><td class="paramname">quality_noise_level</td><td>the ratio of smallest to greatest front component size needed before we acknowledge that the front has split and a separator been found. The smaller this number, the more spurious branches, but if it is too high, we might miss some </td></tr>
    <tr><td class="paramname">optimization_steps</td><td>indicates the number of times we run a simple optimization algorithm based on Dijkstra which aims to make the separator thinner.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function returns a vector of NodeSets containing a number of non-overlapping (local) separators</dd></dl>
<p>This function finds a number of local separators by using a local front propagation method where we iteratively find the point closest to a sphere and then expand the sphere to contain the points (when needed). When the front (i.e. vertices connected to those already found) splits in two, we know that at least locally, the found vertices form a separator. This separator is then made minimal by stripping away vertices until no more can be removed without rejoining the fronts. This process is then repeated as many times as required by the input parameters, and, finally, the local separators produced are packed greedily, and the resulting vector of node sets is returned. </p>

</div>
</div>
<a id="a262095996d764f7d3639d7d0506cd560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a262095996d764f7d3639d7d0506cd560">&#9670;&nbsp;</a></span>maximize_node_set_vec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NodeSetVec Geometry::maximize_node_set_vec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NodeSetVec &amp;&#160;</td>
          <td class="paramname"><em>node_set_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a set of nodes into a set that partitions the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>the input graph </td></tr>
    <tr><td class="paramname">node_set_vec</td><td>is the vector of input node sets. It is assumed that no node in g belongs to more than one of these node sets. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a node set vector such that all graph nodes belong to precisely one node set</dd></dl>
<p>This function simply runs dijkstras algorithm starting from the nodes passed as input. Subsequently, each node that did not belong to the input node_set_vec is assigned to the node set from which it was reached during the run of Dijkstra </p>

</div>
</div>
<a id="ae17b128890e3cb227e313cf93c99a169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17b128890e3cb227e313cf93c99a169">&#9670;&nbsp;</a></span>mcm_smooth_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geometry::mcm_smooth_graph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mean curvature motion smoothing. </p>
<p>Simply put this function moves vertices towards the average of their neighbors position but it moves more if the largest eigenvalue of the covariance matrix dominates. This means that we smooth most if things are anistotropic and less in isotropi areas of the graph. </p>

</div>
</div>
<a id="a9f2ea44c44e75ba22216b4a795fd7a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f2ea44c44e75ba22216b4a795fd7a7c">&#9670;&nbsp;</a></span>minimum_spanning_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> Geometry::minimum_spanning_tree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGeometry_1_1AMGraph.html#aff736ffe081b073bd0038f288ea03313">AMGraph::NodeID</a>&#160;</td>
          <td class="paramname"><em>root</em> = <code><a class="el" href="classGeometry_1_1AMGraph.html#a8cb0932f79bd2ff91a17c0c82e3911d6">AMGraph::InvalidNodeID</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the minimum spanning tree of the argument using Prim's algorithm and returns the resulting graph. </p>

</div>
</div>
<a id="af7d77c79fc5238a26b2005a307fd7d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7d77c79fc5238a26b2005a307fd7d8c">&#9670;&nbsp;</a></span>mtl_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geometry::mtl_load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structGeometry_1_1Material.html">Material</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>materials</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load materials from an MRL file. </p>

</div>
</div>
<a id="a0023a7dab38c9b01d3493da349764298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0023a7dab38c9b01d3493da349764298">&#9670;&nbsp;</a></span>negate_dist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUtil_1_1AttribVec.html">AttribVecDouble</a> Geometry::negate_dist </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classUtil_1_1AttribVec.html">AttribVecDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>dist_in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the attributes in dist_in but negated. </p>

</div>
</div>
<a id="ae20ed7bceb4c81be99aeb6699a6a93aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae20ed7bceb4c81be99aeb6699a6a93aa">&#9670;&nbsp;</a></span>neighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NodeSetUnordered Geometry::neighbors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NodeSetUnordered &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function computes the neighbors of s in g. In other words it returns the set of nodes that are connected to s but do not belong to s. </p>

</div>
</div>
<a id="afe7dbb06fa2180494bac941c1937e400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe7dbb06fa2180494bac941c1937e400">&#9670;&nbsp;</a></span>obj_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geometry::obj_load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGeometry_1_1TriMesh.html">TriMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a <a class="el" href="classGeometry_1_1TriMesh.html" title="A Triangle Mesh struct.">TriMesh</a> from an OBJ file. </p>

</div>
</div>
<a id="ab9803044c149c41e5cfee4baf7119825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9803044c149c41e5cfee4baf7119825">&#9670;&nbsp;</a></span>order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NodeSet Geometry::order </td>
          <td>(</td>
          <td class="paramtype">NodeSetUnordered &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a node set from unordered representation to ordered. </p>
<p>This makes it possible to count the number of shared nodes in linear time. </p>

</div>
</div>
<a id="a34fe57c2e27160c797245b192a890b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34fe57c2e27160c797245b192a890b1e">&#9670;&nbsp;</a></span>ply_load() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::ply_load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;&#160;</td>
          <td class="paramname"><em>_graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load the graph from a PLY file - assuming the edges are explcitly encoded! </p>

</div>
</div>
<a id="a674fdb9971f492514923052f7fb44868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674fdb9971f492514923052f7fb44868">&#9670;&nbsp;</a></span>ply_load() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Geometry::ply_load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGeometry_1_1TriMesh.html">Geometry::TriMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load geometry from a ply file into a <a class="el" href="classGeometry_1_1TriMesh.html" title="A Triangle Mesh struct.">TriMesh</a>. </p>
<p>This is a very crude loader which only extracts the raw geometry. </p>

</div>
</div>
<a id="a70b352deb9d4983a957a55204c949ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b352deb9d4983a957a55204c949ad0">&#9670;&nbsp;</a></span>projection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUtil_1_1AttribVec.html">AttribVecDouble</a> Geometry::projection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1Vec3d.html">CGLA::Vec3d</a> &amp;&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>smooth_iter</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Project the vertex positions of g onto vector dir and return the attribute vector containing the result smoothed smooth_iter times. </p>

</div>
</div>
<a id="ac7e9ab6ead2925de7711775bbdc7763b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e9ab6ead2925de7711775bbdc7763b">&#9670;&nbsp;</a></span>prune()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geometry::prune </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function unceremoniously removes leaf vertices if they share an edge with a vertex that has valence greater than two. </p>

</div>
</div>
<a id="a9c0886ca3c7d6d2751a86e8baff676de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c0886ca3c7d6d2751a86e8baff676de">&#9670;&nbsp;</a></span>saturate_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geometry::saturate_graph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>hops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dist_frac</em> = <code>1.0001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rad</em> = <code>1e300</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add edges to g. </p>
<p>For each vertex in g we visit neighbors at a maximum of &lsquo;hops&rsquo; graph hops from the original vertex. Saturation is here used differently from the conventional graph theoretical usage.. </p>

</div>
</div>
<a id="a8e09438f079533770ffd7f41ab7d5462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e09438f079533770ffd7f41ab7d5462">&#9670;&nbsp;</a></span>skeleton_from_node_set_vec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a>, <a class="el" href="classUtil_1_1AttribVec.html">Util::AttribVec</a>&lt;<a class="el" href="classGeometry_1_1AMGraph.html#aff736ffe081b073bd0038f288ea03313">AMGraph3D::NodeID</a>,<a class="el" href="classGeometry_1_1AMGraph.html#aff736ffe081b073bd0038f288ea03313">AMGraph3D::NodeID</a>&gt; &gt; Geometry::skeleton_from_node_set_vec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NodeSetVec &amp;&#160;</td>
          <td class="paramname"><em>node_set_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>merge</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>smooth_steps</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a vector of (non-overlapping) node sets to a skeleton graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>the input graph </td></tr>
    <tr><td class="paramname">node_set_vec</td><td>the set of nodes which we use to produce the skeleton. Each set becomes a single node of the skeleton </td></tr>
    <tr><td class="paramname">merge</td><td>the resulting skeleton may contain triangles where threee nodes are mutually connected forming a clique. If merge is true, such triangles are collapsed into a single vertex joining all the thus connected nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair containing the graph which represents the skeleton and a mapping from nodes of the original graph to nodes of the skeleton.</dd></dl>
<p>Using Dijkstra, we add nodes to each node set in node_set_vec until all nodes are assigned to exacly one node set. The skeleton is then easy to find. Each (augmented) node set begets a vertex of the skeleton, and whenever two vertices belonging to different node sets are connected by an edge, we connect the corresponding skeletal vertices. Normally, we have merge=true and all of the thriangles in the graph are reduced to Steiner-like vertices. The graph structure has a color associated with vertices, and we color the Steiner vertices red. The green channel is used to store the estimated radius. In a better API, we would output these things as separate attributes. </p>

</div>
</div>
<a id="ab46bdacfd733d8a612a4ff09efe105a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab46bdacfd733d8a612a4ff09efe105a2">&#9670;&nbsp;</a></span>smooth_dist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUtil_1_1AttribVec.html">AttribVecDouble</a> Geometry::smooth_dist </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classUtil_1_1AttribVec.html">AttribVecDouble</a> &amp;&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>smooth_iter</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smooth the attributes in dist associated with graph g smooth_iter times. </p>

</div>
</div>
<a id="a44273334e4bbe146fc33060b3323a592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44273334e4bbe146fc33060b3323a592">&#9670;&nbsp;</a></span>smooth_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Geometry::smooth_graph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple Laplacian graph smoothing. iter specifies number of iterations, and alpha in range [0..1] is the weight. </p>

</div>
</div>
<a id="a12fc270d803250d35a499cb1e7aa2cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12fc270d803250d35a499cb1e7aa2cf0">&#9670;&nbsp;</a></span>test_intersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Geometry::test_intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1AMGraph.html#a45bfc4e413454ca81d6cd1839d5c2bc9">AMGraph3D::NodeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>set1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1AMGraph.html#a45bfc4e413454ca81d6cd1839d5c2bc9">AMGraph3D::NodeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>set2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linear time counting of the number of shared members of set1 and set2. </p>

</div>
</div>
<a id="ace102b2e49c1441880424026f490bc13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace102b2e49c1441880424026f490bc13">&#9670;&nbsp;</a></span>voxel_graph_from_mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGeometry_1_1AMGraph3D.html">AMGraph3D</a> Geometry::voxel_graph_from_mesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">HMesh::Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a graph of voxels from input mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>is the input mesh </td></tr>
    <tr><td class="paramname">res</td><td>is the resolution </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a graph whose vertices are interior to m.</dd></dl>
<p>This function computes a distance field from m (at resolution res) and the graph is constructed from the interior voxels. each voxel is connected to all 26 neighbors. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
