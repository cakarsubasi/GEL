<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GEL: Geometry::KDTree&lt; KeyT, ValT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GEL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceGeometry.html">Geometry</a></li><li class="navelem"><a class="el" href="classGeometry_1_1KDTree.html">KDTree</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classGeometry_1_1KDTree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Geometry::KDTree&lt; KeyT, ValT &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A classic K-D tree.  
 <a href="classGeometry_1_1KDTree.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGeometry_1_1KDTree_1_1KDNode.html">KDNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structGeometry_1_1KDTree_1_1KDNode.html" title="KDNode struct represents node in KD tree.">KDNode</a> struct represents node in KD tree.  <a href="structGeometry_1_1KDTree_1_1KDNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afcdc3c12fa731e530041d4d1919d1df9"><td class="memItemLeft" align="right" valign="top"><a id="afcdc3c12fa731e530041d4d1919d1df9"></a>
typedef KeyT::ScalarType&#160;</td><td class="memItemRight" valign="bottom"><b>ScalarType</b></td></tr>
<tr class="separator:afcdc3c12fa731e530041d4d1919d1df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f399454b64d6f59e0bbc6239c43f4f"><td class="memItemLeft" align="right" valign="top"><a id="a28f399454b64d6f59e0bbc6239c43f4f"></a>
typedef KeyT&#160;</td><td class="memItemRight" valign="bottom"><b>KeyType</b></td></tr>
<tr class="separator:a28f399454b64d6f59e0bbc6239c43f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6d1a5845f3595aa350dcff51e3029c"><td class="memItemLeft" align="right" valign="top"><a id="a4c6d1a5845f3595aa350dcff51e3029c"></a>
typedef std::vector&lt; <a class="el" href="structGeometry_1_1KDTree_1_1KDNode.html">KDNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NodeVecType</b></td></tr>
<tr class="separator:a4c6d1a5845f3595aa350dcff51e3029c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23862c69448b17aae1b8787a1d07f3f"><td class="memItemLeft" align="right" valign="top"><a id="ad23862c69448b17aae1b8787a1d07f3f"></a>
typedef NodeVecType::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>NodeVecConstIterType</b></td></tr>
<tr class="separator:ad23862c69448b17aae1b8787a1d07f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1a104b0d31de943077eb47d433ef34da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1KDTree.html#a1a104b0d31de943077eb47d433ef34da">KDTree</a> ()</td></tr>
<tr class="memdesc:a1a104b0d31de943077eb47d433ef34da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build tree from vector of keys passed as argument.  <a href="classGeometry_1_1KDTree.html#a1a104b0d31de943077eb47d433ef34da">More...</a><br /></td></tr>
<tr class="separator:a1a104b0d31de943077eb47d433ef34da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a98249e0714bc33e6a4cbe27553d48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1KDTree.html#a36a98249e0714bc33e6a4cbe27553d48">insert</a> (const KeyT &amp;key, const ValT &amp;val)</td></tr>
<tr class="memdesc:a36a98249e0714bc33e6a4cbe27553d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a key value pair into the tree.  <a href="classGeometry_1_1KDTree.html#a36a98249e0714bc33e6a4cbe27553d48">More...</a><br /></td></tr>
<tr class="separator:a36a98249e0714bc33e6a4cbe27553d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d113495b66bedc5ce18877c251b5a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1KDTree.html#a80d113495b66bedc5ce18877c251b5a8">build</a> ()</td></tr>
<tr class="memdesc:a80d113495b66bedc5ce18877c251b5a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the tree.  <a href="classGeometry_1_1KDTree.html#a80d113495b66bedc5ce18877c251b5a8">More...</a><br /></td></tr>
<tr class="separator:a80d113495b66bedc5ce18877c251b5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8511bb7e6785340f65378295d9cdb953"><td class="memItemLeft" align="right" valign="top"><a id="a8511bb7e6785340f65378295d9cdb953"></a>
NodeVecConstIterType&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const</td></tr>
<tr class="separator:a8511bb7e6785340f65378295d9cdb953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdba7d00909705d113f5396157b28cc7"><td class="memItemLeft" align="right" valign="top"><a id="abdba7d00909705d113f5396157b28cc7"></a>
NodeVecConstIterType&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const</td></tr>
<tr class="separator:abdba7d00909705d113f5396157b28cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c8f1ba8c95bc1457fee96f11fbf8d67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1KDTree.html#a1c8f1ba8c95bc1457fee96f11fbf8d67">closest_point</a> (const KeyT &amp;p, ScalarType &amp;dist, KeyT &amp;k, ValT &amp;v) const</td></tr>
<tr class="memdesc:a1c8f1ba8c95bc1457fee96f11fbf8d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the key value pair closest to the key given as first argument.  <a href="classGeometry_1_1KDTree.html#a1c8f1ba8c95bc1457fee96f11fbf8d67">More...</a><br /></td></tr>
<tr class="separator:a1c8f1ba8c95bc1457fee96f11fbf8d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108208ff59f311af8e982bac8d7a12fc"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1KDTree.html#a108208ff59f311af8e982bac8d7a12fc">in_sphere</a> (const KeyType &amp;p, ScalarType dist, std::vector&lt; KeyT &gt; &amp;keys, std::vector&lt; ValT &gt; &amp;vals) const</td></tr>
<tr class="memdesc:a108208ff59f311af8e982bac8d7a12fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the elements within a given radius (second argument) of the key (first argument).  <a href="classGeometry_1_1KDTree.html#a108208ff59f311af8e982bac8d7a12fc">More...</a><br /></td></tr>
<tr class="separator:a108208ff59f311af8e982bac8d7a12fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade56c653de747159a3ddf88950c3c1da"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structGeometry_1_1KDTreeRecord.html">KDTreeRecord</a>&lt; KeyT, ValT &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGeometry_1_1KDTree.html#ade56c653de747159a3ddf88950c3c1da">m_closest</a> (unsigned m, const KeyType &amp;p, ScalarType dist) const</td></tr>
<tr class="memdesc:ade56c653de747159a3ddf88950c3c1da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the m elements closest to p and within a distance dist.  <a href="classGeometry_1_1KDTree.html#ade56c653de747159a3ddf88950c3c1da">More...</a><br /></td></tr>
<tr class="separator:ade56c653de747159a3ddf88950c3c1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class KeyT, class ValT&gt;<br />
class Geometry::KDTree&lt; KeyT, ValT &gt;</h3>

<p>A classic K-D tree. </p>
<p>A K-D tree is a good data structure for storing points in space and for nearest neighbour queries. It is basically a generalized binary tree in K dimensions. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1a104b0d31de943077eb47d433ef34da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a104b0d31de943077eb47d433ef34da">&#9670;&nbsp;</a></span>KDTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyT , class ValT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGeometry_1_1KDTree.html">Geometry::KDTree</a>&lt; KeyT, ValT &gt;::<a class="el" href="classGeometry_1_1KDTree.html">KDTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build tree from vector of keys passed as argument. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a80d113495b66bedc5ce18877c251b5a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80d113495b66bedc5ce18877c251b5a8">&#9670;&nbsp;</a></span>build()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyT , class ValT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGeometry_1_1KDTree.html">Geometry::KDTree</a>&lt; KeyT, ValT &gt;::build </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build the tree. </p>
<p>After this function has been called, it is no longer legal to insert elements, but you can perform searches. </p>

</div>
</div>
<a id="a1c8f1ba8c95bc1457fee96f11fbf8d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c8f1ba8c95bc1457fee96f11fbf8d67">&#9670;&nbsp;</a></span>closest_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyT , class ValT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGeometry_1_1KDTree.html">Geometry::KDTree</a>&lt; KeyT, ValT &gt;::closest_point </td>
          <td>(</td>
          <td class="paramtype">const KeyT &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType &amp;&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyT &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValT &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the key value pair closest to the key given as first argument. </p>
<p>The second argument is the maximum search distance. Upon return this value is changed to the distance to the found point. The final two arguments contain the closest key and its associated value upon return. </p>

</div>
</div>
<a id="a108208ff59f311af8e982bac8d7a12fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a108208ff59f311af8e982bac8d7a12fc">&#9670;&nbsp;</a></span>in_sphere()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyT , class ValT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classGeometry_1_1KDTree.html">Geometry::KDTree</a>&lt; KeyT, ValT &gt;::in_sphere </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; KeyT &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; ValT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find all the elements within a given radius (second argument) of the key (first argument). </p>
<p>The key value pairs inside the sphere are returned in a pair of vectors passed as the two last arguments. Note that we don't resize the two last arguments to zero - so either they should be empty vectors or you should desire appending the newly found elements onto these vectors. </p>

</div>
</div>
<a id="a36a98249e0714bc33e6a4cbe27553d48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36a98249e0714bc33e6a4cbe27553d48">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyT , class ValT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGeometry_1_1KDTree.html">Geometry::KDTree</a>&lt; KeyT, ValT &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const KeyT &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValT &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a key value pair into the tree. </p>
<p>Note that the tree needs to be built - by calling the build function - before you can search. </p>

</div>
</div>
<a id="ade56c653de747159a3ddf88950c3c1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade56c653de747159a3ddf88950c3c1da">&#9670;&nbsp;</a></span>m_closest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyT , class ValT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structGeometry_1_1KDTreeRecord.html">KDTreeRecord</a>&lt;KeyT, ValT&gt; &gt; <a class="el" href="classGeometry_1_1KDTree.html">Geometry::KDTree</a>&lt; KeyT, ValT &gt;::m_closest </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ScalarType&#160;</td>
          <td class="paramname"><em>dist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the m elements closest to p and within a distance dist. </p>
<p>This function returns a vector of KDTreeRecords sorted in ascending distance order. This function is often significantly faster than simply finding all elements within a given radius using in_sphere and then sorting because once m elements have been found, the search radius can be narrowed. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="KDTree_8h_source.html">KDTree.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
