<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GEL: CGLA Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GEL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">CGLA Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Computer Graphics Linear Algebra.  
<a href="namespaceCGLA.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1ArithMatFloat.html">ArithMatFloat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic class template for matrices.  <a href="classCGLA_1_1ArithMatFloat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1ArithQuat.html">ArithQuat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A T based Quaterinion class.  <a href="classCGLA_1_1ArithQuat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1ArithSqMat2x2Float.html">ArithSqMat2x2Float</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two by two float matrix template.  <a href="classCGLA_1_1ArithSqMat2x2Float.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1ArithSqMat3x3Float.html">ArithSqMat3x3Float</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">3 by 3 float matrix template.  <a href="classCGLA_1_1ArithSqMat3x3Float.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1ArithSqMat4x4Float.html">ArithSqMat4x4Float</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">4 by 4 float matrix template.  <a href="classCGLA_1_1ArithSqMat4x4Float.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1ArithSqMatFloat.html">ArithSqMatFloat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template for square matrices.  <a href="classCGLA_1_1ArithSqMatFloat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1ArithVec.html">ArithVec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template representing generic arithmetic vectors.  <a href="classCGLA_1_1ArithVec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1ArithVec2Float.html">ArithVec2Float</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1ArithVec3Float.html">ArithVec3Float</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1ArithVec3Int.html">ArithVec3Int</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1ArithVec4Float.html">ArithVec4Float</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A four dimensional floating point vector template.  <a href="classCGLA_1_1ArithVec4Float.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1ArithVec4Int.html">ArithVec4Int</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1ArithVecFloat.html">ArithVecFloat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1VecT__to__MatT.html">VecT_to_MatT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The template below is used to map vector types to matrix types.  <a href="classCGLA_1_1VecT__to__MatT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1ArithVecInt.html">ArithVecInt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1BitMask.html">BitMask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classCGLA_1_1BitMask.html" title="The BitMask class is mostly a utility class.">BitMask</a> class is mostly a utility class.  <a href="classCGLA_1_1BitMask.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1CGLAMotherException.html">CGLAMotherException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1Mat2x2d.html">Mat2x2d</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two by two double matrix.  <a href="classCGLA_1_1Mat2x2d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1Mat2x2f.html">Mat2x2f</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two by two float matrix.  <a href="classCGLA_1_1Mat2x2f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1Mat2x3d.html">Mat2x3d</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">2x3 double matrix class.  <a href="classCGLA_1_1Mat2x3d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1Mat3x2d.html">Mat3x2d</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">3x2 double matrix class.  <a href="classCGLA_1_1Mat3x2d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1Mat2x3f.html">Mat2x3f</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">2x3 float matrix class.  <a href="classCGLA_1_1Mat2x3f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1Mat3x2f.html">Mat3x2f</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">3x2 float matrix class.  <a href="classCGLA_1_1Mat3x2f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1Mat3x3d.html">Mat3x3d</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">3 by 3 double matrix.  <a href="classCGLA_1_1Mat3x3d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1Mat3x3f.html">Mat3x3f</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">3 by 3 float matrix.  <a href="classCGLA_1_1Mat3x3f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1Mat4x4d.html">Mat4x4d</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">4x4 double matrix.  <a href="classCGLA_1_1Mat4x4d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1Mat4x4f.html">Mat4x4f</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">4x4 float matrix.  <a href="classCGLA_1_1Mat4x4f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1Quatd.html">Quatd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A float based Quaterinion class.  <a href="classCGLA_1_1Quatd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1Quatf.html">Quatf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A float based Quaterinion class.  <a href="classCGLA_1_1Quatf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1UnitVector.html">UnitVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classCGLA_1_1UnitVector.html" title="The UnitVector stores a unit length vector as two angles.">UnitVector</a> stores a unit length vector as two angles.  <a href="classCGLA_1_1UnitVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1Vec2d.html">Vec2d</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D double floating point vector  <a href="classCGLA_1_1Vec2d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCGLA_1_1VecT__to__MatT_3_01Vec2d_01_4.html">VecT_to_MatT&lt; Vec2d &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1Vec2f.html">Vec2f</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D floating point vector  <a href="classCGLA_1_1Vec2f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCGLA_1_1VecT__to__MatT_3_01Vec2f_01_4.html">VecT_to_MatT&lt; Vec2f &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1Vec2i.html">Vec2i</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D Integer vector.  <a href="classCGLA_1_1Vec2i.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1Vec2ui.html">Vec2ui</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D Integer vector.  <a href="classCGLA_1_1Vec2ui.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1Vec3d.html">Vec3d</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 3D double vector.  <a href="classCGLA_1_1Vec3d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCGLA_1_1VecT__to__MatT_3_01Vec3d_01_4.html">VecT_to_MatT&lt; Vec3d &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1Vec3f.html">Vec3f</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D float vector.  <a href="classCGLA_1_1Vec3f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCGLA_1_1VecT__to__MatT_3_01Vec3f_01_4.html">VecT_to_MatT&lt; Vec3f &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1Vec3i.html">Vec3i</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D integer vector.  <a href="classCGLA_1_1Vec3i.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1Vec3uc.html">Vec3uc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D unsigned char vector.  <a href="classCGLA_1_1Vec3uc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1Vec3usi.html">Vec3usi</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned short int 3D vector class.  <a href="classCGLA_1_1Vec3usi.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1Vec4d.html">Vec4d</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A four dimensional floating point vector.  <a href="classCGLA_1_1Vec4d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCGLA_1_1VecT__to__MatT_3_01Vec4d_01_4.html">VecT_to_MatT&lt; Vec4d &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1Vec4f.html">Vec4f</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A four dimensional floating point vector.  <a href="classCGLA_1_1Vec4f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCGLA_1_1VecT__to__MatT_3_01Vec4f_01_4.html">VecT_to_MatT&lt; Vec4f &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1Vec4i.html">Vec4i</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">4D integer vector.  <a href="classCGLA_1_1Vec4i.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGLA_1_1Vec4uc.html">Vec4uc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">4D unsigned char vector.  <a href="classCGLA_1_1Vec4uc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa721762d9f12c1ea6ea98a73191881a7"><td class="memItemLeft" align="right" valign="top"><a id="aa721762d9f12c1ea6ea98a73191881a7"></a>
typedef <a class="el" href="classCGLA_1_1Quatf.html">Quatf</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Quaternion</b></td></tr>
<tr class="separator:aa721762d9f12c1ea6ea98a73191881a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f1b9e3a3983b28ecbca9e3cabb5f61"><td class="memItemLeft" align="right" valign="top"><a id="aa3f1b9e3a3983b28ecbca9e3cabb5f61"></a>
typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>UChar</b></td></tr>
<tr class="separator:aa3f1b9e3a3983b28ecbca9e3cabb5f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7ee145a04a2e5b06c3b44c1512b1fc"><td class="memItemLeft" align="right" valign="top"><a id="a4d7ee145a04a2e5b06c3b44c1512b1fc"></a>
typedef unsigned short int&#160;</td><td class="memItemRight" valign="bottom"><b>USInt</b></td></tr>
<tr class="separator:a4d7ee145a04a2e5b06c3b44c1512b1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a581cb1af1e8730f50b18d04eb2af3029"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a581cb1af1e8730f50b18d04eb2af3029">Axis</a> { <b>XAXIS</b> =0
, <b>YAXIS</b> =1
, <b>ZAXIS</b> =2
 }</td></tr>
<tr class="memdesc:a581cb1af1e8730f50b18d04eb2af3029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful enum that represents coordiante axes.  <a href="namespaceCGLA.html#a581cb1af1e8730f50b18d04eb2af3029">More...</a><br /></td></tr>
<tr class="separator:a581cb1af1e8730f50b18d04eb2af3029"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:adad4893d4f51aaa40d60d946915ae41f"><td class="memTemplParams" colspan="2">template&lt;class VVT , class HVT , class MT , unsigned int ROWS&gt; </td></tr>
<tr class="memitem:adad4893d4f51aaa40d60d946915ae41f"><td class="memTemplItemLeft" align="right" valign="top">const MT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#adad4893d4f51aaa40d60d946915ae41f">operator*</a> (double k, const <a class="el" href="classCGLA_1_1ArithMatFloat.html">ArithMatFloat</a>&lt; VVT, HVT, MT, ROWS &gt; &amp;v)</td></tr>
<tr class="memdesc:adad4893d4f51aaa40d60d946915ae41f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply scalar onto matrix.  <a href="namespaceCGLA.html#adad4893d4f51aaa40d60d946915ae41f">More...</a><br /></td></tr>
<tr class="separator:adad4893d4f51aaa40d60d946915ae41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac082a48cbbf6ed5191769be17d97f7ad"><td class="memTemplParams" colspan="2">template&lt;class VVT , class HVT , class MT , unsigned int ROWS&gt; </td></tr>
<tr class="memitem:ac082a48cbbf6ed5191769be17d97f7ad"><td class="memTemplItemLeft" align="right" valign="top">const MT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#ac082a48cbbf6ed5191769be17d97f7ad">operator*</a> (float k, const <a class="el" href="classCGLA_1_1ArithMatFloat.html">ArithMatFloat</a>&lt; VVT, HVT, MT, ROWS &gt; &amp;v)</td></tr>
<tr class="memdesc:ac082a48cbbf6ed5191769be17d97f7ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply scalar onto matrix.  <a href="namespaceCGLA.html#ac082a48cbbf6ed5191769be17d97f7ad">More...</a><br /></td></tr>
<tr class="separator:ac082a48cbbf6ed5191769be17d97f7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad864dcf89490514a24f6e33835a5f887"><td class="memTemplParams" colspan="2">template&lt;class VVT , class HVT , class MT , unsigned int ROWS&gt; </td></tr>
<tr class="memitem:ad864dcf89490514a24f6e33835a5f887"><td class="memTemplItemLeft" align="right" valign="top">const MT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#ad864dcf89490514a24f6e33835a5f887">operator*</a> (int k, const <a class="el" href="classCGLA_1_1ArithMatFloat.html">ArithMatFloat</a>&lt; VVT, HVT, MT, ROWS &gt; &amp;v)</td></tr>
<tr class="memdesc:ad864dcf89490514a24f6e33835a5f887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply scalar onto matrix.  <a href="namespaceCGLA.html#ad864dcf89490514a24f6e33835a5f887">More...</a><br /></td></tr>
<tr class="separator:ad864dcf89490514a24f6e33835a5f887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef9672a724549701fafc9d1e1a3144a"><td class="memTemplParams" colspan="2">template&lt;class VVT , class HVT , class MT , unsigned int ROWS&gt; </td></tr>
<tr class="memitem:a6ef9672a724549701fafc9d1e1a3144a"><td class="memTemplItemLeft" align="right" valign="top">VVT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a6ef9672a724549701fafc9d1e1a3144a">operator*</a> (const <a class="el" href="classCGLA_1_1ArithMatFloat.html">ArithMatFloat</a>&lt; VVT, HVT, MT, ROWS &gt; &amp;m, const HVT &amp;v)</td></tr>
<tr class="memdesc:a6ef9672a724549701fafc9d1e1a3144a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply vector onto matrix.  <a href="namespaceCGLA.html#a6ef9672a724549701fafc9d1e1a3144a">More...</a><br /></td></tr>
<tr class="separator:a6ef9672a724549701fafc9d1e1a3144a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd2718d8fd0d03d2a7e6e2c4af30c6f"><td class="memTemplParams" colspan="2">template&lt;class VVT , class HVT , class HV1T , class VV2T , class MT1 , class MT2 , class MT , unsigned int ROWS1, unsigned int ROWS2&gt; </td></tr>
<tr class="memitem:aebd2718d8fd0d03d2a7e6e2c4af30c6f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#aebd2718d8fd0d03d2a7e6e2c4af30c6f">mul</a> (const <a class="el" href="classCGLA_1_1ArithMatFloat.html">ArithMatFloat</a>&lt; VVT, HV1T, MT1, ROWS1 &gt; &amp;m1, const <a class="el" href="classCGLA_1_1ArithMatFloat.html">ArithMatFloat</a>&lt; VV2T, HVT, MT2, ROWS2 &gt; &amp;m2, <a class="el" href="classCGLA_1_1ArithMatFloat.html">ArithMatFloat</a>&lt; VVT, HVT, MT, ROWS1 &gt; &amp;m)</td></tr>
<tr class="memdesc:aebd2718d8fd0d03d2a7e6e2c4af30c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two arbitrary matrices.  <a href="namespaceCGLA.html#aebd2718d8fd0d03d2a7e6e2c4af30c6f">More...</a><br /></td></tr>
<tr class="separator:aebd2718d8fd0d03d2a7e6e2c4af30c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab84fd049a46bbbda751e1f94bba0620"><td class="memTemplParams" colspan="2">template&lt;class VVT , class HVT , class M1T , class M2T , unsigned int ROWS, unsigned int COLS&gt; </td></tr>
<tr class="memitem:aab84fd049a46bbbda751e1f94bba0620"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#aab84fd049a46bbbda751e1f94bba0620">transpose</a> (const <a class="el" href="classCGLA_1_1ArithMatFloat.html">ArithMatFloat</a>&lt; VVT, HVT, M1T, ROWS &gt; &amp;m, <a class="el" href="classCGLA_1_1ArithMatFloat.html">ArithMatFloat</a>&lt; HVT, VVT, M2T, COLS &gt; &amp;m_new)</td></tr>
<tr class="memdesc:aab84fd049a46bbbda751e1f94bba0620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose.  <a href="namespaceCGLA.html#aab84fd049a46bbbda751e1f94bba0620">More...</a><br /></td></tr>
<tr class="separator:aab84fd049a46bbbda751e1f94bba0620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb930b95b35130d05151258e9e821354"><td class="memTemplParams" colspan="2">template&lt;class VVT , class HVT , class MT , unsigned int ROWS&gt; </td></tr>
<tr class="memitem:afb930b95b35130d05151258e9e821354"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#afb930b95b35130d05151258e9e821354">outer_product</a> (const VVT &amp;a, const HVT &amp;b, <a class="el" href="classCGLA_1_1ArithMatFloat.html">ArithMatFloat</a>&lt; VVT, HVT, MT, ROWS &gt; &amp;m)</td></tr>
<tr class="memdesc:afb930b95b35130d05151258e9e821354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the outer product of a and b: a * transpose(b).  <a href="namespaceCGLA.html#afb930b95b35130d05151258e9e821354">More...</a><br /></td></tr>
<tr class="separator:afb930b95b35130d05151258e9e821354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58fc6f7e860dd0b68cd28baa553afbd"><td class="memTemplParams" colspan="2">template&lt;class VVT , class HVT , class MT , int ROWS, class BinOp &gt; </td></tr>
<tr class="memitem:ad58fc6f7e860dd0b68cd28baa553afbd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#ad58fc6f7e860dd0b68cd28baa553afbd">outer_product</a> (const VVT &amp;a, const HVT &amp;b, <a class="el" href="classCGLA_1_1ArithMatFloat.html">ArithMatFloat</a>&lt; VVT, HVT, MT, ROWS &gt; &amp;m, BinOp op)</td></tr>
<tr class="memdesc:ad58fc6f7e860dd0b68cd28baa553afbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the outer product of a and b using an arbitrary binary operation: op(a, transpose(b)).  <a href="namespaceCGLA.html#ad58fc6f7e860dd0b68cd28baa553afbd">More...</a><br /></td></tr>
<tr class="separator:ad58fc6f7e860dd0b68cd28baa553afbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85f11744ad0e4f12d4c5617f8f3ddce"><td class="memTemplParams" colspan="2">template&lt;class M1 , class M2 &gt; </td></tr>
<tr class="memitem:ab85f11744ad0e4f12d4c5617f8f3ddce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#ab85f11744ad0e4f12d4c5617f8f3ddce">copy_matrix</a> (const M1 &amp;inmat, M2 &amp;outmat)</td></tr>
<tr class="memdesc:ab85f11744ad0e4f12d4c5617f8f3ddce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a matrix to another matrix, cell by cell.  <a href="namespaceCGLA.html#ab85f11744ad0e4f12d4c5617f8f3ddce">More...</a><br /></td></tr>
<tr class="separator:ab85f11744ad0e4f12d4c5617f8f3ddce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79ce13057e87a811d100d11e5da4db9"><td class="memTemplParams" colspan="2">template&lt;class VVT , class HVT , class MT , unsigned int ROWS&gt; </td></tr>
<tr class="memitem:ac79ce13057e87a811d100d11e5da4db9"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#ac79ce13057e87a811d100d11e5da4db9">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classCGLA_1_1ArithMatFloat.html">ArithMatFloat</a>&lt; VVT, HVT, MT, ROWS &gt; &amp;m)</td></tr>
<tr class="memdesc:ac79ce13057e87a811d100d11e5da4db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put to operator.  <a href="namespaceCGLA.html#ac79ce13057e87a811d100d11e5da4db9">More...</a><br /></td></tr>
<tr class="separator:ac79ce13057e87a811d100d11e5da4db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29dd642214f5e58cf2b2184b1043754"><td class="memTemplParams" colspan="2">template&lt;class VVT , class HVT , class MT , unsigned int ROWS&gt; </td></tr>
<tr class="memitem:ae29dd642214f5e58cf2b2184b1043754"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#ae29dd642214f5e58cf2b2184b1043754">operator&gt;&gt;</a> (std::istream &amp;is, const <a class="el" href="classCGLA_1_1ArithMatFloat.html">ArithMatFloat</a>&lt; VVT, HVT, MT, ROWS &gt; &amp;m)</td></tr>
<tr class="memdesc:ae29dd642214f5e58cf2b2184b1043754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get from operator.  <a href="namespaceCGLA.html#ae29dd642214f5e58cf2b2184b1043754">More...</a><br /></td></tr>
<tr class="separator:ae29dd642214f5e58cf2b2184b1043754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde7465256593ade72927ebe1b6649a0"><td class="memTemplParams" colspan="2"><a id="afde7465256593ade72927ebe1b6649a0"></a>
template&lt;class T , class V , class Q &gt; </td></tr>
<tr class="memitem:afde7465256593ade72927ebe1b6649a0"><td class="memTemplItemLeft" align="right" valign="top">Q&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (T scalar, const <a class="el" href="classCGLA_1_1ArithQuat.html">ArithQuat</a>&lt; T, V, Q &gt; &amp;q)</td></tr>
<tr class="separator:afde7465256593ade72927ebe1b6649a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc32f3f28e32530aa847de091191bfa1"><td class="memTemplParams" colspan="2">template&lt;class T , class V , class Q &gt; </td></tr>
<tr class="memitem:afc32f3f28e32530aa847de091191bfa1"><td class="memTemplItemLeft" align="right" valign="top">Q&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#afc32f3f28e32530aa847de091191bfa1">slerp</a> (const <a class="el" href="classCGLA_1_1ArithQuat.html">ArithQuat</a>&lt; T, V, Q &gt; &amp;q0, const <a class="el" href="classCGLA_1_1ArithQuat.html">ArithQuat</a>&lt; T, V, Q &gt; &amp;q1, T t)</td></tr>
<tr class="memdesc:afc32f3f28e32530aa847de091191bfa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform linear interpolation of two quaternions.  <a href="namespaceCGLA.html#afc32f3f28e32530aa847de091191bfa1">More...</a><br /></td></tr>
<tr class="separator:afc32f3f28e32530aa847de091191bfa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af641bcf3953a951950b72027476cbcc5"><td class="memTemplParams" colspan="2">template&lt;class T , class V , class Q &gt; </td></tr>
<tr class="memitem:af641bcf3953a951950b72027476cbcc5"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#af641bcf3953a951950b72027476cbcc5">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classCGLA_1_1ArithQuat.html">ArithQuat</a>&lt; T, V, Q &gt; &amp;v)</td></tr>
<tr class="memdesc:af641bcf3953a951950b72027476cbcc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print quaternion to stream.  <a href="namespaceCGLA.html#af641bcf3953a951950b72027476cbcc5">More...</a><br /></td></tr>
<tr class="separator:af641bcf3953a951950b72027476cbcc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b9ab31318195fe22870c62e976df64"><td class="memItemLeft" align="right" valign="top"><a id="a11b9ab31318195fe22870c62e976df64"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CGLA_DERIVEEXCEPTION</b> (Mat2x2fException)</td></tr>
<tr class="separator:a11b9ab31318195fe22870c62e976df64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef116ec68dc27722ebf5d7359646c156"><td class="memTemplParams" colspan="2">template&lt;class V , class M &gt; </td></tr>
<tr class="memitem:aef116ec68dc27722ebf5d7359646c156"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCGLA_1_1ArithSqMat2x2Float.html">ArithSqMat2x2Float</a>&lt; V, M &gt;::ScalarType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#aef116ec68dc27722ebf5d7359646c156">determinant</a> (const <a class="el" href="classCGLA_1_1ArithSqMat2x2Float.html">ArithSqMat2x2Float</a>&lt; V, M &gt; &amp;m)</td></tr>
<tr class="memdesc:aef116ec68dc27722ebf5d7359646c156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the determinant of a <a class="el" href="classCGLA_1_1Mat2x2f.html" title="Two by two float matrix.">Mat2x2f</a>.  <a href="namespaceCGLA.html#aef116ec68dc27722ebf5d7359646c156">More...</a><br /></td></tr>
<tr class="separator:aef116ec68dc27722ebf5d7359646c156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37687a2508e2e2541844a640570b8343"><td class="memTemplParams" colspan="2"><a id="a37687a2508e2e2541844a640570b8343"></a>
template&lt;class V , class M &gt; </td></tr>
<tr class="memitem:a37687a2508e2e2541844a640570b8343"><td class="memTemplItemLeft" align="right" valign="top">const M&#160;</td><td class="memTemplItemRight" valign="bottom"><b>invert</b> (const <a class="el" href="classCGLA_1_1ArithSqMat2x2Float.html">ArithSqMat2x2Float</a>&lt; V, M &gt; &amp;m)</td></tr>
<tr class="separator:a37687a2508e2e2541844a640570b8343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff067942779c6eaa864faf80a2d841d9"><td class="memTemplParams" colspan="2">template&lt;class V , class M &gt; </td></tr>
<tr class="memitem:aff067942779c6eaa864faf80a2d841d9"><td class="memTemplItemLeft" align="right" valign="top">M&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#aff067942779c6eaa864faf80a2d841d9">invert</a> (const <a class="el" href="classCGLA_1_1ArithSqMat3x3Float.html">ArithSqMat3x3Float</a>&lt; V, M &gt; &amp;)</td></tr>
<tr class="memdesc:aff067942779c6eaa864faf80a2d841d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert 3x3 matrix.  <a href="namespaceCGLA.html#aff067942779c6eaa864faf80a2d841d9">More...</a><br /></td></tr>
<tr class="separator:aff067942779c6eaa864faf80a2d841d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f4f874118836b2bd1fd9366ea2750e"><td class="memTemplParams" colspan="2">template&lt;class V , class M &gt; </td></tr>
<tr class="memitem:af6f4f874118836b2bd1fd9366ea2750e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCGLA_1_1ArithSqMat3x3Float.html">ArithSqMat3x3Float</a>&lt; V, M &gt;::ScalarType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#af6f4f874118836b2bd1fd9366ea2750e">determinant</a> (const <a class="el" href="classCGLA_1_1ArithSqMat3x3Float.html">ArithSqMat3x3Float</a>&lt; V, M &gt; &amp;m)</td></tr>
<tr class="memdesc:af6f4f874118836b2bd1fd9366ea2750e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute determinant.  <a href="namespaceCGLA.html#af6f4f874118836b2bd1fd9366ea2750e">More...</a><br /></td></tr>
<tr class="separator:af6f4f874118836b2bd1fd9366ea2750e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e471bdf7c8149d66242904a0e8844e0"><td class="memTemplParams" colspan="2">template&lt;class VT , class M &gt; </td></tr>
<tr class="memitem:a1e471bdf7c8149d66242904a0e8844e0"><td class="memTemplItemLeft" align="right" valign="top">M&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a1e471bdf7c8149d66242904a0e8844e0">adjoint</a> (const <a class="el" href="classCGLA_1_1ArithSqMat4x4Float.html">ArithSqMat4x4Float</a>&lt; VT, M &gt; &amp;)</td></tr>
<tr class="memdesc:a1e471bdf7c8149d66242904a0e8844e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the adjoint of a matrix.  <a href="namespaceCGLA.html#a1e471bdf7c8149d66242904a0e8844e0">More...</a><br /></td></tr>
<tr class="separator:a1e471bdf7c8149d66242904a0e8844e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0172f048d67b881b4eb1dc6aeadef82"><td class="memTemplParams" colspan="2">template&lt;class V , class M &gt; </td></tr>
<tr class="memitem:ab0172f048d67b881b4eb1dc6aeadef82"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#ab0172f048d67b881b4eb1dc6aeadef82">determinant</a> (const <a class="el" href="classCGLA_1_1ArithSqMat4x4Float.html">ArithSqMat4x4Float</a>&lt; V, M &gt; &amp;m)</td></tr>
<tr class="memdesc:ab0172f048d67b881b4eb1dc6aeadef82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the determinant of a 4x4 matrix.  <a href="namespaceCGLA.html#ab0172f048d67b881b4eb1dc6aeadef82">More...</a><br /></td></tr>
<tr class="separator:ab0172f048d67b881b4eb1dc6aeadef82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65fb80ecad0a3dcfc41389a9158d75d2"><td class="memTemplParams" colspan="2">template&lt;class VT , class M &gt; </td></tr>
<tr class="memitem:a65fb80ecad0a3dcfc41389a9158d75d2"><td class="memTemplItemLeft" align="right" valign="top">M&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a65fb80ecad0a3dcfc41389a9158d75d2">invert</a> (const <a class="el" href="classCGLA_1_1ArithSqMat4x4Float.html">ArithSqMat4x4Float</a>&lt; VT, M &gt; &amp;)</td></tr>
<tr class="memdesc:a65fb80ecad0a3dcfc41389a9158d75d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inverse matrix of a <a class="el" href="classCGLA_1_1Mat4x4f.html" title="4x4 float matrix.">Mat4x4f</a>.  <a href="namespaceCGLA.html#a65fb80ecad0a3dcfc41389a9158d75d2">More...</a><br /></td></tr>
<tr class="separator:a65fb80ecad0a3dcfc41389a9158d75d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6608f53fd1a92566fab9956ab8908d"><td class="memTemplParams" colspan="2">template&lt;class VT , class M &gt; </td></tr>
<tr class="memitem:aca6608f53fd1a92566fab9956ab8908d"><td class="memTemplItemLeft" align="right" valign="top">M&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#aca6608f53fd1a92566fab9956ab8908d">invert_affine</a> (const <a class="el" href="classCGLA_1_1ArithSqMat4x4Float.html">ArithSqMat4x4Float</a>&lt; VT, M &gt; &amp;)</td></tr>
<tr class="memdesc:aca6608f53fd1a92566fab9956ab8908d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inverse matrix of a <a class="el" href="classCGLA_1_1Mat4x4f.html" title="4x4 float matrix.">Mat4x4f</a> that is affine.  <a href="namespaceCGLA.html#aca6608f53fd1a92566fab9956ab8908d">More...</a><br /></td></tr>
<tr class="separator:aca6608f53fd1a92566fab9956ab8908d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74dd48bd255a497ffc024e71098c13b3"><td class="memTemplParams" colspan="2">template&lt;class VT , class MT , unsigned int ROWS&gt; </td></tr>
<tr class="memitem:a74dd48bd255a497ffc024e71098c13b3"><td class="memTemplItemLeft" align="right" valign="top">MT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a74dd48bd255a497ffc024e71098c13b3">operator*</a> (const <a class="el" href="classCGLA_1_1ArithSqMatFloat.html">ArithSqMatFloat</a>&lt; VT, MT, ROWS &gt; &amp;m1, const <a class="el" href="classCGLA_1_1ArithSqMatFloat.html">ArithSqMatFloat</a>&lt; VT, MT, ROWS &gt; &amp;m2)</td></tr>
<tr class="memdesc:a74dd48bd255a497ffc024e71098c13b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two matrices derived from same type, producing a new of same type.  <a href="namespaceCGLA.html#a74dd48bd255a497ffc024e71098c13b3">More...</a><br /></td></tr>
<tr class="separator:a74dd48bd255a497ffc024e71098c13b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbf3e7f447cc3e38624332103960a11"><td class="memTemplParams" colspan="2">template&lt;class VT , class MT , unsigned int ROWS&gt; </td></tr>
<tr class="memitem:a1cbf3e7f447cc3e38624332103960a11"><td class="memTemplItemLeft" align="right" valign="top">MT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a1cbf3e7f447cc3e38624332103960a11">transpose</a> (const <a class="el" href="classCGLA_1_1ArithSqMatFloat.html">ArithSqMatFloat</a>&lt; VT, MT, ROWS &gt; &amp;m)</td></tr>
<tr class="memdesc:a1cbf3e7f447cc3e38624332103960a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the transpose of a square matrix.  <a href="namespaceCGLA.html#a1cbf3e7f447cc3e38624332103960a11">More...</a><br /></td></tr>
<tr class="separator:a1cbf3e7f447cc3e38624332103960a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c51c159d5501d6e4c32441ea9061aa"><td class="memTemplParams" colspan="2">template&lt;class VT , class MT , unsigned int ROWS&gt; </td></tr>
<tr class="memitem:a97c51c159d5501d6e4c32441ea9061aa"><td class="memTemplItemLeft" align="right" valign="top">MT::ScalarType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a97c51c159d5501d6e4c32441ea9061aa">trace</a> (const <a class="el" href="classCGLA_1_1ArithSqMatFloat.html">ArithSqMatFloat</a>&lt; VT, MT, ROWS &gt; &amp;M)</td></tr>
<tr class="memdesc:a97c51c159d5501d6e4c32441ea9061aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute trace. Works only for sq. matrices.  <a href="namespaceCGLA.html#a97c51c159d5501d6e4c32441ea9061aa">More...</a><br /></td></tr>
<tr class="separator:a97c51c159d5501d6e4c32441ea9061aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb32d0780d99709e882f1b7ed7b0250b"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:afb32d0780d99709e882f1b7ed7b0250b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCGLA_1_1VecT__to__MatT.html">VecT_to_MatT</a>&lt; V &gt;::MatT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#afb32d0780d99709e882f1b7ed7b0250b">outer_product</a> (const V &amp;a, const V &amp;b)</td></tr>
<tr class="memdesc:afb32d0780d99709e882f1b7ed7b0250b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the outer product of a and b: a * transpose(b).  <a href="namespaceCGLA.html#afb32d0780d99709e882f1b7ed7b0250b">More...</a><br /></td></tr>
<tr class="separator:afb32d0780d99709e882f1b7ed7b0250b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d83238b33f0418f170f9cc27ad8943"><td class="memTemplParams" colspan="2"><a id="a92d83238b33f0418f170f9cc27ad8943"></a>
template&lt;class T , class V , unsigned int N&gt; </td></tr>
<tr class="memitem:a92d83238b33f0418f170f9cc27ad8943"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classCGLA_1_1ArithVec.html">ArithVec</a>&lt; T, V, N &gt; &amp;v)</td></tr>
<tr class="separator:a92d83238b33f0418f170f9cc27ad8943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2087af59716d5b2190c38b74fcd95e"><td class="memTemplParams" colspan="2">template&lt;class T , class V , unsigned int N&gt; </td></tr>
<tr class="memitem:a4a2087af59716d5b2190c38b74fcd95e"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a4a2087af59716d5b2190c38b74fcd95e">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classCGLA_1_1ArithVec.html">ArithVec</a>&lt; T, V, N &gt; &amp;v)</td></tr>
<tr class="memdesc:a4a2087af59716d5b2190c38b74fcd95e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get from operator for <a class="el" href="classCGLA_1_1ArithVec.html" title="Template representing generic arithmetic vectors.">ArithVec</a> descendants.  <a href="namespaceCGLA.html#a4a2087af59716d5b2190c38b74fcd95e">More...</a><br /></td></tr>
<tr class="separator:a4a2087af59716d5b2190c38b74fcd95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7824214991e543ff96d40f904cdbe7c1"><td class="memTemplParams" colspan="2">template&lt;class T , class V , unsigned int N&gt; </td></tr>
<tr class="memitem:a7824214991e543ff96d40f904cdbe7c1"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a7824214991e543ff96d40f904cdbe7c1">dot</a> (const <a class="el" href="classCGLA_1_1ArithVec.html">ArithVec</a>&lt; T, V, N &gt; &amp;v0, const <a class="el" href="classCGLA_1_1ArithVec.html">ArithVec</a>&lt; T, V, N &gt; &amp;v1)</td></tr>
<tr class="memdesc:a7824214991e543ff96d40f904cdbe7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product for two vectors.  <a href="namespaceCGLA.html#a7824214991e543ff96d40f904cdbe7c1">More...</a><br /></td></tr>
<tr class="separator:a7824214991e543ff96d40f904cdbe7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7dadba9d869969d027cb1380d7b5818"><td class="memTemplParams" colspan="2">template&lt;class T , class V , unsigned int N&gt; </td></tr>
<tr class="memitem:ad7dadba9d869969d027cb1380d7b5818"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#ad7dadba9d869969d027cb1380d7b5818">sqr_length</a> (const <a class="el" href="classCGLA_1_1ArithVec.html">ArithVec</a>&lt; T, V, N &gt; &amp;v)</td></tr>
<tr class="memdesc:ad7dadba9d869969d027cb1380d7b5818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sqr length by taking dot product of vector with itself.  <a href="namespaceCGLA.html#ad7dadba9d869969d027cb1380d7b5818">More...</a><br /></td></tr>
<tr class="separator:ad7dadba9d869969d027cb1380d7b5818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa632ea3d0b7d506a4db1f1032780b382"><td class="memTemplParams" colspan="2">template&lt;class T , class V , unsigned int N&gt; </td></tr>
<tr class="memitem:aa632ea3d0b7d506a4db1f1032780b382"><td class="memTemplItemLeft" align="right" valign="top">const V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#aa632ea3d0b7d506a4db1f1032780b382">operator*</a> (double k, const <a class="el" href="classCGLA_1_1ArithVec.html">ArithVec</a>&lt; T, V, N &gt; &amp;v)</td></tr>
<tr class="memdesc:aa632ea3d0b7d506a4db1f1032780b382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply double onto vector.  <a href="namespaceCGLA.html#aa632ea3d0b7d506a4db1f1032780b382">More...</a><br /></td></tr>
<tr class="separator:aa632ea3d0b7d506a4db1f1032780b382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d1d84a9a0bd6d61b9d053ad540413c"><td class="memTemplParams" colspan="2">template&lt;class T , class V , unsigned int N&gt; </td></tr>
<tr class="memitem:ab6d1d84a9a0bd6d61b9d053ad540413c"><td class="memTemplItemLeft" align="right" valign="top">const V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#ab6d1d84a9a0bd6d61b9d053ad540413c">operator*</a> (float k, const <a class="el" href="classCGLA_1_1ArithVec.html">ArithVec</a>&lt; T, V, N &gt; &amp;v)</td></tr>
<tr class="memdesc:ab6d1d84a9a0bd6d61b9d053ad540413c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply float onto vector.  <a href="namespaceCGLA.html#ab6d1d84a9a0bd6d61b9d053ad540413c">More...</a><br /></td></tr>
<tr class="separator:ab6d1d84a9a0bd6d61b9d053ad540413c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7935023b32719512b23ca80ad6a57218"><td class="memTemplParams" colspan="2">template&lt;class T , class V , unsigned int N&gt; </td></tr>
<tr class="memitem:a7935023b32719512b23ca80ad6a57218"><td class="memTemplItemLeft" align="right" valign="top">const V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a7935023b32719512b23ca80ad6a57218">operator*</a> (int k, const <a class="el" href="classCGLA_1_1ArithVec.html">ArithVec</a>&lt; T, V, N &gt; &amp;v)</td></tr>
<tr class="memdesc:a7935023b32719512b23ca80ad6a57218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply unsigned int onto vector.  <a href="namespaceCGLA.html#a7935023b32719512b23ca80ad6a57218">More...</a><br /></td></tr>
<tr class="separator:a7935023b32719512b23ca80ad6a57218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d9843a9df34cf8563e01fa1688dd5a"><td class="memTemplParams" colspan="2">template&lt;class T , class V , unsigned int N&gt; </td></tr>
<tr class="memitem:a05d9843a9df34cf8563e01fa1688dd5a"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a05d9843a9df34cf8563e01fa1688dd5a">v_min</a> (const <a class="el" href="classCGLA_1_1ArithVec.html">ArithVec</a>&lt; T, V, N &gt; &amp;v0, const <a class="el" href="classCGLA_1_1ArithVec.html">ArithVec</a>&lt; T, V, N &gt; &amp;v1)</td></tr>
<tr class="memdesc:a05d9843a9df34cf8563e01fa1688dd5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vector containing for each coordinate the smallest value from two vectors.  <a href="namespaceCGLA.html#a05d9843a9df34cf8563e01fa1688dd5a">More...</a><br /></td></tr>
<tr class="separator:a05d9843a9df34cf8563e01fa1688dd5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226d2bca97dde95500b02e7e95ce3746"><td class="memTemplParams" colspan="2">template&lt;class T , class V , unsigned int N&gt; </td></tr>
<tr class="memitem:a226d2bca97dde95500b02e7e95ce3746"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a226d2bca97dde95500b02e7e95ce3746">v_max</a> (const <a class="el" href="classCGLA_1_1ArithVec.html">ArithVec</a>&lt; T, V, N &gt; &amp;v0, const <a class="el" href="classCGLA_1_1ArithVec.html">ArithVec</a>&lt; T, V, N &gt; &amp;v1)</td></tr>
<tr class="memdesc:a226d2bca97dde95500b02e7e95ce3746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vector containing for each coordinate the largest value from two vectors.  <a href="namespaceCGLA.html#a226d2bca97dde95500b02e7e95ce3746">More...</a><br /></td></tr>
<tr class="separator:a226d2bca97dde95500b02e7e95ce3746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e1c64372c70216020b898b820caf03"><td class="memTemplParams" colspan="2">template&lt;class T , class V &gt; </td></tr>
<tr class="memitem:ac7e1c64372c70216020b898b820caf03"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#ac7e1c64372c70216020b898b820caf03">orthogonal</a> (const <a class="el" href="classCGLA_1_1ArithVec2Float.html">ArithVec2Float</a>&lt; T, V &gt; &amp;v)</td></tr>
<tr class="memdesc:ac7e1c64372c70216020b898b820caf03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates vector 90 degrees to obtain orthogonal vector.  <a href="namespaceCGLA.html#ac7e1c64372c70216020b898b820caf03">More...</a><br /></td></tr>
<tr class="separator:ac7e1c64372c70216020b898b820caf03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71cf8a486fa281e4974cd1fe4b54085"><td class="memTemplParams" colspan="2"><a id="af71cf8a486fa281e4974cd1fe4b54085"></a>
template&lt;class T , class V &gt; </td></tr>
<tr class="memitem:af71cf8a486fa281e4974cd1fe4b54085"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cross</b> (const <a class="el" href="classCGLA_1_1ArithVec2Float.html">ArithVec2Float</a>&lt; T, V &gt; &amp;a, const <a class="el" href="classCGLA_1_1ArithVec2Float.html">ArithVec2Float</a>&lt; T, V &gt; &amp;b)</td></tr>
<tr class="separator:af71cf8a486fa281e4974cd1fe4b54085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4303bdb4c02280511ff4f08c9127302"><td class="memTemplParams" colspan="2">template&lt;class T , class V &gt; </td></tr>
<tr class="memitem:ac4303bdb4c02280511ff4f08c9127302"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#ac4303bdb4c02280511ff4f08c9127302">linear_combine</a> (const <a class="el" href="classCGLA_1_1ArithVec2Float.html">ArithVec2Float</a>&lt; T, V &gt; &amp;a, const <a class="el" href="classCGLA_1_1ArithVec2Float.html">ArithVec2Float</a>&lt; T, V &gt; &amp;b, const <a class="el" href="classCGLA_1_1ArithVec2Float.html">ArithVec2Float</a>&lt; T, V &gt; &amp;c, T &amp;, T &amp;)</td></tr>
<tr class="memdesc:ac4303bdb4c02280511ff4f08c9127302"><td class="mdescLeft">&#160;</td><td class="mdescRight">The two last (scalar) arguments are the linear combination of the two first arguments (vectors) which produces the third argument.  <a href="namespaceCGLA.html#ac4303bdb4c02280511ff4f08c9127302">More...</a><br /></td></tr>
<tr class="separator:ac4303bdb4c02280511ff4f08c9127302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a441523df91e127eabe5a2d2e98724"><td class="memTemplParams" colspan="2">template&lt;class T , class V &gt; </td></tr>
<tr class="memitem:a68a441523df91e127eabe5a2d2e98724"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a68a441523df91e127eabe5a2d2e98724">cross</a> (const <a class="el" href="classCGLA_1_1ArithVec3Float.html">ArithVec3Float</a>&lt; T, V &gt; &amp;x, const <a class="el" href="classCGLA_1_1ArithVec3Float.html">ArithVec3Float</a>&lt; T, V &gt; &amp;y)</td></tr>
<tr class="memdesc:a68a441523df91e127eabe5a2d2e98724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns cross product of arguments.  <a href="namespaceCGLA.html#a68a441523df91e127eabe5a2d2e98724">More...</a><br /></td></tr>
<tr class="separator:a68a441523df91e127eabe5a2d2e98724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f239eee3df119f280913bae1715949f"><td class="memTemplParams" colspan="2">template&lt;class T , class V &gt; </td></tr>
<tr class="memitem:a9f239eee3df119f280913bae1715949f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a9f239eee3df119f280913bae1715949f">orthogonal</a> (const <a class="el" href="classCGLA_1_1ArithVec3Float.html">ArithVec3Float</a>&lt; T, V &gt; &amp;, <a class="el" href="classCGLA_1_1ArithVec3Float.html">ArithVec3Float</a>&lt; T, V &gt; &amp;, <a class="el" href="classCGLA_1_1ArithVec3Float.html">ArithVec3Float</a>&lt; T, V &gt; &amp;)</td></tr>
<tr class="memdesc:a9f239eee3df119f280913bae1715949f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute basis of orthogonal plane.  <a href="namespaceCGLA.html#a9f239eee3df119f280913bae1715949f">More...</a><br /></td></tr>
<tr class="separator:a9f239eee3df119f280913bae1715949f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30641cd7014fd49260079844dd843b1"><td class="memTemplParams" colspan="2">template&lt;class T , class V &gt; </td></tr>
<tr class="memitem:af30641cd7014fd49260079844dd843b1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#af30641cd7014fd49260079844dd843b1">onb</a> (const <a class="el" href="classCGLA_1_1ArithVec3Float.html">ArithVec3Float</a>&lt; T, V &gt; &amp;, <a class="el" href="classCGLA_1_1ArithVec3Float.html">ArithVec3Float</a>&lt; T, V &gt; &amp;, <a class="el" href="classCGLA_1_1ArithVec3Float.html">ArithVec3Float</a>&lt; T, V &gt; &amp;)</td></tr>
<tr class="memdesc:af30641cd7014fd49260079844dd843b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build an orthonormal basis from a 3d unit vector [Frisvad 2012].  <a href="namespaceCGLA.html#af30641cd7014fd49260079844dd843b1">More...</a><br /></td></tr>
<tr class="separator:af30641cd7014fd49260079844dd843b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3cfe2a1fc29650a488ccf0add2f3326"><td class="memTemplParams" colspan="2">template&lt;class T , class V &gt; </td></tr>
<tr class="memitem:ae3cfe2a1fc29650a488ccf0add2f3326"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#ae3cfe2a1fc29650a488ccf0add2f3326">cross</a> (const <a class="el" href="classCGLA_1_1ArithVec3Int.html">ArithVec3Int</a>&lt; T, V &gt; &amp;x, const <a class="el" href="classCGLA_1_1ArithVec3Int.html">ArithVec3Int</a>&lt; T, V &gt; &amp;y)</td></tr>
<tr class="memdesc:ae3cfe2a1fc29650a488ccf0add2f3326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns cross product of arguments.  <a href="namespaceCGLA.html#ae3cfe2a1fc29650a488ccf0add2f3326">More...</a><br /></td></tr>
<tr class="separator:ae3cfe2a1fc29650a488ccf0add2f3326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a417f58451a8d2ac147330475a4d554"><td class="memTemplParams" colspan="2">template&lt;class T , class V , unsigned int N&gt; </td></tr>
<tr class="memitem:a5a417f58451a8d2ac147330475a4d554"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a5a417f58451a8d2ac147330475a4d554">length</a> (const <a class="el" href="classCGLA_1_1ArithVecFloat.html">ArithVecFloat</a>&lt; T, V, N &gt; &amp;v)</td></tr>
<tr class="memdesc:a5a417f58451a8d2ac147330475a4d554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns length of vector.  <a href="namespaceCGLA.html#a5a417f58451a8d2ac147330475a4d554">More...</a><br /></td></tr>
<tr class="separator:a5a417f58451a8d2ac147330475a4d554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af473ad0eedf28a08e4b83fafe6b0bced"><td class="memTemplParams" colspan="2">template&lt;class T , class V , unsigned int N&gt; </td></tr>
<tr class="memitem:af473ad0eedf28a08e4b83fafe6b0bced"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#af473ad0eedf28a08e4b83fafe6b0bced">normalize</a> (const <a class="el" href="classCGLA_1_1ArithVecFloat.html">ArithVecFloat</a>&lt; T, V, N &gt; &amp;v)</td></tr>
<tr class="memdesc:af473ad0eedf28a08e4b83fafe6b0bced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns normalized vector.  <a href="namespaceCGLA.html#af473ad0eedf28a08e4b83fafe6b0bced">More...</a><br /></td></tr>
<tr class="separator:af473ad0eedf28a08e4b83fafe6b0bced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa293205b7806032f437552d8e6cff75f"><td class="memTemplParams" colspan="2">template&lt;class T , class V , unsigned int N&gt; </td></tr>
<tr class="memitem:aa293205b7806032f437552d8e6cff75f"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#aa293205b7806032f437552d8e6cff75f">cond_normalize</a> (const <a class="el" href="classCGLA_1_1ArithVecFloat.html">ArithVecFloat</a>&lt; T, V, N &gt; &amp;v)</td></tr>
<tr class="memdesc:aa293205b7806032f437552d8e6cff75f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns normalized vector if the vector has non-zero length - otherwise the 0 vector.  <a href="namespaceCGLA.html#aa293205b7806032f437552d8e6cff75f">More...</a><br /></td></tr>
<tr class="separator:aa293205b7806032f437552d8e6cff75f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99747ffef2b4adb259ef7f09c0720f92"><td class="memItemLeft" align="right" valign="top"><a id="a99747ffef2b4adb259ef7f09c0720f92"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>cgla_nan</b> ()</td></tr>
<tr class="separator:a99747ffef2b4adb259ef7f09c0720f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1b914751c1b6bfe1318f96290ec289"><td class="memItemLeft" align="right" valign="top"><a id="a5d1b914751c1b6bfe1318f96290ec289"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>sqrt3</b> ()</td></tr>
<tr class="separator:a5d1b914751c1b6bfe1318f96290ec289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30070ae683d2c9cd03841160ea888959"><td class="memItemLeft" align="right" valign="top"><a id="a30070ae683d2c9cd03841160ea888959"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isnan</b> (double x)</td></tr>
<tr class="separator:a30070ae683d2c9cd03841160ea888959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e660f13e4b9522e1561445b80530ba"><td class="memTemplParams" colspan="2">template&lt;class Scalar &gt; </td></tr>
<tr class="memitem:ac8e660f13e4b9522e1561445b80530ba"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#ac8e660f13e4b9522e1561445b80530ba">sqr</a> (Scalar x)</td></tr>
<tr class="memdesc:ac8e660f13e4b9522e1561445b80530ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template for a function that squares the argument.  <a href="namespaceCGLA.html#ac8e660f13e4b9522e1561445b80530ba">More...</a><br /></td></tr>
<tr class="separator:ac8e660f13e4b9522e1561445b80530ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a646a928482dc1b2f51623ad2cdd22bfb"><td class="memTemplParams" colspan="2">template&lt;class Scalar &gt; </td></tr>
<tr class="memitem:a646a928482dc1b2f51623ad2cdd22bfb"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a646a928482dc1b2f51623ad2cdd22bfb">qbe</a> (Scalar x)</td></tr>
<tr class="memdesc:a646a928482dc1b2f51623ad2cdd22bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar template for a function that returns the cube of the argument.  <a href="namespaceCGLA.html#a646a928482dc1b2f51623ad2cdd22bfb">More...</a><br /></td></tr>
<tr class="separator:a646a928482dc1b2f51623ad2cdd22bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7a0eb5ba573d939317aeba2b6c1e1c"><td class="memTemplParams" colspan="2"><a id="ace7a0eb5ba573d939317aeba2b6c1e1c"></a>
template&lt;class Scalar &gt; </td></tr>
<tr class="memitem:ace7a0eb5ba573d939317aeba2b6c1e1c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_zero</b> (Scalar x)</td></tr>
<tr class="separator:ace7a0eb5ba573d939317aeba2b6c1e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0642edf675b75cddc453fd7d500e17d2"><td class="memTemplParams" colspan="2"><a id="a0642edf675b75cddc453fd7d500e17d2"></a>
template&lt;class Scalar &gt; </td></tr>
<tr class="memitem:a0642edf675b75cddc453fd7d500e17d2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_tiny</b> (Scalar x)</td></tr>
<tr class="separator:a0642edf675b75cddc453fd7d500e17d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8faf64d92f0883773655482ab4ae65e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a8faf64d92f0883773655482ab4ae65e0">two_to_what_power</a> (unsigned int x)</td></tr>
<tr class="memdesc:a8faf64d92f0883773655482ab4ae65e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">What power of 2 ?.  <a href="namespaceCGLA.html#a8faf64d92f0883773655482ab4ae65e0">More...</a><br /></td></tr>
<tr class="separator:a8faf64d92f0883773655482ab4ae65e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497c152a18017bf5394b46171e082750"><td class="memItemLeft" align="right" valign="top"><a id="a497c152a18017bf5394b46171e082750"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>round</b> (float x)</td></tr>
<tr class="separator:a497c152a18017bf5394b46171e082750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad109987979e00947241ff9208f10984f"><td class="memTemplParams" colspan="2"><a id="ad109987979e00947241ff9208f10984f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad109987979e00947241ff9208f10984f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sign</b> (T x)</td></tr>
<tr class="separator:ad109987979e00947241ff9208f10984f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0256f4c5c218f0a96d95aa82f51f8dd"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa0256f4c5c218f0a96d95aa82f51f8dd"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#aa0256f4c5c218f0a96d95aa82f51f8dd">int_pow</a> (T a, unsigned int n)</td></tr>
<tr class="memdesc:aa0256f4c5c218f0a96d95aa82f51f8dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer power function with O(log(n)) complexity.  <a href="namespaceCGLA.html#aa0256f4c5c218f0a96d95aa82f51f8dd">More...</a><br /></td></tr>
<tr class="separator:aa0256f4c5c218f0a96d95aa82f51f8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565c30a1720552a706d1fac6dcec7efe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a565c30a1720552a706d1fac6dcec7efe">gel_srand</a> (unsigned int seed)</td></tr>
<tr class="memdesc:a565c30a1720552a706d1fac6dcec7efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that seeds the GEL pseudo-random number generator.  <a href="namespaceCGLA.html#a565c30a1720552a706d1fac6dcec7efe">More...</a><br /></td></tr>
<tr class="separator:a565c30a1720552a706d1fac6dcec7efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9dac9894ae7ca37983be8409d9c44f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a3a9dac9894ae7ca37983be8409d9c44f">gel_rand</a> (unsigned int k)</td></tr>
<tr class="memdesc:a3a9dac9894ae7ca37983be8409d9c44f"><td class="mdescLeft">&#160;</td><td class="mdescRight">GEL provides a linear congruential pseudo-random number generator which is optimized for speed.  <a href="namespaceCGLA.html#a3a9dac9894ae7ca37983be8409d9c44f">More...</a><br /></td></tr>
<tr class="separator:a3a9dac9894ae7ca37983be8409d9c44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a369bdfb0dfe9561a3d64e5fc3d4e7b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a4a369bdfb0dfe9561a3d64e5fc3d4e7b">gel_rand</a> ()</td></tr>
<tr class="memdesc:a4a369bdfb0dfe9561a3d64e5fc3d4e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">GEL provides a linear congruential pseudo-random number generator which is optimized for speed.  <a href="namespaceCGLA.html#a4a369bdfb0dfe9561a3d64e5fc3d4e7b">More...</a><br /></td></tr>
<tr class="separator:a4a369bdfb0dfe9561a3d64e5fc3d4e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3debe391f6c7c2d99f00c476afa54f47"><td class="memTemplParams" colspan="2">template&lt;class T , class S &gt; </td></tr>
<tr class="memitem:a3debe391f6c7c2d99f00c476afa54f47"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a3debe391f6c7c2d99f00c476afa54f47">raw_assign</a> (T &amp;a, const S *b)</td></tr>
<tr class="memdesc:a3debe391f6c7c2d99f00c476afa54f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">raw_assign takes a <a class="el" href="namespaceCGLA.html" title="Computer Graphics Linear Algebra.">CGLA</a> vector, matrix or whatever has a get() function as its first argument and a raw pointer to a (presumed scalar) entity as the second argument.  <a href="namespaceCGLA.html#a3debe391f6c7c2d99f00c476afa54f47">More...</a><br /></td></tr>
<tr class="separator:a3debe391f6c7c2d99f00c476afa54f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0f4c24a088e41e84ee5045b227a261"><td class="memTemplParams" colspan="2">template&lt;class MT &gt; </td></tr>
<tr class="memitem:a5f0f4c24a088e41e84ee5045b227a261"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a5f0f4c24a088e41e84ee5045b227a261">power_eigensolution</a> (const MT &amp;A, MT &amp;Q, MT &amp;L, unsigned int max_sol=1000)</td></tr>
<tr class="memdesc:a5f0f4c24a088e41e84ee5045b227a261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the power method to obtain an eigensolution.  <a href="namespaceCGLA.html#a5f0f4c24a088e41e84ee5045b227a261">More...</a><br /></td></tr>
<tr class="separator:a5f0f4c24a088e41e84ee5045b227a261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9240ff54d73af2a47139066ae68e9df9"><td class="memTemplParams" colspan="2"><a id="a9240ff54d73af2a47139066ae68e9df9"></a>
template&lt;class V &gt; </td></tr>
<tr class="memitem:a9240ff54d73af2a47139066ae68e9df9"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ls_solve</b> (const std::vector&lt; V &gt; &amp;A, const std::vector&lt; typename V::ScalarType &gt; &amp;b)</td></tr>
<tr class="separator:a9240ff54d73af2a47139066ae68e9df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d713b294a1a6f6540bd19c7ed04fff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGLA_1_1Mat3x3d.html">Mat3x3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a85d713b294a1a6f6540bd19c7ed04fff">rotation_Mat3x3d</a> (<a class="el" href="namespaceCGLA.html#a581cb1af1e8730f50b18d04eb2af3029">CGLA::Axis</a> axis, double angle)</td></tr>
<tr class="memdesc:a85d713b294a1a6f6540bd19c7ed04fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a rotation _matrix. Rotates about one of the major axes.  <a href="namespaceCGLA.html#a85d713b294a1a6f6540bd19c7ed04fff">More...</a><br /></td></tr>
<tr class="separator:a85d713b294a1a6f6540bd19c7ed04fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391e07cd41c3584f3fcc562393131501"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGLA_1_1Mat3x3d.html">Mat3x3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a391e07cd41c3584f3fcc562393131501">scaling_Mat3x3d</a> (const <a class="el" href="classCGLA_1_1Vec3d.html">Vec3d</a> &amp;)</td></tr>
<tr class="memdesc:a391e07cd41c3584f3fcc562393131501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a scaling matrix.  <a href="namespaceCGLA.html#a391e07cd41c3584f3fcc562393131501">More...</a><br /></td></tr>
<tr class="separator:a391e07cd41c3584f3fcc562393131501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0ae4c87b1a8f9921c4aca2ac8fb556"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGLA_1_1Mat3x3d.html">Mat3x3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a0b0ae4c87b1a8f9921c4aca2ac8fb556">identity_Mat3x3d</a> ()</td></tr>
<tr class="memdesc:a0b0ae4c87b1a8f9921c4aca2ac8fb556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an identity matrix.  <a href="namespaceCGLA.html#a0b0ae4c87b1a8f9921c4aca2ac8fb556">More...</a><br /></td></tr>
<tr class="separator:a0b0ae4c87b1a8f9921c4aca2ac8fb556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8256ccac55aa8aa82e0ea630bf33cf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGLA_1_1Mat3x3f.html">Mat3x3f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#ac8256ccac55aa8aa82e0ea630bf33cf2">rotation_Mat3x3f</a> (<a class="el" href="namespaceCGLA.html#a581cb1af1e8730f50b18d04eb2af3029">CGLA::Axis</a> axis, float angle)</td></tr>
<tr class="memdesc:ac8256ccac55aa8aa82e0ea630bf33cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a rotation _matrix. Rotates about one of the major axes.  <a href="namespaceCGLA.html#ac8256ccac55aa8aa82e0ea630bf33cf2">More...</a><br /></td></tr>
<tr class="separator:ac8256ccac55aa8aa82e0ea630bf33cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdcbc09254845d038c18529f0c3e9321"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGLA_1_1Mat3x3f.html">Mat3x3f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#afdcbc09254845d038c18529f0c3e9321">scaling_Mat3x3f</a> (const <a class="el" href="classCGLA_1_1Vec3f.html">Vec3f</a> &amp;)</td></tr>
<tr class="memdesc:afdcbc09254845d038c18529f0c3e9321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a scaling matrix.  <a href="namespaceCGLA.html#afdcbc09254845d038c18529f0c3e9321">More...</a><br /></td></tr>
<tr class="separator:afdcbc09254845d038c18529f0c3e9321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbad6f89867f55e801f5226b7c2be3f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGLA_1_1Mat3x3f.html">Mat3x3f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#abbad6f89867f55e801f5226b7c2be3f6">identity_Mat3x3f</a> ()</td></tr>
<tr class="memdesc:abbad6f89867f55e801f5226b7c2be3f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an identity matrix.  <a href="namespaceCGLA.html#abbad6f89867f55e801f5226b7c2be3f6">More...</a><br /></td></tr>
<tr class="separator:abbad6f89867f55e801f5226b7c2be3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e03059373e0ec53bb53d7bab781be78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGLA_1_1Mat4x4d.html">Mat4x4d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a6e03059373e0ec53bb53d7bab781be78">rotation_Mat4x4d</a> (<a class="el" href="namespaceCGLA.html#a581cb1af1e8730f50b18d04eb2af3029">CGLA::Axis</a> axis, float angle)</td></tr>
<tr class="memdesc:a6e03059373e0ec53bb53d7bab781be78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a rotation _matrix. Rotates about one of the major axes.  <a href="namespaceCGLA.html#a6e03059373e0ec53bb53d7bab781be78">More...</a><br /></td></tr>
<tr class="separator:a6e03059373e0ec53bb53d7bab781be78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16baa83309d0c62975419ed8c1ba783"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGLA_1_1Mat4x4d.html">Mat4x4d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#ac16baa83309d0c62975419ed8c1ba783">translation_Mat4x4d</a> (const <a class="el" href="classCGLA_1_1Vec3d.html">Vec3d</a> &amp;)</td></tr>
<tr class="memdesc:ac16baa83309d0c62975419ed8c1ba783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a translation matrix.  <a href="namespaceCGLA.html#ac16baa83309d0c62975419ed8c1ba783">More...</a><br /></td></tr>
<tr class="separator:ac16baa83309d0c62975419ed8c1ba783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b62de6a06e3944e1c42fc4702d53ea9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGLA_1_1Mat4x4d.html">Mat4x4d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a8b62de6a06e3944e1c42fc4702d53ea9">scaling_Mat4x4d</a> (const <a class="el" href="classCGLA_1_1Vec3d.html">Vec3d</a> &amp;)</td></tr>
<tr class="memdesc:a8b62de6a06e3944e1c42fc4702d53ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a scaling matrix.  <a href="namespaceCGLA.html#a8b62de6a06e3944e1c42fc4702d53ea9">More...</a><br /></td></tr>
<tr class="separator:a8b62de6a06e3944e1c42fc4702d53ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8061617543c55d4a6546c5921b5420"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGLA_1_1Mat4x4d.html">Mat4x4d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#aab8061617543c55d4a6546c5921b5420">identity_Mat4x4d</a> ()</td></tr>
<tr class="memdesc:aab8061617543c55d4a6546c5921b5420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an identity matrix.  <a href="namespaceCGLA.html#aab8061617543c55d4a6546c5921b5420">More...</a><br /></td></tr>
<tr class="separator:aab8061617543c55d4a6546c5921b5420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5adc4a677b18f2d0944b83de8b897503"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGLA_1_1Mat4x4d.html">Mat4x4d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a5adc4a677b18f2d0944b83de8b897503">invert_ortho</a> (const <a class="el" href="classCGLA_1_1Mat4x4d.html">Mat4x4d</a> &amp;m)</td></tr>
<tr class="memdesc:a5adc4a677b18f2d0944b83de8b897503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute inverse assuming that the upper-left 3x3 sub-matrix is orthonormal (which is the case if the transformation is only a concatenation of rotations and translations).  <a href="namespaceCGLA.html#a5adc4a677b18f2d0944b83de8b897503">More...</a><br /></td></tr>
<tr class="separator:a5adc4a677b18f2d0944b83de8b897503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1848554ffcc7352f221c6cd1f455981b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGLA_1_1Mat4x4f.html">Mat4x4f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a1848554ffcc7352f221c6cd1f455981b">rotation_Mat4x4f</a> (<a class="el" href="namespaceCGLA.html#a581cb1af1e8730f50b18d04eb2af3029">CGLA::Axis</a> axis, float angle)</td></tr>
<tr class="memdesc:a1848554ffcc7352f221c6cd1f455981b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a rotation _matrix. Rotates about one of the major axes.  <a href="namespaceCGLA.html#a1848554ffcc7352f221c6cd1f455981b">More...</a><br /></td></tr>
<tr class="separator:a1848554ffcc7352f221c6cd1f455981b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01a08a76820d9a98e651bfdd13e9328"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGLA_1_1Mat4x4f.html">Mat4x4f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#aa01a08a76820d9a98e651bfdd13e9328">translation_Mat4x4f</a> (const <a class="el" href="classCGLA_1_1Vec3f.html">Vec3f</a> &amp;)</td></tr>
<tr class="memdesc:aa01a08a76820d9a98e651bfdd13e9328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a translation matrix.  <a href="namespaceCGLA.html#aa01a08a76820d9a98e651bfdd13e9328">More...</a><br /></td></tr>
<tr class="separator:aa01a08a76820d9a98e651bfdd13e9328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41e8c3c11fdaa1c68b0b08b42c3adf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGLA_1_1Mat4x4f.html">Mat4x4f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#af41e8c3c11fdaa1c68b0b08b42c3adf6">scaling_Mat4x4f</a> (const <a class="el" href="classCGLA_1_1Vec3f.html">Vec3f</a> &amp;)</td></tr>
<tr class="memdesc:af41e8c3c11fdaa1c68b0b08b42c3adf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a scaling matrix.  <a href="namespaceCGLA.html#af41e8c3c11fdaa1c68b0b08b42c3adf6">More...</a><br /></td></tr>
<tr class="separator:af41e8c3c11fdaa1c68b0b08b42c3adf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e8fcc49a31ea4d6066e824f52c1af7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGLA_1_1Mat4x4f.html">Mat4x4f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#af5e8fcc49a31ea4d6066e824f52c1af7">perspective_Mat4x4f</a> (float fovy, float aspect, float zNear, float zFar)</td></tr>
<tr class="memdesc:af5e8fcc49a31ea4d6066e824f52c1af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a perspective projection similar to gluPerspective Description from gluPerspective: perspective_Mat4x4f specifies a viewing frustum into the world coordinate system.  <a href="namespaceCGLA.html#af5e8fcc49a31ea4d6066e824f52c1af7">More...</a><br /></td></tr>
<tr class="separator:af5e8fcc49a31ea4d6066e824f52c1af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c150743a52fdfad548ba81623280cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGLA_1_1Mat4x4f.html">Mat4x4f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a80c150743a52fdfad548ba81623280cd">frustum_Mat4x4f</a> (float left, float right, float bottom, float top, float nearVal, float farVal)</td></tr>
<tr class="memdesc:a80c150743a52fdfad548ba81623280cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a perspective matrix similar to glFrustum.  <a href="namespaceCGLA.html#a80c150743a52fdfad548ba81623280cd">More...</a><br /></td></tr>
<tr class="separator:a80c150743a52fdfad548ba81623280cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5114469431cd36a1b63e981f6ab06b47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGLA_1_1Mat4x4f.html">Mat4x4f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a5114469431cd36a1b63e981f6ab06b47">ortho_Mat4x4f</a> (float left, float right, float bottom, float top, float nearVal, float farVal)</td></tr>
<tr class="memdesc:a5114469431cd36a1b63e981f6ab06b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an orthographic projection matrix (similar to glOrtho)  <a href="namespaceCGLA.html#a5114469431cd36a1b63e981f6ab06b47">More...</a><br /></td></tr>
<tr class="separator:a5114469431cd36a1b63e981f6ab06b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68edf1b25170e7c0ac70bd4fc895c93e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGLA_1_1Mat4x4f.html">Mat4x4f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a68edf1b25170e7c0ac70bd4fc895c93e">ortho2D_Mat4x4f</a> (float left, float right, float bottom, float top)</td></tr>
<tr class="memdesc:a68edf1b25170e7c0ac70bd4fc895c93e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a 2D orthographic projection matrix (similar to gluOrtho2D)  <a href="namespaceCGLA.html#a68edf1b25170e7c0ac70bd4fc895c93e">More...</a><br /></td></tr>
<tr class="separator:a68edf1b25170e7c0ac70bd4fc895c93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204760ac24e00131dae985f0f4d88aac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGLA_1_1Mat4x4f.html">Mat4x4f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a204760ac24e00131dae985f0f4d88aac">lookAt_Mat4x4f</a> (const <a class="el" href="classCGLA_1_1Vec3f.html">Vec3f</a> &amp;eye, const <a class="el" href="classCGLA_1_1Vec3f.html">Vec3f</a> &amp;at, const <a class="el" href="classCGLA_1_1Vec3f.html">Vec3f</a> &amp;up)</td></tr>
<tr class="memdesc:a204760ac24e00131dae985f0f4d88aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a view matrix similar to gluLookAt.  <a href="namespaceCGLA.html#a204760ac24e00131dae985f0f4d88aac">More...</a><br /></td></tr>
<tr class="separator:a204760ac24e00131dae985f0f4d88aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72db15e782bc3a0ffeadad33bd9f27d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGLA_1_1Mat4x4f.html">Mat4x4f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#ac72db15e782bc3a0ffeadad33bd9f27d">identity_Mat4x4f</a> ()</td></tr>
<tr class="memdesc:ac72db15e782bc3a0ffeadad33bd9f27d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an identity matrix.  <a href="namespaceCGLA.html#ac72db15e782bc3a0ffeadad33bd9f27d">More...</a><br /></td></tr>
<tr class="separator:ac72db15e782bc3a0ffeadad33bd9f27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455708148db8f12dbca0ec9b36d49e38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGLA_1_1Mat4x4f.html">Mat4x4f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a455708148db8f12dbca0ec9b36d49e38">invert_ortho</a> (const <a class="el" href="classCGLA_1_1Mat4x4f.html">Mat4x4f</a> &amp;m)</td></tr>
<tr class="memdesc:a455708148db8f12dbca0ec9b36d49e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute inverse assuming that the upper-left 3x3 sub-matrix is orthonormal (which is the case if the transformation is only a concatenation of rotations and translations).  <a href="namespaceCGLA.html#a455708148db8f12dbca0ec9b36d49e38">More...</a><br /></td></tr>
<tr class="separator:a455708148db8f12dbca0ec9b36d49e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a77eef06f58b81f44b2ae88104a0056"><td class="memTemplParams" colspan="2"><a id="a5a77eef06f58b81f44b2ae88104a0056"></a>
template&lt;class VT &gt; </td></tr>
<tr class="memitem:a5a77eef06f58b81f44b2ae88104a0056"><td class="memTemplItemLeft" align="right" valign="top">VT&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mean</b> (const std::vector&lt; VT &gt; &amp;vec)</td></tr>
<tr class="separator:a5a77eef06f58b81f44b2ae88104a0056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ed75e755d11a330bd8b51324c3c765"><td class="memTemplParams" colspan="2">template&lt;class VT , class MT &gt; </td></tr>
<tr class="memitem:a84ed75e755d11a330bd8b51324c3c765"><td class="memTemplItemLeft" align="right" valign="top">VT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a84ed75e755d11a330bd8b51324c3c765">covariance</a> (const std::vector&lt; VT &gt; &amp;vec, MT &amp;C_out)</td></tr>
<tr class="memdesc:a84ed75e755d11a330bd8b51324c3c765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that computes the covariance of a set of points.  <a href="namespaceCGLA.html#a84ed75e755d11a330bd8b51324c3c765">More...</a><br /></td></tr>
<tr class="separator:a84ed75e755d11a330bd8b51324c3c765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a41ae199c9848a1c8543d682d2fa02d"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a4a41ae199c9848a1c8543d682d2fa02d">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classCGLA_1_1UnitVector.html">UnitVector</a> &amp;u)</td></tr>
<tr class="memdesc:a4a41ae199c9848a1c8543d682d2fa02d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline output operator.  <a href="namespaceCGLA.html#a4a41ae199c9848a1c8543d682d2fa02d">More...</a><br /></td></tr>
<tr class="separator:a4a41ae199c9848a1c8543d682d2fa02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a73e24a1ad7737d232ae22e990ccc5889"><td class="memItemLeft" align="right" valign="top"><a id="a73e24a1ad7737d232ae22e990ccc5889"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>MASKS</b> [33]</td></tr>
<tr class="separator:a73e24a1ad7737d232ae22e990ccc5889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6913c4e6a433a7ce037427d082c2a654"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a6913c4e6a433a7ce037427d082c2a654">BIG</a> =10e+30</td></tr>
<tr class="memdesc:a6913c4e6a433a7ce037427d082c2a654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numerical constant representing something large.  <a href="namespaceCGLA.html#a6913c4e6a433a7ce037427d082c2a654">More...</a><br /></td></tr>
<tr class="separator:a6913c4e6a433a7ce037427d082c2a654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6166f640b91e99737b997afc26b2a1"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#adb6166f640b91e99737b997afc26b2a1">MINUTE</a> =10e-30</td></tr>
<tr class="memdesc:adb6166f640b91e99737b997afc26b2a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numerical constant represents something extremely small.  <a href="namespaceCGLA.html#adb6166f640b91e99737b997afc26b2a1">More...</a><br /></td></tr>
<tr class="separator:adb6166f640b91e99737b997afc26b2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868c0c07c06e6482033992880b147818"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a868c0c07c06e6482033992880b147818">TINY</a> =3e-7</td></tr>
<tr class="memdesc:a868c0c07c06e6482033992880b147818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numerical constant represents something very small.  <a href="namespaceCGLA.html#a868c0c07c06e6482033992880b147818">More...</a><br /></td></tr>
<tr class="separator:a868c0c07c06e6482033992880b147818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914b7e71b2d3dfc539ea043d0bc82b29"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a914b7e71b2d3dfc539ea043d0bc82b29">SMALL</a> =10e-2</td></tr>
<tr class="memdesc:a914b7e71b2d3dfc539ea043d0bc82b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numerical constant represents something small.  <a href="namespaceCGLA.html#a914b7e71b2d3dfc539ea043d0bc82b29">More...</a><br /></td></tr>
<tr class="separator:a914b7e71b2d3dfc539ea043d0bc82b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f7dc3ae9f0c4223b352fe1bc8967c2"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCGLA.html#a29f7dc3ae9f0c4223b352fe1bc8967c2">GEL_RAND_MAX</a> =UINT_MAX</td></tr>
<tr class="memdesc:a29f7dc3ae9f0c4223b352fe1bc8967c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The GEL pseudo-random number generator uses UINT_MAX as RAND_MAX to avoid mod operations.  <a href="namespaceCGLA.html#a29f7dc3ae9f0c4223b352fe1bc8967c2">More...</a><br /></td></tr>
<tr class="separator:a29f7dc3ae9f0c4223b352fe1bc8967c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Computer Graphics Linear Algebra. </p>
<p><a class="el" href="namespaceCGLA.html" title="Computer Graphics Linear Algebra.">CGLA</a> is a set of numerical C++ vector and matrix classes and class templates designed with computer graphics in mind. <a class="el" href="namespaceCGLA.html" title="Computer Graphics Linear Algebra.">CGLA</a> stands for `&lsquo;Computer Graphics Linear Algebra&rsquo;'.</p>
<p>Let us get right down to the obvious question: Why create another linear algebra package? Well, <a class="el" href="namespaceCGLA.html" title="Computer Graphics Linear Algebra.">CGLA</a> evolved from a few matrix and vector classes because I didn't have anything better. Also, I created <a class="el" href="namespaceCGLA.html" title="Computer Graphics Linear Algebra.">CGLA</a> to experiment with some template programming techniques. This led to the most important feature of <a class="el" href="namespaceCGLA.html" title="Computer Graphics Linear Algebra.">CGLA</a>, namely the fact that all vector types are derived from the same template.</p>
<p>This makes it easy to ensure identical semantics: Since all vectors have inherited, say, the * operator from a common ancestor, it works the same for all of them.</p>
<p>It is important to note that <a class="el" href="namespaceCGLA.html" title="Computer Graphics Linear Algebra.">CGLA</a> was designed for Computer Graphics (not numerical computations) and this had a number of implications. Since, in computer graphics we mainly need small vectors of dimension 2,3, or 4 <a class="el" href="namespaceCGLA.html" title="Computer Graphics Linear Algebra.">CGLA</a> was designed for vectors of low dimensionality. Moreover, the amount of memory allocated for a vector is decided by its type at compile time. <a class="el" href="namespaceCGLA.html" title="Computer Graphics Linear Algebra.">CGLA</a> does not use dynamic memory. <a class="el" href="namespaceCGLA.html" title="Computer Graphics Linear Algebra.">CGLA</a> also does not use virtual functions, and most functions are inline. These features all help making <a class="el" href="namespaceCGLA.html" title="Computer Graphics Linear Algebra.">CGLA</a> relatively fast.</p>
<p>Of course, other libraries of vector templates for computer graphics exist, but to my knowledge none where the fundamental templates are parametrized w.r.t. dimension as well as type. In other words, we have a template (<a class="el" href="classCGLA_1_1ArithVec.html" title="Template representing generic arithmetic vectors.">ArithVec</a>) that gets both type (e.g. float) and dimension (e.g. 3) as arguments. the intended use of this template is as ancestor of concrete types such as <a class="el" href="classCGLA_1_1Vec3f.html" title="3D float vector.">Vec3f</a> - a 3D floating point type.</p>
<p>The use of just one template as basis is very important, I believe, since it makes it extremely simple to add new types of vectors. Another very generic template is ArithMat which is a template for matrix classes. (and not necessarily NxN matrices).</p>
<p>From a users perspective <a class="el" href="namespaceCGLA.html" title="Computer Graphics Linear Algebra.">CGLA</a> contains a number of vector and matrix classes, a quaternion and some utility classes. In summary, the most important features are</p>
<ul>
<li>A number of 2, 3 and 4 d vector classes.</li>
<li>A number of Matrix classes.</li>
<li>A Quaternion class.</li>
<li>Some test programs.</li>
<li>Works well with OpenGL.</li>
</ul>
<p>There is a document on <a class="el" href="namespaceCGLA.html" title="Computer Graphics Linear Algebra.">CGLA</a> in the GEL documentation. The introduction above was taken from that text. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a581cb1af1e8730f50b18d04eb2af3029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a581cb1af1e8730f50b18d04eb2af3029">&#9670;&nbsp;</a></span>Axis</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceCGLA.html#a581cb1af1e8730f50b18d04eb2af3029">CGLA::Axis</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Useful enum that represents coordiante axes. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a1e471bdf7c8149d66242904a0e8844e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e471bdf7c8149d66242904a0e8844e0">&#9670;&nbsp;</a></span>adjoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VT , class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">M CGLA::adjoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithSqMat4x4Float.html">ArithSqMat4x4Float</a>&lt; VT, M &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the adjoint of a matrix. </p>
<p>This is the matrix where each entry is the subdeterminant of 'in' where the row and column of the element is removed. Use mostly to compute the inverse </p>

</div>
</div>
<a id="aa293205b7806032f437552d8e6cff75f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa293205b7806032f437552d8e6cff75f">&#9670;&nbsp;</a></span>cond_normalize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class V , unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V CGLA::cond_normalize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithVecFloat.html">ArithVecFloat</a>&lt; T, V, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns normalized vector if the vector has non-zero length - otherwise the 0 vector. </p>

</div>
</div>
<a id="ab85f11744ad0e4f12d4c5617f8f3ddce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab85f11744ad0e4f12d4c5617f8f3ddce">&#9670;&nbsp;</a></span>copy_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M1 , class M2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CGLA::copy_matrix </td>
          <td>(</td>
          <td class="paramtype">const M1 &amp;&#160;</td>
          <td class="paramname"><em>inmat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M2 &amp;&#160;</td>
          <td class="paramname"><em>outmat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a matrix to another matrix, cell by cell. </p>
<p>This conversion that takes a const matrix as first argument (source) and a non-const matrix as second argument (destination). The contents of the first matrix is simply copied to the second matrix.</p>
<p>However, if the first matrix is larger than the second, the cells outside the range of the destination are simply not copied. If the destination is larger, the cells outside the range of the source matrix are not touched.</p>
<p>An obvious use of this function is to copy a 3x3 rotation matrix into a 4x4 transformation matrix. </p>

</div>
</div>
<a id="a84ed75e755d11a330bd8b51324c3c765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84ed75e755d11a330bd8b51324c3c765">&#9670;&nbsp;</a></span>covariance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VT , class MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VT CGLA::covariance </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; VT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MT &amp;&#160;</td>
          <td class="paramname"><em>C_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that computes the covariance of a set of points. </p>
<p>This function returns the mean, and, upon completion, the final argument contains the covariance matrix.</p>
<p>This template is instantiated for <a class="el" href="classCGLA_1_1Vec3f.html" title="3D float vector.">Vec3f</a>, <a class="el" href="classCGLA_1_1Vec2f.html" title="2D floating point vector">Vec2f</a>, and <a class="el" href="classCGLA_1_1Vec4f.html" title="A four dimensional floating point vector.">Vec4f</a>. </p>

</div>
</div>
<a id="a68a441523df91e127eabe5a2d2e98724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a441523df91e127eabe5a2d2e98724">&#9670;&nbsp;</a></span>cross() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V CGLA::cross </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithVec3Float.html">ArithVec3Float</a>&lt; T, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithVec3Float.html">ArithVec3Float</a>&lt; T, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns cross product of arguments. </p>

</div>
</div>
<a id="ae3cfe2a1fc29650a488ccf0add2f3326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3cfe2a1fc29650a488ccf0add2f3326">&#9670;&nbsp;</a></span>cross() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V CGLA::cross </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithVec3Int.html">ArithVec3Int</a>&lt; T, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithVec3Int.html">ArithVec3Int</a>&lt; T, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns cross product of arguments. </p>

</div>
</div>
<a id="aef116ec68dc27722ebf5d7359646c156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef116ec68dc27722ebf5d7359646c156">&#9670;&nbsp;</a></span>determinant() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGLA_1_1ArithSqMat2x2Float.html">ArithSqMat2x2Float</a>&lt;V,M&gt;::ScalarType CGLA::determinant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithSqMat2x2Float.html">ArithSqMat2x2Float</a>&lt; V, M &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the determinant of a <a class="el" href="classCGLA_1_1Mat2x2f.html" title="Two by two float matrix.">Mat2x2f</a>. </p>
<p>This function is faster than the generic determinant function for ArithSqMat </p>

</div>
</div>
<a id="af6f4f874118836b2bd1fd9366ea2750e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f4f874118836b2bd1fd9366ea2750e">&#9670;&nbsp;</a></span>determinant() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGLA_1_1ArithSqMat3x3Float.html">ArithSqMat3x3Float</a>&lt;V,M&gt;::ScalarType CGLA::determinant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithSqMat3x3Float.html">ArithSqMat3x3Float</a>&lt; V, M &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute determinant. </p>
<p>There is a more generic function for computing determinants of square matrices (ArithSqMat). This one is faster but works only on <a class="el" href="classCGLA_1_1Mat3x3f.html" title="3 by 3 float matrix.">Mat3x3f</a> </p>

</div>
</div>
<a id="ab0172f048d67b881b4eb1dc6aeadef82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0172f048d67b881b4eb1dc6aeadef82">&#9670;&nbsp;</a></span>determinant() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CGLA::determinant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithSqMat4x4Float.html">ArithSqMat4x4Float</a>&lt; V, M &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the determinant of a 4x4 matrix. </p>
<p>The code below is what I found to be most robust. The original implementation used direct computation of the 3x3 sub-determinants and I also tried a direct computation based on enumerating all permutations. The code below is better. </p>

</div>
</div>
<a id="a7824214991e543ff96d40f904cdbe7c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7824214991e543ff96d40f904cdbe7c1">&#9670;&nbsp;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class V , unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T CGLA::dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithVec.html">ArithVec</a>&lt; T, V, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithVec.html">ArithVec</a>&lt; T, V, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dot product for two vectors. </p>
<p>The &lsquo;*&rsquo; operator is reserved for coordinatewise multiplication of vectors. </p>

</div>
</div>
<a id="a80c150743a52fdfad548ba81623280cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c150743a52fdfad548ba81623280cd">&#9670;&nbsp;</a></span>frustum_Mat4x4f()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGLA_1_1Mat4x4f.html">Mat4x4f</a> CGLA::frustum_Mat4x4f </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>nearVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>farVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a perspective matrix similar to glFrustum. </p>

</div>
</div>
<a id="a4a369bdfb0dfe9561a3d64e5fc3d4e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a369bdfb0dfe9561a3d64e5fc3d4e7b">&#9670;&nbsp;</a></span>gel_rand() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int CGLA::gel_rand </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GEL provides a linear congruential pseudo-random number generator which is optimized for speed. </p>
<p>This means that GEL_RAND_MAX==UINT_MAX. </p>

</div>
</div>
<a id="a3a9dac9894ae7ca37983be8409d9c44f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a9dac9894ae7ca37983be8409d9c44f">&#9670;&nbsp;</a></span>gel_rand() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int CGLA::gel_rand </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GEL provides a linear congruential pseudo-random number generator which is optimized for speed. </p>
<p>This version allows an integer argument which is useful for grid-based noise functions. </p>

</div>
</div>
<a id="a565c30a1720552a706d1fac6dcec7efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a565c30a1720552a706d1fac6dcec7efe">&#9670;&nbsp;</a></span>gel_srand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CGLA::gel_srand </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that seeds the GEL pseudo-random number generator. </p>

</div>
</div>
<a id="a0b0ae4c87b1a8f9921c4aca2ac8fb556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b0ae4c87b1a8f9921c4aca2ac8fb556">&#9670;&nbsp;</a></span>identity_Mat3x3d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGLA_1_1Mat3x3d.html">Mat3x3d</a> CGLA::identity_Mat3x3d </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an identity matrix. </p>

</div>
</div>
<a id="abbad6f89867f55e801f5226b7c2be3f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbad6f89867f55e801f5226b7c2be3f6">&#9670;&nbsp;</a></span>identity_Mat3x3f()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGLA_1_1Mat3x3f.html">Mat3x3f</a> CGLA::identity_Mat3x3f </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an identity matrix. </p>

</div>
</div>
<a id="aab8061617543c55d4a6546c5921b5420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab8061617543c55d4a6546c5921b5420">&#9670;&nbsp;</a></span>identity_Mat4x4d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGLA_1_1Mat4x4d.html">Mat4x4d</a> CGLA::identity_Mat4x4d </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an identity matrix. </p>

</div>
</div>
<a id="ac72db15e782bc3a0ffeadad33bd9f27d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac72db15e782bc3a0ffeadad33bd9f27d">&#9670;&nbsp;</a></span>identity_Mat4x4f()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGLA_1_1Mat4x4f.html">Mat4x4f</a> CGLA::identity_Mat4x4f </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an identity matrix. </p>

</div>
</div>
<a id="aa0256f4c5c218f0a96d95aa82f51f8dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0256f4c5c218f0a96d95aa82f51f8dd">&#9670;&nbsp;</a></span>int_pow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T CGLA::int_pow </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integer power function with O(log(n)) complexity. </p>

</div>
</div>
<a id="aff067942779c6eaa864faf80a2d841d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff067942779c6eaa864faf80a2d841d9">&#9670;&nbsp;</a></span>invert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V , class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">M CGLA::invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithSqMat3x3Float.html">ArithSqMat3x3Float</a>&lt; V, M &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invert 3x3 matrix. </p>

</div>
</div>
<a id="a65fb80ecad0a3dcfc41389a9158d75d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65fb80ecad0a3dcfc41389a9158d75d2">&#9670;&nbsp;</a></span>invert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VT , class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">M CGLA::invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithSqMat4x4Float.html">ArithSqMat4x4Float</a>&lt; VT, M &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the inverse matrix of a <a class="el" href="classCGLA_1_1Mat4x4f.html" title="4x4 float matrix.">Mat4x4f</a>. </p>

</div>
</div>
<a id="aca6608f53fd1a92566fab9956ab8908d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca6608f53fd1a92566fab9956ab8908d">&#9670;&nbsp;</a></span>invert_affine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VT , class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">M CGLA::invert_affine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithSqMat4x4Float.html">ArithSqMat4x4Float</a>&lt; VT, M &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the inverse matrix of a <a class="el" href="classCGLA_1_1Mat4x4f.html" title="4x4 float matrix.">Mat4x4f</a> that is affine. </p>

</div>
</div>
<a id="a5adc4a677b18f2d0944b83de8b897503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5adc4a677b18f2d0944b83de8b897503">&#9670;&nbsp;</a></span>invert_ortho() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGLA_1_1Mat4x4d.html">Mat4x4d</a> CGLA::invert_ortho </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1Mat4x4d.html">Mat4x4d</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute inverse assuming that the upper-left 3x3 sub-matrix is orthonormal (which is the case if the transformation is only a concatenation of rotations and translations). </p>

</div>
</div>
<a id="a455708148db8f12dbca0ec9b36d49e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455708148db8f12dbca0ec9b36d49e38">&#9670;&nbsp;</a></span>invert_ortho() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGLA_1_1Mat4x4f.html">Mat4x4f</a> CGLA::invert_ortho </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1Mat4x4f.html">Mat4x4f</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute inverse assuming that the upper-left 3x3 sub-matrix is orthonormal (which is the case if the transformation is only a concatenation of rotations and translations). </p>

</div>
</div>
<a id="a5a417f58451a8d2ac147330475a4d554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a417f58451a8d2ac147330475a4d554">&#9670;&nbsp;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class V , unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T CGLA::length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithVecFloat.html">ArithVecFloat</a>&lt; T, V, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns length of vector. </p>

</div>
</div>
<a id="ac4303bdb4c02280511ff4f08c9127302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4303bdb4c02280511ff4f08c9127302">&#9670;&nbsp;</a></span>linear_combine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool CGLA::linear_combine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithVec2Float.html">ArithVec2Float</a>&lt; T, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithVec2Float.html">ArithVec2Float</a>&lt; T, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithVec2Float.html">ArithVec2Float</a>&lt; T, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The two last (scalar) arguments are the linear combination of the two first arguments (vectors) which produces the third argument. </p>

</div>
</div>
<a id="a204760ac24e00131dae985f0f4d88aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a204760ac24e00131dae985f0f4d88aac">&#9670;&nbsp;</a></span>lookAt_Mat4x4f()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGLA_1_1Mat4x4f.html">Mat4x4f</a> CGLA::lookAt_Mat4x4f </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1Vec3f.html">Vec3f</a> &amp;&#160;</td>
          <td class="paramname"><em>eye</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1Vec3f.html">Vec3f</a> &amp;&#160;</td>
          <td class="paramname"><em>at</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1Vec3f.html">Vec3f</a> &amp;&#160;</td>
          <td class="paramname"><em>up</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a view matrix similar to gluLookAt. </p>

</div>
</div>
<a id="aebd2718d8fd0d03d2a7e6e2c4af30c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd2718d8fd0d03d2a7e6e2c4af30c6f">&#9670;&nbsp;</a></span>mul()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VVT , class HVT , class HV1T , class VV2T , class MT1 , class MT2 , class MT , unsigned int ROWS1, unsigned int ROWS2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CGLA::mul </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithMatFloat.html">ArithMatFloat</a>&lt; VVT, HV1T, MT1, ROWS1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithMatFloat.html">ArithMatFloat</a>&lt; VV2T, HVT, MT2, ROWS2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGLA_1_1ArithMatFloat.html">ArithMatFloat</a>&lt; VVT, HVT, MT, ROWS1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply two arbitrary matrices. </p>
<p>In principle, this function could return a matrix, but in general the new matrix will be of a type that is different from either of the two matrices that are multiplied together. We do not want to return an <a class="el" href="classCGLA_1_1ArithMatFloat.html" title="Basic class template for matrices.">ArithMatFloat</a> - so it seems best to let the return value be a reference arg.</p>
<p>This template can only be instantiated if the dimensions of the matrices match &ndash; i.e. if the multiplication can actually be carried out. This is more type safe than the win32 version below. </p>

</div>
</div>
<a id="af473ad0eedf28a08e4b83fafe6b0bced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af473ad0eedf28a08e4b83fafe6b0bced">&#9670;&nbsp;</a></span>normalize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class V , unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V CGLA::normalize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithVecFloat.html">ArithVecFloat</a>&lt; T, V, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns normalized vector. </p>

</div>
</div>
<a id="af30641cd7014fd49260079844dd843b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30641cd7014fd49260079844dd843b1">&#9670;&nbsp;</a></span>onb()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CGLA::onb </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithVec3Float.html">ArithVec3Float</a>&lt; T, V &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGLA_1_1ArithVec3Float.html">ArithVec3Float</a>&lt; T, V &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGLA_1_1ArithVec3Float.html">ArithVec3Float</a>&lt; T, V &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build an orthonormal basis from a 3d unit vector [Frisvad 2012]. </p>
<p>Given a unit vector compute two unit vectors that are orthogonal to it and to each other. </p>

</div>
</div>
<a id="a6ef9672a724549701fafc9d1e1a3144a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ef9672a724549701fafc9d1e1a3144a">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VVT , class HVT , class MT , unsigned int ROWS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VVT CGLA::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithMatFloat.html">ArithMatFloat</a>&lt; VVT, HVT, MT, ROWS &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HVT &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply vector onto matrix. </p>

</div>
</div>
<a id="a74dd48bd255a497ffc024e71098c13b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74dd48bd255a497ffc024e71098c13b3">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VT , class MT , unsigned int ROWS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MT CGLA::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithSqMatFloat.html">ArithSqMatFloat</a>&lt; VT, MT, ROWS &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithSqMatFloat.html">ArithSqMatFloat</a>&lt; VT, MT, ROWS &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply two matrices derived from same type, producing a new of same type. </p>

</div>
</div>
<a id="adad4893d4f51aaa40d60d946915ae41f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad4893d4f51aaa40d60d946915ae41f">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VVT , class HVT , class MT , unsigned int ROWS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MT CGLA::operator* </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithMatFloat.html">ArithMatFloat</a>&lt; VVT, HVT, MT, ROWS &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply scalar onto matrix. </p>

</div>
</div>
<a id="aa632ea3d0b7d506a4db1f1032780b382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa632ea3d0b7d506a4db1f1032780b382">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class V , unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const V CGLA::operator* </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithVec.html">ArithVec</a>&lt; T, V, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply double onto vector. </p>
<p>This operator handles the case where the vector is on the righ side of the &lsquo;*&rsquo;.</p>
<dl class="section note"><dt>Note</dt><dd>It seems to be optimal to put the binary operators inside the <a class="el" href="classCGLA_1_1ArithVec.html" title="Template representing generic arithmetic vectors.">ArithVec</a> class template, but the operator functions whose left operand is <em>not</em> a vector cannot be inside, hence they are here. We need three operators for scalar * vector although they are identical, because, if we use a separate template argument for the left operand, it will match any type. If we use just T as type for the left operand hoping that other built-in types will be automatically converted, we will be disappointed. It seems that a float * ArithVec&lt;float,Vec3f,3&gt; function is not found if the left operand is really a double. </dd></dl>

</div>
</div>
<a id="ac082a48cbbf6ed5191769be17d97f7ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac082a48cbbf6ed5191769be17d97f7ad">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VVT , class HVT , class MT , unsigned int ROWS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MT CGLA::operator* </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithMatFloat.html">ArithMatFloat</a>&lt; VVT, HVT, MT, ROWS &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply scalar onto matrix. </p>

</div>
</div>
<a id="ab6d1d84a9a0bd6d61b9d053ad540413c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d1d84a9a0bd6d61b9d053ad540413c">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class V , unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const V CGLA::operator* </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithVec.html">ArithVec</a>&lt; T, V, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply float onto vector. </p>
<p>See the note in the documentation regarding multiplication of a double onto a vector. </p>

</div>
</div>
<a id="ad864dcf89490514a24f6e33835a5f887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad864dcf89490514a24f6e33835a5f887">&#9670;&nbsp;</a></span>operator*() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VVT , class HVT , class MT , unsigned int ROWS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MT CGLA::operator* </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithMatFloat.html">ArithMatFloat</a>&lt; VVT, HVT, MT, ROWS &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply scalar onto matrix. </p>

</div>
</div>
<a id="a7935023b32719512b23ca80ad6a57218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7935023b32719512b23ca80ad6a57218">&#9670;&nbsp;</a></span>operator*() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class V , unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const V CGLA::operator* </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithVec.html">ArithVec</a>&lt; T, V, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply unsigned int onto vector. </p>
<p>See the note in the documentation regarding multiplication of a double onto a vector. </p>

</div>
</div>
<a id="ac79ce13057e87a811d100d11e5da4db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac79ce13057e87a811d100d11e5da4db9">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VVT , class HVT , class MT , unsigned int ROWS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; CGLA::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithMatFloat.html">ArithMatFloat</a>&lt; VVT, HVT, MT, ROWS &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Put to operator. </p>

</div>
</div>
<a id="af641bcf3953a951950b72027476cbcc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af641bcf3953a951950b72027476cbcc5">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class V , class Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; CGLA::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithQuat.html">ArithQuat</a>&lt; T, V, Q &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print quaternion to stream. </p>

</div>
</div>
<a id="a4a41ae199c9848a1c8543d682d2fa02d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a41ae199c9848a1c8543d682d2fa02d">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; CGLA::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1UnitVector.html">UnitVector</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline output operator. </p>

</div>
</div>
<a id="a4a2087af59716d5b2190c38b74fcd95e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a2087af59716d5b2190c38b74fcd95e">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class V , unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; CGLA::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGLA_1_1ArithVec.html">ArithVec</a>&lt; T, V, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get from operator for <a class="el" href="classCGLA_1_1ArithVec.html" title="Template representing generic arithmetic vectors.">ArithVec</a> descendants. </p>

</div>
</div>
<a id="ae29dd642214f5e58cf2b2184b1043754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae29dd642214f5e58cf2b2184b1043754">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VVT , class HVT , class MT , unsigned int ROWS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; CGLA::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithMatFloat.html">ArithMatFloat</a>&lt; VVT, HVT, MT, ROWS &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get from operator. </p>

</div>
</div>
<a id="a68edf1b25170e7c0ac70bd4fc895c93e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68edf1b25170e7c0ac70bd4fc895c93e">&#9670;&nbsp;</a></span>ortho2D_Mat4x4f()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGLA_1_1Mat4x4f.html">Mat4x4f</a> CGLA::ortho2D_Mat4x4f </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>top</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a 2D orthographic projection matrix (similar to gluOrtho2D) </p>

</div>
</div>
<a id="a5114469431cd36a1b63e981f6ab06b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5114469431cd36a1b63e981f6ab06b47">&#9670;&nbsp;</a></span>ortho_Mat4x4f()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGLA_1_1Mat4x4f.html">Mat4x4f</a> CGLA::ortho_Mat4x4f </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>nearVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>farVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an orthographic projection matrix (similar to glOrtho) </p>

</div>
</div>
<a id="ac7e1c64372c70216020b898b820caf03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e1c64372c70216020b898b820caf03">&#9670;&nbsp;</a></span>orthogonal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V CGLA::orthogonal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithVec2Float.html">ArithVec2Float</a>&lt; T, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotates vector 90 degrees to obtain orthogonal vector. </p>

</div>
</div>
<a id="a9f239eee3df119f280913bae1715949f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f239eee3df119f280913bae1715949f">&#9670;&nbsp;</a></span>orthogonal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CGLA::orthogonal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithVec3Float.html">ArithVec3Float</a>&lt; T, V &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGLA_1_1ArithVec3Float.html">ArithVec3Float</a>&lt; T, V &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGLA_1_1ArithVec3Float.html">ArithVec3Float</a>&lt; T, V &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute basis of orthogonal plane. </p>
<p>Given a vector compute two vectors that are orthogonal to it and to each other. </p>

</div>
</div>
<a id="afb32d0780d99709e882f1b7ed7b0250b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb32d0780d99709e882f1b7ed7b0250b">&#9670;&nbsp;</a></span>outer_product() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGLA_1_1VecT__to__MatT.html">VecT_to_MatT</a>&lt;V&gt;::MatT CGLA::outer_product </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the outer product of a and b: a * transpose(b). </p>
<p>This is for vectors of identical dimensions, and it returns the result. </p>

</div>
</div>
<a id="afb930b95b35130d05151258e9e821354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb930b95b35130d05151258e9e821354">&#9670;&nbsp;</a></span>outer_product() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VVT , class HVT , class MT , unsigned int ROWS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CGLA::outer_product </td>
          <td>(</td>
          <td class="paramtype">const VVT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HVT &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGLA_1_1ArithMatFloat.html">ArithMatFloat</a>&lt; VVT, HVT, MT, ROWS &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the outer product of a and b: a * transpose(b). </p>
<p>This is a matrix with a::rows and b::columns. </p>

</div>
</div>
<a id="ad58fc6f7e860dd0b68cd28baa553afbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad58fc6f7e860dd0b68cd28baa553afbd">&#9670;&nbsp;</a></span>outer_product() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VVT , class HVT , class MT , int ROWS, class BinOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CGLA::outer_product </td>
          <td>(</td>
          <td class="paramtype">const VVT &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HVT &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGLA_1_1ArithMatFloat.html">ArithMatFloat</a>&lt; VVT, HVT, MT, ROWS &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the outer product of a and b using an arbitrary binary operation: op(a, transpose(b)). </p>
<p>This is a matrix with a::rows and b::columns. </p>

</div>
</div>
<a id="af5e8fcc49a31ea4d6066e824f52c1af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e8fcc49a31ea4d6066e824f52c1af7">&#9670;&nbsp;</a></span>perspective_Mat4x4f()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGLA_1_1Mat4x4f.html">Mat4x4f</a> CGLA::perspective_Mat4x4f </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fovy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>aspect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>zNear</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>zFar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a perspective projection similar to gluPerspective Description from gluPerspective: perspective_Mat4x4f specifies a viewing frustum into the world coordinate system. </p>
<p>In general, the aspect ratio in perspective_Mat4x4f should match the aspect ratio of the associated viewport. For example, aspect = 2.0 means the viewer's angle of view is twice as wide in x as it is in y. If the viewport is twice as wide as it is tall, it displays the image without distortion. </p>

</div>
</div>
<a id="a5f0f4c24a088e41e84ee5045b227a261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0f4c24a088e41e84ee5045b227a261">&#9670;&nbsp;</a></span>power_eigensolution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int CGLA::power_eigensolution </td>
          <td>(</td>
          <td class="paramtype">const MT &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MT &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MT &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_sol</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the power method to obtain an eigensolution. </p>
<p>Given a matrix A, the function returns the number of eigensolutions found, and the eigenvectors are stored in Q as the rows, and the corresponding values are stored in the diagonal of L upon return of the function.</p>
<p>The so called power method is used to find the dominant eigenvalue, and the method of deflation is used to find the following values. This restricts this function to work only on symmetric matrices.</p>
<p>DO NOT CALL THIS FUNCTION WITH AN UNSYMMETRIC MATRIX.</p>
<p>The final argument is the number of solutions to find. If only a number of solutions are interesting, use this argument to save cycles. </p>

</div>
</div>
<a id="a646a928482dc1b2f51623ad2cdd22bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a646a928482dc1b2f51623ad2cdd22bfb">&#9670;&nbsp;</a></span>qbe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Scalar CGLA::qbe </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar template for a function that returns the cube of the argument. </p>

</div>
</div>
<a id="a3debe391f6c7c2d99f00c476afa54f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3debe391f6c7c2d99f00c476afa54f47">&#9670;&nbsp;</a></span>raw_assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void CGLA::raw_assign </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>raw_assign takes a <a class="el" href="namespaceCGLA.html" title="Computer Graphics Linear Algebra.">CGLA</a> vector, matrix or whatever has a get() function as its first argument and a raw pointer to a (presumed scalar) entity as the second argument. </p>
<p>the contents dereferenced by the pointer is copied to the entity given as first argument. </p>

</div>
</div>
<a id="a85d713b294a1a6f6540bd19c7ed04fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d713b294a1a6f6540bd19c7ed04fff">&#9670;&nbsp;</a></span>rotation_Mat3x3d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGLA_1_1Mat3x3d.html">Mat3x3d</a> CGLA::rotation_Mat3x3d </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceCGLA.html#a581cb1af1e8730f50b18d04eb2af3029">CGLA::Axis</a>&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a rotation _matrix. Rotates about one of the major axes. </p>

</div>
</div>
<a id="ac8256ccac55aa8aa82e0ea630bf33cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8256ccac55aa8aa82e0ea630bf33cf2">&#9670;&nbsp;</a></span>rotation_Mat3x3f()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGLA_1_1Mat3x3f.html">Mat3x3f</a> CGLA::rotation_Mat3x3f </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceCGLA.html#a581cb1af1e8730f50b18d04eb2af3029">CGLA::Axis</a>&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a rotation _matrix. Rotates about one of the major axes. </p>

</div>
</div>
<a id="a6e03059373e0ec53bb53d7bab781be78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e03059373e0ec53bb53d7bab781be78">&#9670;&nbsp;</a></span>rotation_Mat4x4d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGLA_1_1Mat4x4d.html">Mat4x4d</a> CGLA::rotation_Mat4x4d </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceCGLA.html#a581cb1af1e8730f50b18d04eb2af3029">CGLA::Axis</a>&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a rotation _matrix. Rotates about one of the major axes. </p>

</div>
</div>
<a id="a1848554ffcc7352f221c6cd1f455981b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1848554ffcc7352f221c6cd1f455981b">&#9670;&nbsp;</a></span>rotation_Mat4x4f()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGLA_1_1Mat4x4f.html">Mat4x4f</a> CGLA::rotation_Mat4x4f </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceCGLA.html#a581cb1af1e8730f50b18d04eb2af3029">CGLA::Axis</a>&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a rotation _matrix. Rotates about one of the major axes. </p>

</div>
</div>
<a id="a391e07cd41c3584f3fcc562393131501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391e07cd41c3584f3fcc562393131501">&#9670;&nbsp;</a></span>scaling_Mat3x3d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGLA_1_1Mat3x3d.html">Mat3x3d</a> CGLA::scaling_Mat3x3d </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1Vec3d.html">Vec3d</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a scaling matrix. </p>

</div>
</div>
<a id="afdcbc09254845d038c18529f0c3e9321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdcbc09254845d038c18529f0c3e9321">&#9670;&nbsp;</a></span>scaling_Mat3x3f()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGLA_1_1Mat3x3f.html">Mat3x3f</a> CGLA::scaling_Mat3x3f </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1Vec3f.html">Vec3f</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a scaling matrix. </p>

</div>
</div>
<a id="a8b62de6a06e3944e1c42fc4702d53ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b62de6a06e3944e1c42fc4702d53ea9">&#9670;&nbsp;</a></span>scaling_Mat4x4d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGLA_1_1Mat4x4d.html">Mat4x4d</a> CGLA::scaling_Mat4x4d </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1Vec3d.html">Vec3d</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a scaling matrix. </p>

</div>
</div>
<a id="af41e8c3c11fdaa1c68b0b08b42c3adf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af41e8c3c11fdaa1c68b0b08b42c3adf6">&#9670;&nbsp;</a></span>scaling_Mat4x4f()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGLA_1_1Mat4x4f.html">Mat4x4f</a> CGLA::scaling_Mat4x4f </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1Vec3f.html">Vec3f</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a scaling matrix. </p>

</div>
</div>
<a id="afc32f3f28e32530aa847de091191bfa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc32f3f28e32530aa847de091191bfa1">&#9670;&nbsp;</a></span>slerp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class V , class Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Q CGLA::slerp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithQuat.html">ArithQuat</a>&lt; T, V, Q &gt; &amp;&#160;</td>
          <td class="paramname"><em>q0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithQuat.html">ArithQuat</a>&lt; T, V, Q &gt; &amp;&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform linear interpolation of two quaternions. </p>
<p>The last argument is the parameter used to interpolate between the two first. SLERP - invented by Shoemake - is a good way to interpolate because the interpolation is performed on the unit sphere. <br  />
 </p>

</div>
</div>
<a id="ac8e660f13e4b9522e1561445b80530ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e660f13e4b9522e1561445b80530ba">&#9670;&nbsp;</a></span>sqr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Scalar CGLA::sqr </td>
          <td>(</td>
          <td class="paramtype">Scalar&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Template for a function that squares the argument. </p>

</div>
</div>
<a id="ad7dadba9d869969d027cb1380d7b5818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7dadba9d869969d027cb1380d7b5818">&#9670;&nbsp;</a></span>sqr_length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class V , unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T CGLA::sqr_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithVec.html">ArithVec</a>&lt; T, V, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the sqr length by taking dot product of vector with itself. </p>

</div>
</div>
<a id="a97c51c159d5501d6e4c32441ea9061aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c51c159d5501d6e4c32441ea9061aa">&#9670;&nbsp;</a></span>trace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VT , class MT , unsigned int ROWS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MT::ScalarType CGLA::trace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithSqMatFloat.html">ArithSqMatFloat</a>&lt; VT, MT, ROWS &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute trace. Works only for sq. matrices. </p>

</div>
</div>
<a id="ac16baa83309d0c62975419ed8c1ba783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac16baa83309d0c62975419ed8c1ba783">&#9670;&nbsp;</a></span>translation_Mat4x4d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGLA_1_1Mat4x4d.html">Mat4x4d</a> CGLA::translation_Mat4x4d </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1Vec3d.html">Vec3d</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a translation matrix. </p>

</div>
</div>
<a id="aa01a08a76820d9a98e651bfdd13e9328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa01a08a76820d9a98e651bfdd13e9328">&#9670;&nbsp;</a></span>translation_Mat4x4f()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGLA_1_1Mat4x4f.html">Mat4x4f</a> CGLA::translation_Mat4x4f </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1Vec3f.html">Vec3f</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a translation matrix. </p>

</div>
</div>
<a id="aab84fd049a46bbbda751e1f94bba0620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab84fd049a46bbbda751e1f94bba0620">&#9670;&nbsp;</a></span>transpose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VVT , class HVT , class M1T , class M2T , unsigned int ROWS, unsigned int COLS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CGLA::transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithMatFloat.html">ArithMatFloat</a>&lt; VVT, HVT, M1T, ROWS &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGLA_1_1ArithMatFloat.html">ArithMatFloat</a>&lt; HVT, VVT, M2T, COLS &gt; &amp;&#160;</td>
          <td class="paramname"><em>m_new</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transpose. </p>
<p>See the discussion on mul if you are curious as to why I don't simply return the transpose. </p>

</div>
</div>
<a id="a1cbf3e7f447cc3e38624332103960a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cbf3e7f447cc3e38624332103960a11">&#9670;&nbsp;</a></span>transpose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VT , class MT , unsigned int ROWS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MT CGLA::transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithSqMatFloat.html">ArithSqMatFloat</a>&lt; VT, MT, ROWS &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the transpose of a square matrix. </p>
<p>This function returns the transpose of its argument. </p>

</div>
</div>
<a id="a8faf64d92f0883773655482ab4ae65e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8faf64d92f0883773655482ab4ae65e0">&#9670;&nbsp;</a></span>two_to_what_power()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CGLA::two_to_what_power </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>What power of 2 ?. </p>
<p>if x is the argument, find the largest y so that 2^y &lt;= x </p>

</div>
</div>
<a id="a226d2bca97dde95500b02e7e95ce3746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a226d2bca97dde95500b02e7e95ce3746">&#9670;&nbsp;</a></span>v_max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class V , unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V CGLA::v_max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithVec.html">ArithVec</a>&lt; T, V, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithVec.html">ArithVec</a>&lt; T, V, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the vector containing for each coordinate the largest value from two vectors. </p>

</div>
</div>
<a id="a05d9843a9df34cf8563e01fa1688dd5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05d9843a9df34cf8563e01fa1688dd5a">&#9670;&nbsp;</a></span>v_min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class V , unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V CGLA::v_min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithVec.html">ArithVec</a>&lt; T, V, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGLA_1_1ArithVec.html">ArithVec</a>&lt; T, V, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the vector containing for each coordinate the smallest value from two vectors. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a6913c4e6a433a7ce037427d082c2a654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6913c4e6a433a7ce037427d082c2a654">&#9670;&nbsp;</a></span>BIG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double CGLA::BIG =10e+30</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Numerical constant representing something large. </p>
<p>value is a bit arbitrary </p>

</div>
</div>
<a id="a29f7dc3ae9f0c4223b352fe1bc8967c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f7dc3ae9f0c4223b352fe1bc8967c2">&#9670;&nbsp;</a></span>GEL_RAND_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int CGLA::GEL_RAND_MAX =UINT_MAX</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The GEL pseudo-random number generator uses UINT_MAX as RAND_MAX to avoid mod operations. </p>

</div>
</div>
<a id="adb6166f640b91e99737b997afc26b2a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb6166f640b91e99737b997afc26b2a1">&#9670;&nbsp;</a></span>MINUTE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double CGLA::MINUTE =10e-30</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Numerical constant represents something extremely small. </p>
<p>value is a bit arbitrary </p>

</div>
</div>
<a id="a914b7e71b2d3dfc539ea043d0bc82b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a914b7e71b2d3dfc539ea043d0bc82b29">&#9670;&nbsp;</a></span>SMALL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double CGLA::SMALL =10e-2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Numerical constant represents something small. </p>
<p>value is a bit arbitrary </p>

</div>
</div>
<a id="a868c0c07c06e6482033992880b147818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a868c0c07c06e6482033992880b147818">&#9670;&nbsp;</a></span>TINY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double CGLA::TINY =3e-7</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Numerical constant represents something very small. </p>
<p>value is a bit arbitrary </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
