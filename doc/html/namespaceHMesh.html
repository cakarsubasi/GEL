<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GEL: HMesh Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GEL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">HMesh Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="namespaceHMesh.html" title="The HMesh namespace contains the Manifold class which is a halfedge based mesh.">HMesh</a> namespace contains the <a class="el" href="classHMesh_1_1Manifold.html" title="The Manifold class represents a halfedge based mesh.">Manifold</a> class which is a halfedge based mesh.  
<a href="namespaceHMesh.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMesh_1_1VertexAttributeVector.html">VertexAttributeVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMesh_1_1AttributeVector.html">AttributeVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for <a class="el" href="namespaceHMesh.html" title="The HMesh namespace contains the Manifold class which is a halfedge based mesh.">HMesh</a> entity attribute vectors.  <a href="classHMesh_1_1AttributeVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMesh_1_1FaceAttributeVector.html">FaceAttributeVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMesh_1_1HalfEdgeAttributeVector.html">HalfEdgeAttributeVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMesh_1_1VertexCirculator.html">VertexCirculator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMesh_1_1FaceCirculator.html">FaceCirculator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHMesh_1_1Vertex.html">Vertex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vertex struct. This contains just a single outgoing halfedge.  <a href="structHMesh_1_1Vertex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHMesh_1_1Face.html">Face</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The face struct. Contains a single halfedge.  <a href="structHMesh_1_1Face.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHMesh_1_1HalfEdge.html">HalfEdge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The halfedge struct. Contains IDs of next, previous, and opposite edges as well as incident face and vertex.  <a href="structHMesh_1_1HalfEdge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHMesh_1_1IDRemap.html">IDRemap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structHMesh_1_1IDRemap.html" title="The IDRemap struct is just used for garbage collection.">IDRemap</a> struct is just used for garbage collection.  <a href="structHMesh_1_1IDRemap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMesh_1_1IDSet.html">IDSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of IDs.  <a href="classHMesh_1_1IDSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMesh_1_1ConnectivityKernel.html">ConnectivityKernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The connectivity kernel is basically an aggregate of ItemVectors for vertices, faces, and halfedges.  <a href="classHMesh_1_1ConnectivityKernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHMesh_1_1DijkstraOutput.html">DijkstraOutput</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMesh_1_1ItemID.html">ItemID</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classHMesh_1_1ItemID.html" title="The ItemID class is simply a wrapper around an index.">ItemID</a> class is simply a wrapper around an index.  <a href="classHMesh_1_1ItemID.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMesh_1_1ItemVector.html">ItemVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classHMesh_1_1ItemVector.html" title="The ItemVector is a vector of mesh entities.">ItemVector</a> is a vector of mesh entities.  <a href="classHMesh_1_1ItemVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMesh_1_1IDIterator.html">IDIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the entities of an <a class="el" href="namespaceHMesh.html" title="The HMesh namespace contains the Manifold class which is a halfedge based mesh.">HMesh</a> in the order they are stored in the data structure.  <a href="classHMesh_1_1IDIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMesh_1_1IteratorPair.html">IteratorPair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMesh_1_1Manifold.html">Manifold</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classHMesh_1_1Manifold.html" title="The Manifold class represents a halfedge based mesh.">Manifold</a> class represents a halfedge based mesh.  <a href="classHMesh_1_1Manifold.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMesh_1_1EnergyFun.html">EnergyFun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the energy of an edge. It is used in optimization schemes where edges are swapped (aka flipped). *&zwj;/.  <a href="classHMesh_1_1EnergyFun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMesh_1_1MinAngleEnergy.html">MinAngleEnergy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMesh_1_1DihedralEnergy.html">DihedralEnergy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMesh_1_1CurvatureEnergy.html">CurvatureEnergy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMesh_1_1ValencyEnergy.html">ValencyEnergy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHMesh_1_1Walker.html">Walker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for traversing the entities of a <a class="el" href="namespaceHMesh.html" title="The HMesh namespace contains the Manifold class which is a halfedge based mesh.">HMesh</a>.  <a href="classHMesh_1_1Walker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab2477d35f8899bd49ed5de9df28a8235"><td class="memItemLeft" align="right" valign="top"><a id="ab2477d35f8899bd49ed5de9df28a8235"></a>
typedef <a class="el" href="classHMesh_1_1ItemVector.html">ItemVector</a>&lt; <a class="el" href="structHMesh_1_1Vertex.html">Vertex</a> &gt;::IDType&#160;</td><td class="memItemRight" valign="bottom"><b>VertexID</b></td></tr>
<tr class="separator:ab2477d35f8899bd49ed5de9df28a8235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc85fbec3903874746bcc6024b226fcc"><td class="memItemLeft" align="right" valign="top"><a id="adc85fbec3903874746bcc6024b226fcc"></a>
typedef <a class="el" href="classHMesh_1_1ItemVector.html">ItemVector</a>&lt; <a class="el" href="structHMesh_1_1Face.html">Face</a> &gt;::IDType&#160;</td><td class="memItemRight" valign="bottom"><b>FaceID</b></td></tr>
<tr class="separator:adc85fbec3903874746bcc6024b226fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9163cf51be508d5c169502254971d8b4"><td class="memItemLeft" align="right" valign="top"><a id="a9163cf51be508d5c169502254971d8b4"></a>
typedef <a class="el" href="classHMesh_1_1ItemVector.html">ItemVector</a>&lt; <a class="el" href="structHMesh_1_1HalfEdge.html">HalfEdge</a> &gt;::IDType&#160;</td><td class="memItemRight" valign="bottom"><b>HalfEdgeID</b></td></tr>
<tr class="separator:a9163cf51be508d5c169502254971d8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f964807f63c24b0ca3248197e9c58d"><td class="memItemLeft" align="right" valign="top"><a id="a49f964807f63c24b0ca3248197e9c58d"></a>
typedef <a class="el" href="classHMesh_1_1IDIterator.html">IDIterator</a>&lt; <a class="el" href="structHMesh_1_1Vertex.html">Vertex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>VertexIDIterator</b></td></tr>
<tr class="separator:a49f964807f63c24b0ca3248197e9c58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288bc04de8fd505ca40fb62ab2650396"><td class="memItemLeft" align="right" valign="top"><a id="a288bc04de8fd505ca40fb62ab2650396"></a>
typedef <a class="el" href="classHMesh_1_1IDIterator.html">IDIterator</a>&lt; <a class="el" href="structHMesh_1_1Face.html">Face</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>FaceIDIterator</b></td></tr>
<tr class="separator:a288bc04de8fd505ca40fb62ab2650396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844b5d93534aa42080fa6420683dc75c"><td class="memItemLeft" align="right" valign="top"><a id="a844b5d93534aa42080fa6420683dc75c"></a>
typedef <a class="el" href="classHMesh_1_1IDIterator.html">IDIterator</a>&lt; <a class="el" href="structHMesh_1_1HalfEdge.html">HalfEdge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>HalfEdgeIDIterator</b></td></tr>
<tr class="separator:a844b5d93534aa42080fa6420683dc75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2017dafc77131aa7f2b21f7012f2d06"><td class="memItemLeft" align="right" valign="top"><a id="af2017dafc77131aa7f2b21f7012f2d06"></a>
typedef std::map&lt; VertexID, VertexID &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>VertexIDRemap</b></td></tr>
<tr class="separator:af2017dafc77131aa7f2b21f7012f2d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e830d1bae6ecff5cd6997b76532a942"><td class="memItemLeft" align="right" valign="top"><a id="a5e830d1bae6ecff5cd6997b76532a942"></a>
typedef std::map&lt; FaceID, FaceID &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>FaceIDRemap</b></td></tr>
<tr class="separator:a5e830d1bae6ecff5cd6997b76532a942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba01df3466b0b3a774b59a25ab00047"><td class="memItemLeft" align="right" valign="top"><a id="aeba01df3466b0b3a774b59a25ab00047"></a>
typedef std::map&lt; HalfEdgeID, HalfEdgeID &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>HalfEdgeIDRemap</b></td></tr>
<tr class="separator:aeba01df3466b0b3a774b59a25ab00047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3359aad6cb722629b1d9b6fe493ede41"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a3359aad6cb722629b1d9b6fe493ede41">VertexSet</a> = <a class="el" href="classHMesh_1_1IDSet.html">IDSet</a>&lt; <a class="el" href="structHMesh_1_1Vertex.html">Vertex</a> &gt;</td></tr>
<tr class="memdesc:a3359aad6cb722629b1d9b6fe493ede41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of vertices.  <a href="namespaceHMesh.html#a3359aad6cb722629b1d9b6fe493ede41">More...</a><br /></td></tr>
<tr class="separator:a3359aad6cb722629b1d9b6fe493ede41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a57d545ddd8234734991a3e6fb993f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a85a57d545ddd8234734991a3e6fb993f">FaceSet</a> = <a class="el" href="classHMesh_1_1IDSet.html">IDSet</a>&lt; <a class="el" href="structHMesh_1_1Face.html">Face</a> &gt;</td></tr>
<tr class="memdesc:a85a57d545ddd8234734991a3e6fb993f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of faces.  <a href="namespaceHMesh.html#a85a57d545ddd8234734991a3e6fb993f">More...</a><br /></td></tr>
<tr class="separator:a85a57d545ddd8234734991a3e6fb993f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c5194c50ed11d7f2d4c8cfa1e3cffa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#ab5c5194c50ed11d7f2d4c8cfa1e3cffa">HalfEdgeSet</a> = <a class="el" href="classHMesh_1_1IDSet.html">IDSet</a>&lt; <a class="el" href="structHMesh_1_1HalfEdge.html">HalfEdge</a> &gt;</td></tr>
<tr class="memdesc:ab5c5194c50ed11d7f2d4c8cfa1e3cffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of halfedges.  <a href="namespaceHMesh.html#ab5c5194c50ed11d7f2d4c8cfa1e3cffa">More...</a><br /></td></tr>
<tr class="separator:ab5c5194c50ed11d7f2d4c8cfa1e3cffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a1f3b64eb41a33601629ed9ea8c617847"><td class="memItemLeft" align="right" valign="top"><a id="a1f3b64eb41a33601629ed9ea8c617847"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>NormalSmoothMethod</b> { <b>FVM_NORMAL_SMOOTH</b>
, <b>BILATERAL_NORMAL_SMOOTH</b>
 }</td></tr>
<tr class="separator:a1f3b64eb41a33601629ed9ea8c617847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac835cb5f41dd3f0598259b1816ed3ed2"><td class="memItemLeft" align="right" valign="top"><a id="ac835cb5f41dd3f0598259b1816ed3ed2"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>TriangulationMethod</b> { <b>CLIP_EAR</b>
, <b>SHORTEST_EDGE</b>
 }</td></tr>
<tr class="separator:ac835cb5f41dd3f0598259b1816ed3ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6bfeb37978ea98fba3478ba00744e827"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a6bfeb37978ea98fba3478ba00744e827">remove_caps</a> (<a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, float thresh)</td></tr>
<tr class="memdesc:a6bfeb37978ea98fba3478ba00744e827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove caps from a manifold consisting of only triangles.  <a href="namespaceHMesh.html#a6bfeb37978ea98fba3478ba00744e827">More...</a><br /></td></tr>
<tr class="separator:a6bfeb37978ea98fba3478ba00744e827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b032514e541e901cf6c2ed169d4cf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a52b032514e541e901cf6c2ed169d4cf6">remove_needles</a> (<a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, float thresh=0.1, bool averagePositions=true)</td></tr>
<tr class="memdesc:a52b032514e541e901cf6c2ed169d4cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove needles from a manifold consisting of only triangles.  <a href="namespaceHMesh.html#a52b032514e541e901cf6c2ed169d4cf6">More...</a><br /></td></tr>
<tr class="separator:a52b032514e541e901cf6c2ed169d4cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402ba7f70f9eeedc1ff8207d604e0cd5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a402ba7f70f9eeedc1ff8207d604e0cd5">stitch_mesh</a> (<a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, double rad)</td></tr>
<tr class="memdesc:a402ba7f70f9eeedc1ff8207d604e0cd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stitch together edges whose endpoints coincide geometrically.  <a href="namespaceHMesh.html#a402ba7f70f9eeedc1ff8207d604e0cd5">More...</a><br /></td></tr>
<tr class="separator:a402ba7f70f9eeedc1ff8207d604e0cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0260d79bf1aba8b7a94d0fc38a81e7a"><td class="memItemLeft" align="right" valign="top"><a id="ad0260d79bf1aba8b7a94d0fc38a81e7a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>stitch_mesh</b> (<a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, const <a class="el" href="classHMesh_1_1VertexAttributeVector.html">VertexAttributeVector</a>&lt; int &gt; &amp;cluster_id)</td></tr>
<tr class="separator:ad0260d79bf1aba8b7a94d0fc38a81e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00005c75c1b6d0307eb34b705bc01731"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a00005c75c1b6d0307eb34b705bc01731">stitch_more</a> (<a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, double rad)</td></tr>
<tr class="memdesc:a00005c75c1b6d0307eb34b705bc01731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stitches the mesh together, splits edges that could not be stitched and goes again.  <a href="namespaceHMesh.html#a00005c75c1b6d0307eb34b705bc01731">More...</a><br /></td></tr>
<tr class="separator:a00005c75c1b6d0307eb34b705bc01731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8772d2bebaff87460236b2ac9614c734"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a8772d2bebaff87460236b2ac9614c734">close_holes</a> (<a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, int max_size=100)</td></tr>
<tr class="memdesc:a8772d2bebaff87460236b2ac9614c734"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function replaces holes by faces.  <a href="namespaceHMesh.html#a8772d2bebaff87460236b2ac9614c734">More...</a><br /></td></tr>
<tr class="separator:a8772d2bebaff87460236b2ac9614c734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53eabfab6b40b034457bc67f04afa73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#ac53eabfab6b40b034457bc67f04afa73">flip_orientation</a> (<a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m)</td></tr>
<tr class="memdesc:ac53eabfab6b40b034457bc67f04afa73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip the orientation of a mesh.  <a href="namespaceHMesh.html#ac53eabfab6b40b034457bc67f04afa73">More...</a><br /></td></tr>
<tr class="separator:ac53eabfab6b40b034457bc67f04afa73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7830724b70d835f9ad975a370073c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a4e7830724b70d835f9ad975a370073c8">remove_valence_two_vertices</a> (<a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m)</td></tr>
<tr class="memdesc:a4e7830724b70d835f9ad975a370073c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove valence two vertices.  <a href="namespaceHMesh.html#a4e7830724b70d835f9ad975a370073c8">More...</a><br /></td></tr>
<tr class="separator:a4e7830724b70d835f9ad975a370073c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fff1b56c3c6d1c356df1c53b279559b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a8fff1b56c3c6d1c356df1c53b279559b">merge_coincident_boundary_vertices</a> (<a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, double rad=1e-30)</td></tr>
<tr class="memdesc:a8fff1b56c3c6d1c356df1c53b279559b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function merges pairs of boundary vertices, provided there are exactly two such vertices at a given point in space, that they are not in each others' one ring and that the one rings are disjoint.  <a href="namespaceHMesh.html#a8fff1b56c3c6d1c356df1c53b279559b">More...</a><br /></td></tr>
<tr class="separator:a8fff1b56c3c6d1c356df1c53b279559b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925bdd3c0f946f359ac74e98acd86c29"><td class="memItemLeft" align="right" valign="top"><a id="a925bdd3c0f946f359ac74e98acd86c29"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>mixed_area</b> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, VertexID v)</td></tr>
<tr class="separator:a925bdd3c0f946f359ac74e98acd86c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c37634784bab4172e2d86de19ac835"><td class="memItemLeft" align="right" valign="top"><a id="aa9c37634784bab4172e2d86de19ac835"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>barycentric_area</b> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, VertexID v)</td></tr>
<tr class="separator:aa9c37634784bab4172e2d86de19ac835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a78ea201030eb6805609db26ded1652"><td class="memItemLeft" align="right" valign="top"><a id="a3a78ea201030eb6805609db26ded1652"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unnormalized_mean_curvature_normal</b> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, VertexID v, <a class="el" href="classCGLA_1_1Vec3d.html">CGLA::Vec3d</a> &amp;curv_normal, double &amp;w_sum)</td></tr>
<tr class="separator:a3a78ea201030eb6805609db26ded1652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9d8a6d831435a3c489c7abb867fe31"><td class="memItemLeft" align="right" valign="top"><a id="a0f9d8a6d831435a3c489c7abb867fe31"></a>
<a class="el" href="classCGLA_1_1Vec3d.html">CGLA::Vec3d</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mean_curvature_normal</b> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, VertexID v)</td></tr>
<tr class="separator:a0f9d8a6d831435a3c489c7abb867fe31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00efab6f66e9826d720d4e0717375508"><td class="memItemLeft" align="right" valign="top"><a id="a00efab6f66e9826d720d4e0717375508"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>sum_curvatures</b> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, <a class="el" href="classHMesh_1_1VertexAttributeVector.html">VertexAttributeVector</a>&lt; double &gt; &amp;curvature)</td></tr>
<tr class="separator:a00efab6f66e9826d720d4e0717375508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3abc03b228bd15a415fcc29b863225f"><td class="memItemLeft" align="right" valign="top"><a id="ae3abc03b228bd15a415fcc29b863225f"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>gaussian_curvature_angle_defect</b> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, VertexID v)</td></tr>
<tr class="separator:ae3abc03b228bd15a415fcc29b863225f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8c538bac80c11deafe4528a5d41870"><td class="memItemLeft" align="right" valign="top"><a id="aca8c538bac80c11deafe4528a5d41870"></a>
<a class="el" href="classCGLA_1_1Mat3x3d.html">CGLA::Mat3x3d</a>&#160;</td><td class="memItemRight" valign="bottom"><b>curvature_tensor</b> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, HalfEdgeID h)</td></tr>
<tr class="separator:aca8c538bac80c11deafe4528a5d41870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5bce5cd3bbb6b823b54fb04ebe0cd5"><td class="memItemLeft" align="right" valign="top"><a id="a8d5bce5cd3bbb6b823b54fb04ebe0cd5"></a>
<a class="el" href="classCGLA_1_1Mat3x3d.html">CGLA::Mat3x3d</a>&#160;</td><td class="memItemRight" valign="bottom"><b>curvature_tensor_from_edge</b> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, HalfEdgeID h)</td></tr>
<tr class="separator:a8d5bce5cd3bbb6b823b54fb04ebe0cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37daf2ee996b4fad449819ce615942a2"><td class="memItemLeft" align="right" valign="top"><a id="a37daf2ee996b4fad449819ce615942a2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>curvature_tensor_paraboloid</b> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, VertexID v, <a class="el" href="classCGLA_1_1Mat2x2d.html">CGLA::Mat2x2d</a> &amp;curv_tensor, <a class="el" href="classCGLA_1_1Mat3x3d.html">CGLA::Mat3x3d</a> &amp;frame)</td></tr>
<tr class="separator:a37daf2ee996b4fad449819ce615942a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7144b973f8bb3909cb8ce57238644ea"><td class="memItemLeft" align="right" valign="top"><a id="ac7144b973f8bb3909cb8ce57238644ea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>curvature_tensors_from_edges</b> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, <a class="el" href="classHMesh_1_1VertexAttributeVector.html">VertexAttributeVector</a>&lt; <a class="el" href="classCGLA_1_1Mat3x3d.html">CGLA::Mat3x3d</a> &gt; &amp;curvature_tensors)</td></tr>
<tr class="separator:ac7144b973f8bb3909cb8ce57238644ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c167cdf236f5e8f19b1bb4d128c133"><td class="memItemLeft" align="right" valign="top"><a id="a54c167cdf236f5e8f19b1bb4d128c133"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>smooth_curvature_tensors</b> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, <a class="el" href="classHMesh_1_1VertexAttributeVector.html">VertexAttributeVector</a>&lt; <a class="el" href="classCGLA_1_1Mat3x3d.html">CGLA::Mat3x3d</a> &gt; &amp;curvature_tensors)</td></tr>
<tr class="separator:a54c167cdf236f5e8f19b1bb4d128c133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea1abba9f8f4b5434e533a195dc302c"><td class="memItemLeft" align="right" valign="top"><a id="a0ea1abba9f8f4b5434e533a195dc302c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>gaussian_curvature_angle_defects</b> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, <a class="el" href="classHMesh_1_1VertexAttributeVector.html">VertexAttributeVector</a>&lt; double &gt; &amp;curvature, int smooth_steps=0)</td></tr>
<tr class="separator:a0ea1abba9f8f4b5434e533a195dc302c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58d62f23cf721a43a6b60c524d6ea38"><td class="memItemLeft" align="right" valign="top"><a id="ac58d62f23cf721a43a6b60c524d6ea38"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mean_curvatures</b> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, <a class="el" href="classHMesh_1_1VertexAttributeVector.html">VertexAttributeVector</a>&lt; double &gt; &amp;curvature, int smooth_steps=0)</td></tr>
<tr class="separator:ac58d62f23cf721a43a6b60c524d6ea38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b02c73e10938d1695b8984fe041da93"><td class="memItemLeft" align="right" valign="top"><a id="a9b02c73e10938d1695b8984fe041da93"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>curvature_paraboloids</b> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, <a class="el" href="classHMesh_1_1VertexAttributeVector.html">VertexAttributeVector</a>&lt; <a class="el" href="classCGLA_1_1Vec3d.html">CGLA::Vec3d</a> &gt; &amp;min_curv_direction, <a class="el" href="classHMesh_1_1VertexAttributeVector.html">VertexAttributeVector</a>&lt; <a class="el" href="classCGLA_1_1Vec3d.html">CGLA::Vec3d</a> &gt; &amp;max_curv_direction, <a class="el" href="classHMesh_1_1VertexAttributeVector.html">VertexAttributeVector</a>&lt; <a class="el" href="classCGLA_1_1Vec2d.html">CGLA::Vec2d</a> &gt; &amp;curvature)</td></tr>
<tr class="separator:a9b02c73e10938d1695b8984fe041da93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4eb9c2dacbe40e6c5d578fc81185ba"><td class="memItemLeft" align="right" valign="top"><a id="a2c4eb9c2dacbe40e6c5d578fc81185ba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>curvature_from_tensors</b> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, const <a class="el" href="classHMesh_1_1VertexAttributeVector.html">VertexAttributeVector</a>&lt; <a class="el" href="classCGLA_1_1Mat3x3d.html">CGLA::Mat3x3d</a> &gt; &amp;curvature_tensors, <a class="el" href="classHMesh_1_1VertexAttributeVector.html">VertexAttributeVector</a>&lt; <a class="el" href="classCGLA_1_1Vec3d.html">CGLA::Vec3d</a> &gt; &amp;min_curv_direction, <a class="el" href="classHMesh_1_1VertexAttributeVector.html">VertexAttributeVector</a>&lt; <a class="el" href="classCGLA_1_1Vec3d.html">CGLA::Vec3d</a> &gt; &amp;max_curv_direction, <a class="el" href="classHMesh_1_1VertexAttributeVector.html">VertexAttributeVector</a>&lt; <a class="el" href="classCGLA_1_1Vec2d.html">CGLA::Vec2d</a> &gt; &amp;curvature)</td></tr>
<tr class="separator:a2c4eb9c2dacbe40e6c5d578fc81185ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b9246eae0fa03238480c484a892be9"><td class="memItemLeft" align="right" valign="top"><a id="a21b9246eae0fa03238480c484a892be9"></a>
<a class="el" href="classHMesh_1_1Manifold.html">HMesh::Manifold</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Delaunay_triangulate</b> (const std::vector&lt; <a class="el" href="classCGLA_1_1Vec3d.html">CGLA::Vec3d</a> &gt; &amp;pts3d, const <a class="el" href="classCGLA_1_1Vec3d.html">CGLA::Vec3d</a> &amp;X_axis=<a class="el" href="classCGLA_1_1Vec3d.html">CGLA::Vec3d</a>(1, 0, 0), const <a class="el" href="classCGLA_1_1Vec3d.html">CGLA::Vec3d</a> &amp;Y_axis=<a class="el" href="classCGLA_1_1Vec3d.html">CGLA::Vec3d</a>(0, 1, 0))</td></tr>
<tr class="separator:a21b9246eae0fa03238480c484a892be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e04ba9b1d99905bebc0fb128bdc9f6"><td class="memItemLeft" align="right" valign="top"><a id="a00e04ba9b1d99905bebc0fb128bdc9f6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dual</b> (<a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m)</td></tr>
<tr class="separator:a00e04ba9b1d99905bebc0fb128bdc9f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1171524b980dd95c2fa317e4d8dde0e8"><td class="memItemLeft" align="right" valign="top"><a id="a1171524b980dd95c2fa317e4d8dde0e8"></a>
<a class="el" href="structHMesh_1_1DijkstraOutput.html">DijkstraOutput</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Dijkstra</b> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, VertexID source, <a class="el" href="namespaceHMesh.html#a3359aad6cb722629b1d9b6fe493ede41">VertexSet</a> region=<a class="el" href="namespaceHMesh.html#a3359aad6cb722629b1d9b6fe493ede41">VertexSet</a>())</td></tr>
<tr class="separator:a1171524b980dd95c2fa317e4d8dde0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8977dcd83c107dd96840349dc8819106"><td class="memItemLeft" align="right" valign="top"><a id="a8977dcd83c107dd96840349dc8819106"></a>
<a class="el" href="classHMesh_1_1VertexAttributeVector.html">VertexAttributeVector</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>backpropagate_subtree_sizes</b> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, const <a class="el" href="structHMesh_1_1DijkstraOutput.html">DijkstraOutput</a> &amp;)</td></tr>
<tr class="separator:a8977dcd83c107dd96840349dc8819106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bed7cf3a6527a1ca77988e8c3dc65dc"><td class="memTemplParams" colspan="2"><a id="a9bed7cf3a6527a1ca77988e8c3dc65dc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9bed7cf3a6527a1ca77988e8c3dc65dc"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classHMesh_1_1ItemID.html">ItemID</a>&lt; T &gt; &amp;iid)</td></tr>
<tr class="separator:a9bed7cf3a6527a1ca77988e8c3dc65dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394c133900cd07b8752b0b9679212d7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a394c133900cd07b8752b0b9679212d7c">load</a> (const std::string &amp;, <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;)</td></tr>
<tr class="memdesc:a394c133900cd07b8752b0b9679212d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a geometry file. This could be a PLY, OBJ, X3D, or OFF file.  <a href="namespaceHMesh.html#a394c133900cd07b8752b0b9679212d7c">More...</a><br /></td></tr>
<tr class="separator:a394c133900cd07b8752b0b9679212d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac133c861b65b755aa1112ffe6ad0a6c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMesh_1_1VertexAttributeVector.html">VertexAttributeVector</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#ac133c861b65b755aa1112ffe6ad0a6c9">build</a> (<a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, size_t no_vertices, const float *vertvec, size_t no_faces, const int *facevec, const int *indices)</td></tr>
<tr class="memdesc:ac133c861b65b755aa1112ffe6ad0a6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a manifold.  <a href="namespaceHMesh.html#ac133c861b65b755aa1112ffe6ad0a6c9">More...</a><br /></td></tr>
<tr class="separator:ac133c861b65b755aa1112ffe6ad0a6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9baa789f078529210812e418afc2cf25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMesh_1_1VertexAttributeVector.html">VertexAttributeVector</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a9baa789f078529210812e418afc2cf25">build</a> (<a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, size_t no_vertices, const double *vertvec, size_t no_faces, const int *facevec, const int *indices)</td></tr>
<tr class="memdesc:a9baa789f078529210812e418afc2cf25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a manifold.  <a href="namespaceHMesh.html#a9baa789f078529210812e418afc2cf25">More...</a><br /></td></tr>
<tr class="separator:a9baa789f078529210812e418afc2cf25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4bc15ec0b7db2cb17a87a26c8d7e3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMesh_1_1VertexAttributeVector.html">VertexAttributeVector</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#acb4bc15ec0b7db2cb17a87a26c8d7e3c">build</a> (<a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, const <a class="el" href="classGeometry_1_1TriMesh.html">Geometry::TriMesh</a> &amp;<a class="el" href="classmesh.html">mesh</a>)</td></tr>
<tr class="memdesc:acb4bc15ec0b7db2cb17a87a26c8d7e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a manifold from a TriMesh.  <a href="namespaceHMesh.html#acb4bc15ec0b7db2cb17a87a26c8d7e3c">More...</a><br /></td></tr>
<tr class="separator:acb4bc15ec0b7db2cb17a87a26c8d7e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad2e94f52a1763876e80cc60e6a7c31"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a9ad2e94f52a1763876e80cc60e6a7c31">find_invalid_entities</a> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, <a class="el" href="namespaceHMesh.html#a3359aad6cb722629b1d9b6fe493ede41">VertexSet</a> &amp;vs, <a class="el" href="namespaceHMesh.html#ab5c5194c50ed11d7f2d4c8cfa1e3cffa">HalfEdgeSet</a> &amp;hs, <a class="el" href="namespaceHMesh.html#a85a57d545ddd8234734991a3e6fb993f">FaceSet</a> &amp;fs)</td></tr>
<tr class="memdesc:a9ad2e94f52a1763876e80cc60e6a7c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify <a class="el" href="classHMesh_1_1Manifold.html" title="The Manifold class represents a halfedge based mesh.">Manifold</a> Integrity Performs a series of tests to check that this is a valid manifold.  <a href="namespaceHMesh.html#a9ad2e94f52a1763876e80cc60e6a7c31">More...</a><br /></td></tr>
<tr class="separator:a9ad2e94f52a1763876e80cc60e6a7c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb92e38765f7e69659d736553846fac"><td class="memItemLeft" align="right" valign="top"><a id="a3eb92e38765f7e69659d736553846fac"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>valid</b> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m)</td></tr>
<tr class="separator:a3eb92e38765f7e69659d736553846fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9111e728908fdc3eefbc82c38340a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#adc9111e728908fdc3eefbc82c38340a3">bbox</a> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, <a class="el" href="classHMesh_1_1Manifold.html#addeb1166a6148a372b91787509604d6c">Manifold::Vec</a> &amp;pmin, <a class="el" href="classHMesh_1_1Manifold.html#addeb1166a6148a372b91787509604d6c">Manifold::Vec</a> &amp;pmax)</td></tr>
<tr class="memdesc:adc9111e728908fdc3eefbc82c38340a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the bounding box of the manifold.  <a href="namespaceHMesh.html#adc9111e728908fdc3eefbc82c38340a3">More...</a><br /></td></tr>
<tr class="separator:adc9111e728908fdc3eefbc82c38340a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab818ab0617e0e443b3a8dc0531f9aa6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#ab818ab0617e0e443b3a8dc0531f9aa6e">bsphere</a> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, <a class="el" href="classHMesh_1_1Manifold.html#addeb1166a6148a372b91787509604d6c">Manifold::Vec</a> &amp;c, float &amp;r)</td></tr>
<tr class="memdesc:ab818ab0617e0e443b3a8dc0531f9aa6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the bounding sphere of the manifold.  <a href="namespaceHMesh.html#ab818ab0617e0e443b3a8dc0531f9aa6e">More...</a><br /></td></tr>
<tr class="separator:ab818ab0617e0e443b3a8dc0531f9aa6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e1ef60db88302f038e7d54af100bbd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a91e1ef60db88302f038e7d54af100bbd">precond_collapse_edge</a> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, HalfEdgeID h)</td></tr>
<tr class="memdesc:a91e1ef60db88302f038e7d54af100bbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test for legal edge collapse.  <a href="namespaceHMesh.html#a91e1ef60db88302f038e7d54af100bbd">More...</a><br /></td></tr>
<tr class="separator:a91e1ef60db88302f038e7d54af100bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e4972e4b2cf3fba427e7ef13d607c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#ae0e4972e4b2cf3fba427e7ef13d607c7">precond_flip_edge</a> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, HalfEdgeID h)</td></tr>
<tr class="memdesc:ae0e4972e4b2cf3fba427e7ef13d607c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test fpr legal edge flip.  <a href="namespaceHMesh.html#ae0e4972e4b2cf3fba427e7ef13d607c7">More...</a><br /></td></tr>
<tr class="separator:ae0e4972e4b2cf3fba427e7ef13d607c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac931a6ffdbf14f33192fb54e74528276"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#ac931a6ffdbf14f33192fb54e74528276">boundary</a> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, HalfEdgeID h)</td></tr>
<tr class="memdesc:ac931a6ffdbf14f33192fb54e74528276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the halfedge is a boundary halfedge.  <a href="namespaceHMesh.html#ac931a6ffdbf14f33192fb54e74528276">More...</a><br /></td></tr>
<tr class="separator:ac931a6ffdbf14f33192fb54e74528276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f87ef03b98c2b265a924b97eeed20b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a76f87ef03b98c2b265a924b97eeed20b">closed</a> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m)</td></tr>
<tr class="memdesc:a76f87ef03b98c2b265a924b97eeed20b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the mesh is closed, i.e. has no boundary.  <a href="namespaceHMesh.html#a76f87ef03b98c2b265a924b97eeed20b">More...</a><br /></td></tr>
<tr class="separator:a76f87ef03b98c2b265a924b97eeed20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298f09a535601bf723ba125b1d20bd4b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a298f09a535601bf723ba125b1d20bd4b">length</a> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, HalfEdgeID h)</td></tr>
<tr class="memdesc:a298f09a535601bf723ba125b1d20bd4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the geometric length of a halfedge.  <a href="namespaceHMesh.html#a298f09a535601bf723ba125b1d20bd4b">More...</a><br /></td></tr>
<tr class="separator:a298f09a535601bf723ba125b1d20bd4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3548c0b7d14893caa570c48047fe6b35"><td class="memItemLeft" align="right" valign="top">HalfEdgeID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a3548c0b7d14893caa570c48047fe6b35">boundary_edge</a> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, VertexID v)</td></tr>
<tr class="memdesc:a3548c0b7d14893caa570c48047fe6b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the id of the boundary edge or InvalidHalfEdgeID if the vertex is not on the boundary.  <a href="namespaceHMesh.html#a3548c0b7d14893caa570c48047fe6b35">More...</a><br /></td></tr>
<tr class="separator:a3548c0b7d14893caa570c48047fe6b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a98d70f5fdfc2d216070e8733f9c62"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a23a98d70f5fdfc2d216070e8733f9c62">valency</a> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, VertexID v)</td></tr>
<tr class="memdesc:a23a98d70f5fdfc2d216070e8733f9c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute valency, i.e. number of incident edges.  <a href="namespaceHMesh.html#a23a98d70f5fdfc2d216070e8733f9c62">More...</a><br /></td></tr>
<tr class="separator:a23a98d70f5fdfc2d216070e8733f9c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa272182ccadcc426cb09bf70c839b44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMesh_1_1Manifold.html#addeb1166a6148a372b91787509604d6c">Manifold::Vec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#afa272182ccadcc426cb09bf70c839b44">normal</a> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, VertexID v)</td></tr>
<tr class="memdesc:afa272182ccadcc426cb09bf70c839b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the vertex normal. This function computes the angle weighted sum of incident face normals.  <a href="namespaceHMesh.html#afa272182ccadcc426cb09bf70c839b44">More...</a><br /></td></tr>
<tr class="separator:afa272182ccadcc426cb09bf70c839b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a17a05760b3b6f15d0c256741d7ec9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMesh_1_1Manifold.html#addeb1166a6148a372b91787509604d6c">Manifold::Vec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#ad4a17a05760b3b6f15d0c256741d7ec9">area_normal</a> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, FaceID f)</td></tr>
<tr class="memdesc:ad4a17a05760b3b6f15d0c256741d7ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the vertex normal but multiplied by the area of the face. This is more efficient if both area and normal are needed.  <a href="namespaceHMesh.html#ad4a17a05760b3b6f15d0c256741d7ec9">More...</a><br /></td></tr>
<tr class="separator:ad4a17a05760b3b6f15d0c256741d7ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1e4f1de66565a8c774f5ebe7dd02ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#acd1e4f1de66565a8c774f5ebe7dd02ff">connected</a> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, VertexID v0, VertexID v1)</td></tr>
<tr class="memdesc:acd1e4f1de66565a8c774f5ebe7dd02ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the two argument vertices are in each other's one-rings.  <a href="namespaceHMesh.html#acd1e4f1de66565a8c774f5ebe7dd02ff">More...</a><br /></td></tr>
<tr class="separator:acd1e4f1de66565a8c774f5ebe7dd02ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb4dc06bbcaf9497cec7c1d13e426fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#adfb4dc06bbcaf9497cec7c1d13e426fe">no_edges</a> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, FaceID f)</td></tr>
<tr class="memdesc:adfb4dc06bbcaf9497cec7c1d13e426fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of edges of a face.  <a href="namespaceHMesh.html#adfb4dc06bbcaf9497cec7c1d13e426fe">More...</a><br /></td></tr>
<tr class="separator:adfb4dc06bbcaf9497cec7c1d13e426fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a2f50aae9135987654459831df3973"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#ae6a2f50aae9135987654459831df3973">area</a> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, FaceID f)</td></tr>
<tr class="memdesc:ae6a2f50aae9135987654459831df3973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the area of a face.  <a href="namespaceHMesh.html#ae6a2f50aae9135987654459831df3973">More...</a><br /></td></tr>
<tr class="separator:ae6a2f50aae9135987654459831df3973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac551c6ac0965c6a150ac701259ac59f6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#ac551c6ac0965c6a150ac701259ac59f6">perimeter</a> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, FaceID f)</td></tr>
<tr class="memdesc:ac551c6ac0965c6a150ac701259ac59f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the perimeter of a face.  <a href="namespaceHMesh.html#ac551c6ac0965c6a150ac701259ac59f6">More...</a><br /></td></tr>
<tr class="separator:ac551c6ac0965c6a150ac701259ac59f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e31843ef282d5958427d54b39da7ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMesh_1_1Manifold.html#addeb1166a6148a372b91787509604d6c">Manifold::Vec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a08e31843ef282d5958427d54b39da7ac">centre</a> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, FaceID f)</td></tr>
<tr class="memdesc:a08e31843ef282d5958427d54b39da7ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the centre of a face.  <a href="namespaceHMesh.html#a08e31843ef282d5958427d54b39da7ac">More...</a><br /></td></tr>
<tr class="separator:a08e31843ef282d5958427d54b39da7ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61bafc672b23ef1df0cb667c237bca23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHMesh_1_1Manifold.html#addeb1166a6148a372b91787509604d6c">Manifold::Vec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a61bafc672b23ef1df0cb667c237bca23">barycenter</a> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, FaceID f)</td></tr>
<tr class="memdesc:a61bafc672b23ef1df0cb667c237bca23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the barycenter of a face (with American spelling).  <a href="namespaceHMesh.html#a61bafc672b23ef1df0cb667c237bca23">More...</a><br /></td></tr>
<tr class="separator:a61bafc672b23ef1df0cb667c237bca23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781f805fd9b673a118aea13cc9a62dea"><td class="memItemLeft" align="right" valign="top"><a id="a781f805fd9b673a118aea13cc9a62dea"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>circulate_vertex_ccw</b> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, VertexID v, std::function&lt; void(<a class="el" href="classHMesh_1_1Walker.html">Walker</a> &amp;)&gt; f)</td></tr>
<tr class="separator:a781f805fd9b673a118aea13cc9a62dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99755fac37624d7156ca66778203d21d"><td class="memItemLeft" align="right" valign="top"><a id="a99755fac37624d7156ca66778203d21d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>circulate_vertex_ccw</b> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, VertexID v, std::function&lt; void(VertexID)&gt; f)</td></tr>
<tr class="separator:a99755fac37624d7156ca66778203d21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cdaa121a9f839b4deac2efb65ef1f9d"><td class="memItemLeft" align="right" valign="top"><a id="a3cdaa121a9f839b4deac2efb65ef1f9d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>circulate_vertex_cw</b> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, VertexID v, std::function&lt; void(<a class="el" href="classHMesh_1_1Walker.html">Walker</a> &amp;)&gt; f)</td></tr>
<tr class="separator:a3cdaa121a9f839b4deac2efb65ef1f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae728fd90b3b5ad9cde2fc90bd9d05ea3"><td class="memItemLeft" align="right" valign="top"><a id="ae728fd90b3b5ad9cde2fc90bd9d05ea3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>circulate_vertex_cw</b> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, VertexID v, std::function&lt; void(VertexID)&gt; f)</td></tr>
<tr class="separator:ae728fd90b3b5ad9cde2fc90bd9d05ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd67aa792692127243a496031ef4524"><td class="memItemLeft" align="right" valign="top"><a id="adbd67aa792692127243a496031ef4524"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>circulate_face_ccw</b> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, FaceID f, std::function&lt; void(<a class="el" href="classHMesh_1_1Walker.html">Walker</a> &amp;)&gt; g)</td></tr>
<tr class="separator:adbd67aa792692127243a496031ef4524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ba8750df614fc0e159ae9bec1424d2"><td class="memItemLeft" align="right" valign="top"><a id="ae7ba8750df614fc0e159ae9bec1424d2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>circulate_face_ccw</b> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, FaceID f, std::function&lt; void(VertexID)&gt; g)</td></tr>
<tr class="separator:ae7ba8750df614fc0e159ae9bec1424d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aba3390b11830f078347b4f0e5197f5"><td class="memItemLeft" align="right" valign="top"><a id="a0aba3390b11830f078347b4f0e5197f5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>circulate_face_cw</b> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, FaceID f, std::function&lt; void(<a class="el" href="classHMesh_1_1Walker.html">Walker</a> &amp;)&gt; g)</td></tr>
<tr class="separator:a0aba3390b11830f078347b4f0e5197f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c04f95876a57951d340820e8752edf"><td class="memItemLeft" align="right" valign="top"><a id="a06c04f95876a57951d340820e8752edf"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>circulate_face_cw</b> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, FaceID f, std::function&lt; void(VertexID)&gt; g)</td></tr>
<tr class="separator:a06c04f95876a57951d340820e8752edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b14bcf8bdef656cf6ced38a3f2b1437"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a7b14bcf8bdef656cf6ced38a3f2b1437">priority_queue_optimization</a> (<a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, const <a class="el" href="classHMesh_1_1EnergyFun.html">EnergyFun</a> &amp;efun)</td></tr>
<tr class="memdesc:a7b14bcf8bdef656cf6ced38a3f2b1437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize in a greedy fashion.  <a href="namespaceHMesh.html#a7b14bcf8bdef656cf6ced38a3f2b1437">More...</a><br /></td></tr>
<tr class="separator:a7b14bcf8bdef656cf6ced38a3f2b1437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a7860d676cc92c8649d4587d9fe35d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a15a7860d676cc92c8649d4587d9fe35d">simulated_annealing_optimization</a> (<a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, const <a class="el" href="classHMesh_1_1EnergyFun.html">EnergyFun</a> &amp;efun, int max_iter=10000)</td></tr>
<tr class="memdesc:a15a7860d676cc92c8649d4587d9fe35d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize with simulated annealing. Avoids getting trapped in local minima.  <a href="namespaceHMesh.html#a15a7860d676cc92c8649d4587d9fe35d">More...</a><br /></td></tr>
<tr class="separator:a15a7860d676cc92c8649d4587d9fe35d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1761800ef0c39208e49371fda3f09c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a1761800ef0c39208e49371fda3f09c12">minimize_dihedral_angle</a> (<a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, int max_iter=10000, bool anneal=false, bool alpha=false, double gamma=4.0)</td></tr>
<tr class="memdesc:a1761800ef0c39208e49371fda3f09c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimize the angle between adjacent triangles. Almost the same as mean curvature minimization.  <a href="namespaceHMesh.html#a1761800ef0c39208e49371fda3f09c12">More...</a><br /></td></tr>
<tr class="separator:a1761800ef0c39208e49371fda3f09c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf03d6162622513b7c54d82ae9815164"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#abf03d6162622513b7c54d82ae9815164">minimize_curvature</a> (<a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, bool anneal=false)</td></tr>
<tr class="memdesc:abf03d6162622513b7c54d82ae9815164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimizes mean curvature. This is really the same as dihedral angle optimization except that we weight by edge length.  <a href="namespaceHMesh.html#abf03d6162622513b7c54d82ae9815164">More...</a><br /></td></tr>
<tr class="separator:abf03d6162622513b7c54d82ae9815164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2e836221aa25f553aad1e39f455a6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a1e2e836221aa25f553aad1e39f455a6c">minimize_gauss_curvature</a> (<a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, bool anneal=false)</td></tr>
<tr class="memdesc:a1e2e836221aa25f553aad1e39f455a6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimizes gaussian curvature. Probably less useful than mean curvature.  <a href="namespaceHMesh.html#a1e2e836221aa25f553aad1e39f455a6c">More...</a><br /></td></tr>
<tr class="separator:a1e2e836221aa25f553aad1e39f455a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d36f9cd3abcc6311f748454741eaea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a67d36f9cd3abcc6311f748454741eaea">maximize_min_angle</a> (<a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, float thresh, bool anneal=false)</td></tr>
<tr class="memdesc:a67d36f9cd3abcc6311f748454741eaea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximizes the minimum angle of triangles. Makes the mesh more Delaunay.  <a href="namespaceHMesh.html#a67d36f9cd3abcc6311f748454741eaea">More...</a><br /></td></tr>
<tr class="separator:a67d36f9cd3abcc6311f748454741eaea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ed37225f8a3cf466de5c35e6313968"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#af9ed37225f8a3cf466de5c35e6313968">optimize_valency</a> (<a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, bool anneal=false)</td></tr>
<tr class="memdesc:af9ed37225f8a3cf466de5c35e6313968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to achieve valence 6 internally and 4 along edges.  <a href="namespaceHMesh.html#af9ed37225f8a3cf466de5c35e6313968">More...</a><br /></td></tr>
<tr class="separator:af9ed37225f8a3cf466de5c35e6313968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceac9698ce31ea5131b8d4d8be510c08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#aceac9698ce31ea5131b8d4d8be510c08">randomize_mesh</a> (<a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, int max_iter)</td></tr>
<tr class="memdesc:aceac9698ce31ea5131b8d4d8be510c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make radom flips. Useful for generating synthetic test cases.  <a href="namespaceHMesh.html#aceac9698ce31ea5131b8d4d8be510c08">More...</a><br /></td></tr>
<tr class="separator:aceac9698ce31ea5131b8d4d8be510c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe2480b8f35f997450b51cad02d42b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a0fe2480b8f35f997450b51cad02d42b8">edge_equalize</a> (<a class="el" href="classHMesh_1_1Manifold.html">HMesh::Manifold</a> &amp;m, const <a class="el" href="classGeometry_1_1Implicit.html">Geometry::Implicit</a> &amp;imp, float tau, int max_iter)</td></tr>
<tr class="memdesc:a0fe2480b8f35f997450b51cad02d42b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform many operations in order to equalize edge lengths.  <a href="namespaceHMesh.html#a0fe2480b8f35f997450b51cad02d42b8">More...</a><br /></td></tr>
<tr class="separator:a0fe2480b8f35f997450b51cad02d42b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2af29a6e5c5043ca1d07485a8dd876"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a3c2af29a6e5c5043ca1d07485a8dd876">obj_load</a> (const std::string &amp;, <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, <a class="el" href="classHMesh_1_1VertexAttributeVector.html">VertexAttributeVector</a>&lt; int &gt; &amp;orig_vertex_indices)</td></tr>
<tr class="memdesc:a3c2af29a6e5c5043ca1d07485a8dd876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a Wavefront OBJ file.  <a href="namespaceHMesh.html#a3c2af29a6e5c5043ca1d07485a8dd876">More...</a><br /></td></tr>
<tr class="separator:a3c2af29a6e5c5043ca1d07485a8dd876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243bc172dd22d92e53f54719b011e839"><td class="memItemLeft" align="right" valign="top"><a id="a243bc172dd22d92e53f54719b011e839"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>obj_load</b> (const std::string &amp;, <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m)</td></tr>
<tr class="separator:a243bc172dd22d92e53f54719b011e839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab980f699995b83c76341d48407c3c26a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#ab980f699995b83c76341d48407c3c26a">obj_save</a> (const std::string &amp;, <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m)</td></tr>
<tr class="memdesc:ab980f699995b83c76341d48407c3c26a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save in Wavefront OBJ format.  <a href="namespaceHMesh.html#ab980f699995b83c76341d48407c3c26a">More...</a><br /></td></tr>
<tr class="separator:ab980f699995b83c76341d48407c3c26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a000e0bfd2eaf8a33ee8dee378e872"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a68a000e0bfd2eaf8a33ee8dee378e872">off_load</a> (const std::string &amp;, <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m)</td></tr>
<tr class="memdesc:a68a000e0bfd2eaf8a33ee8dee378e872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load an OFF file (Object File Format). So far, this loader is mostly ensured to load files from the Princeton Shape Benchmark.  <a href="namespaceHMesh.html#a68a000e0bfd2eaf8a33ee8dee378e872">More...</a><br /></td></tr>
<tr class="separator:a68a000e0bfd2eaf8a33ee8dee378e872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4cafb10ae2c47e1c29452b9d438a22c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#ae4cafb10ae2c47e1c29452b9d438a22c">off_save</a> (const std::string &amp;, <a class="el" href="classHMesh_1_1Manifold.html">HMesh::Manifold</a> &amp;m)</td></tr>
<tr class="memdesc:ae4cafb10ae2c47e1c29452b9d438a22c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save in OFF format.  <a href="namespaceHMesh.html#ae4cafb10ae2c47e1c29452b9d438a22c">More...</a><br /></td></tr>
<tr class="separator:ae4cafb10ae2c47e1c29452b9d438a22c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa462861e0fd27ec885865115dbe89ea4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#aa462861e0fd27ec885865115dbe89ea4">ply_load</a> (const std::string &amp;, <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m)</td></tr>
<tr class="memdesc:aa462861e0fd27ec885865115dbe89ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load an Wavefront OBJ file.  <a href="namespaceHMesh.html#aa462861e0fd27ec885865115dbe89ea4">More...</a><br /></td></tr>
<tr class="separator:aa462861e0fd27ec885865115dbe89ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d840744a37a7b0dfb45477157335b57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a4d840744a37a7b0dfb45477157335b57">volume_polygonize</a> (const <a class="el" href="classGeometry_1_1XForm.html">Geometry::XForm</a> &amp;xform, const <a class="el" href="classGeometry_1_1RGrid.html">Geometry::RGrid</a>&lt; float &gt; &amp;grid, <a class="el" href="classHMesh_1_1Manifold.html">HMesh::Manifold</a> &amp;mani, float tau, bool make_triangles=true, bool high_is_inside=true)</td></tr>
<tr class="memdesc:a4d840744a37a7b0dfb45477157335b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a polygonal mesh from a volumetric isocontour.  <a href="namespaceHMesh.html#a4d840744a37a7b0dfb45477157335b57">More...</a><br /></td></tr>
<tr class="separator:a4d840744a37a7b0dfb45477157335b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c29047193f74df4686ec75fbb0a766d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a2c29047193f74df4686ec75fbb0a766d">quadric_simplify</a> (<a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, double keep_fraction, double singular_thresh=0.0001, bool choose_optimal_positions=true)</td></tr>
<tr class="memdesc:a2c29047193f74df4686ec75fbb0a766d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garland Heckbert simplification in our own implementation.  <a href="namespaceHMesh.html#a2c29047193f74df4686ec75fbb0a766d">More...</a><br /></td></tr>
<tr class="separator:a2c29047193f74df4686ec75fbb0a766d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b625f28ee418b0e34aa6b2241cc645"><td class="memItemLeft" align="right" valign="top"><a id="a93b625f28ee418b0e34aa6b2241cc645"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>quadric_simplify</b> (<a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, <a class="el" href="classHMesh_1_1VertexAttributeVector.html">VertexAttributeVector</a>&lt; int &gt; mask, double keep_fraction, double singular_thresh=0.0001, bool choose_optimal_positions=true)</td></tr>
<tr class="separator:a93b625f28ee418b0e34aa6b2241cc645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da8f37e6a9a98df42b483223cdcbcd4"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a8da8f37e6a9a98df42b483223cdcbcd4">average_edge_length</a> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m)</td></tr>
<tr class="memdesc:a8da8f37e6a9a98df42b483223cdcbcd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the average edge length.  <a href="namespaceHMesh.html#a8da8f37e6a9a98df42b483223cdcbcd4">More...</a><br /></td></tr>
<tr class="separator:a8da8f37e6a9a98df42b483223cdcbcd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad749c5bc88e524e918f73c2293001b27"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#ad749c5bc88e524e918f73c2293001b27">median_edge_length</a> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m)</td></tr>
<tr class="memdesc:ad749c5bc88e524e918f73c2293001b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the median edge length. A bit more involved to compute, more robust.  <a href="namespaceHMesh.html#ad749c5bc88e524e918f73c2293001b27">More...</a><br /></td></tr>
<tr class="separator:ad749c5bc88e524e918f73c2293001b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01ef3183c8ae4cf46a42cf123b85322"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#ac01ef3183c8ae4cf46a42cf123b85322">refine_edges</a> (<a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, float t)</td></tr>
<tr class="memdesc:ac01ef3183c8ae4cf46a42cf123b85322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split all edges in mesh passed as first argument which are longer than the threshold (second arg) length.  <a href="namespaceHMesh.html#ac01ef3183c8ae4cf46a42cf123b85322">More...</a><br /></td></tr>
<tr class="separator:ac01ef3183c8ae4cf46a42cf123b85322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8577f8d96f3ba5aaed262ecb6f388d"><td class="memItemLeft" align="right" valign="top"><a id="a7e8577f8d96f3ba5aaed262ecb6f388d"></a>
<a class="el" href="classCGLA_1_1Vec3d.html">CGLA::Vec3d</a>&#160;</td><td class="memItemRight" valign="bottom"><b>laplacian</b> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, VertexID v)</td></tr>
<tr class="separator:a7e8577f8d96f3ba5aaed262ecb6f388d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacae72fad6034a34d1c2568c12f29192"><td class="memItemLeft" align="right" valign="top"><a id="aacae72fad6034a34d1c2568c12f29192"></a>
<a class="el" href="classCGLA_1_1Vec3d.html">CGLA::Vec3d</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cot_laplacian</b> (const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, VertexID v)</td></tr>
<tr class="separator:aacae72fad6034a34d1c2568c12f29192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220f29fedadbf0c57c344cda99e57d15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a220f29fedadbf0c57c344cda99e57d15">laplacian_smooth</a> (<a class="el" href="classHMesh_1_1Manifold.html">HMesh::Manifold</a> &amp;m, float t=1.0f, int iter=1)</td></tr>
<tr class="memdesc:a220f29fedadbf0c57c344cda99e57d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple laplacian smoothing with an optional weight.  <a href="namespaceHMesh.html#a220f29fedadbf0c57c344cda99e57d15">More...</a><br /></td></tr>
<tr class="separator:a220f29fedadbf0c57c344cda99e57d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b22ab24a539fcdc8cd61d0eb4f735d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a31b22ab24a539fcdc8cd61d0eb4f735d">taubin_smooth</a> (<a class="el" href="classHMesh_1_1Manifold.html">HMesh::Manifold</a> &amp;m, int iter=1)</td></tr>
<tr class="memdesc:a31b22ab24a539fcdc8cd61d0eb4f735d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Taubin smoothing is similar to laplacian smoothing but reduces shrinkage.  <a href="namespaceHMesh.html#a31b22ab24a539fcdc8cd61d0eb4f735d">More...</a><br /></td></tr>
<tr class="separator:a31b22ab24a539fcdc8cd61d0eb4f735d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79af7854e5c3bf20b8dd0c0bc62408d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a79af7854e5c3bf20b8dd0c0bc62408d1">anisotropic_smooth</a> (<a class="el" href="classHMesh_1_1Manifold.html">HMesh::Manifold</a> &amp;m, int iter, NormalSmoothMethod nsm)</td></tr>
<tr class="memdesc:a79af7854e5c3bf20b8dd0c0bc62408d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smooth meshes by first filtering normals and then refitting the mesh.  <a href="namespaceHMesh.html#a79af7854e5c3bf20b8dd0c0bc62408d1">More...</a><br /></td></tr>
<tr class="separator:a79af7854e5c3bf20b8dd0c0bc62408d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb5257522f4ce7b8b73ad9a6886d7f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a6eb5257522f4ce7b8b73ad9a6886d7f6">TAL_smoothing</a> (<a class="el" href="classHMesh_1_1Manifold.html">HMesh::Manifold</a> &amp;m, float w, int iter=1)</td></tr>
<tr class="memdesc:a6eb5257522f4ce7b8b73ad9a6886d7f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tangential area weighted smoothing.  <a href="namespaceHMesh.html#a6eb5257522f4ce7b8b73ad9a6886d7f6">More...</a><br /></td></tr>
<tr class="separator:a6eb5257522f4ce7b8b73ad9a6886d7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ebf1a4e57530d7e62c476998b2fdbd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a1ebf1a4e57530d7e62c476998b2fdbd3">cc_split</a> (<a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;, <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;)</td></tr>
<tr class="memdesc:a1ebf1a4e57530d7e62c476998b2fdbd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a Catmull-Clark split, i.e.  <a href="namespaceHMesh.html#a1ebf1a4e57530d7e62c476998b2fdbd3">More...</a><br /></td></tr>
<tr class="separator:a1ebf1a4e57530d7e62c476998b2fdbd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4360b8eea4f38d459d94cadd94766a"><td class="memItemLeft" align="right" valign="top"><a id="a8d4360b8eea4f38d459d94cadd94766a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loop_split</b> (<a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m_in, <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m)</td></tr>
<tr class="separator:a8d4360b8eea4f38d459d94cadd94766a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5acd8c129be667b4998993afceb95677"><td class="memItemLeft" align="right" valign="top"><a id="a5acd8c129be667b4998993afceb95677"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>root3_subdivide</b> (<a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;, <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;)</td></tr>
<tr class="separator:a5acd8c129be667b4998993afceb95677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82cacd16d07d6992afc3d3c68cce065b"><td class="memItemLeft" align="right" valign="top"><a id="a82cacd16d07d6992afc3d3c68cce065b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>rootCC_subdivide</b> (<a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m_in, <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m)</td></tr>
<tr class="separator:a82cacd16d07d6992afc3d3c68cce065b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7748dd206bd11dbc02bd227a5c7eea46"><td class="memItemLeft" align="right" valign="top"><a id="a7748dd206bd11dbc02bd227a5c7eea46"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>butterfly_subdivide</b> (<a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m_in, <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m)</td></tr>
<tr class="separator:a7748dd206bd11dbc02bd227a5c7eea46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b1d7889212859515b391f485c4b942"><td class="memItemLeft" align="right" valign="top"><a id="a63b1d7889212859515b391f485c4b942"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cc_smooth</b> (<a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;)</td></tr>
<tr class="separator:a63b1d7889212859515b391f485c4b942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9f12ea7510ee5689725b14243cafe7"><td class="memItemLeft" align="right" valign="top"><a id="aba9f12ea7510ee5689725b14243cafe7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loop_smooth</b> (<a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;)</td></tr>
<tr class="separator:aba9f12ea7510ee5689725b14243cafe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431da0c0266faa5d82323297fd9201d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a431da0c0266faa5d82323297fd9201d7">triangulate</a> (<a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, FaceID f, TriangulationMethod policy=CLIP_EAR)</td></tr>
<tr class="memdesc:a431da0c0266faa5d82323297fd9201d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangulate by connected vertices on the face f.  <a href="namespaceHMesh.html#a431da0c0266faa5d82323297fd9201d7">More...</a><br /></td></tr>
<tr class="separator:a431da0c0266faa5d82323297fd9201d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1e6d131ef5eff0745216277035bb46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#afa1e6d131ef5eff0745216277035bb46">triangulate</a> (<a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m, TriangulationMethod policy=CLIP_EAR)</td></tr>
<tr class="memdesc:afa1e6d131ef5eff0745216277035bb46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangulate by connectin.  <a href="namespaceHMesh.html#afa1e6d131ef5eff0745216277035bb46">More...</a><br /></td></tr>
<tr class="separator:afa1e6d131ef5eff0745216277035bb46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec98b3dedef5824df105fd919035f93c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#aec98b3dedef5824df105fd919035f93c">x3d_load</a> (const std::string &amp;filename, <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m)</td></tr>
<tr class="memdesc:aec98b3dedef5824df105fd919035f93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a mesh from an X3D file. It handles arbitrary polygons.  <a href="namespaceHMesh.html#aec98b3dedef5824df105fd919035f93c">More...</a><br /></td></tr>
<tr class="separator:aec98b3dedef5824df105fd919035f93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cfd1ab9ac0990110d68417b33984557"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceHMesh.html#a5cfd1ab9ac0990110d68417b33984557">x3d_save</a> (const std::string &amp;, <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;m)</td></tr>
<tr class="memdesc:a5cfd1ab9ac0990110d68417b33984557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save mesh to x3d file.  <a href="namespaceHMesh.html#a5cfd1ab9ac0990110d68417b33984557">More...</a><br /></td></tr>
<tr class="separator:a5cfd1ab9ac0990110d68417b33984557"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="namespaceHMesh.html" title="The HMesh namespace contains the Manifold class which is a halfedge based mesh.">HMesh</a> namespace contains the <a class="el" href="classHMesh_1_1Manifold.html" title="The Manifold class represents a halfedge based mesh.">Manifold</a> class which is a halfedge based mesh. </p>
<p>Apart from manifold there are also face and vertex circulators in this namespace. More advanced things are relegated to the HMeshUtil namespace.</p>
<p>Some applications are also found here. For instance an isosurface polygonizer and Garland Heckbert simplification has been implemented on top of <a class="el" href="namespaceHMesh.html" title="The HMesh namespace contains the Manifold class which is a halfedge based mesh.">HMesh</a>. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a85a57d545ddd8234734991a3e6fb993f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a57d545ddd8234734991a3e6fb993f">&#9670;&nbsp;</a></span>FaceSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceHMesh.html#a85a57d545ddd8234734991a3e6fb993f">HMesh::FaceSet</a> = typedef <a class="el" href="classHMesh_1_1IDSet.html">IDSet</a>&lt;<a class="el" href="structHMesh_1_1Face.html">Face</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set of faces. </p>

</div>
</div>
<a id="ab5c5194c50ed11d7f2d4c8cfa1e3cffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5c5194c50ed11d7f2d4c8cfa1e3cffa">&#9670;&nbsp;</a></span>HalfEdgeSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceHMesh.html#ab5c5194c50ed11d7f2d4c8cfa1e3cffa">HMesh::HalfEdgeSet</a> = typedef <a class="el" href="classHMesh_1_1IDSet.html">IDSet</a>&lt;<a class="el" href="structHMesh_1_1HalfEdge.html">HalfEdge</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set of halfedges. </p>

</div>
</div>
<a id="a3359aad6cb722629b1d9b6fe493ede41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3359aad6cb722629b1d9b6fe493ede41">&#9670;&nbsp;</a></span>VertexSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceHMesh.html#a3359aad6cb722629b1d9b6fe493ede41">HMesh::VertexSet</a> = typedef <a class="el" href="classHMesh_1_1IDSet.html">IDSet</a>&lt;<a class="el" href="structHMesh_1_1Vertex.html">Vertex</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set of vertices. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a79af7854e5c3bf20b8dd0c0bc62408d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79af7854e5c3bf20b8dd0c0bc62408d1">&#9670;&nbsp;</a></span>anisotropic_smooth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HMesh::anisotropic_smooth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">HMesh::Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NormalSmoothMethod&#160;</td>
          <td class="paramname"><em>nsm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smooth meshes by first filtering normals and then refitting the mesh. </p>

</div>
</div>
<a id="ae6a2f50aae9135987654459831df3973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a2f50aae9135987654459831df3973">&#9670;&nbsp;</a></span>area()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double HMesh::area </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FaceID&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the area of a face. </p>

</div>
</div>
<a id="ad4a17a05760b3b6f15d0c256741d7ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a17a05760b3b6f15d0c256741d7ec9">&#9670;&nbsp;</a></span>area_normal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMesh_1_1Manifold.html#addeb1166a6148a372b91787509604d6c">Manifold::Vec</a> HMesh::area_normal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FaceID&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the vertex normal but multiplied by the area of the face. This is more efficient if both area and normal are needed. </p>

</div>
</div>
<a id="a8da8f37e6a9a98df42b483223cdcbcd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da8f37e6a9a98df42b483223cdcbcd4">&#9670;&nbsp;</a></span>average_edge_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float HMesh::average_edge_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the average edge length. </p>

</div>
</div>
<a id="a61bafc672b23ef1df0cb667c237bca23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61bafc672b23ef1df0cb667c237bca23">&#9670;&nbsp;</a></span>barycenter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMesh_1_1Manifold.html#addeb1166a6148a372b91787509604d6c">Manifold::Vec</a> HMesh::barycenter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FaceID&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the barycenter of a face (with American spelling). </p>
<p>Compute the barycenter of an halfedge (with American spelling). </p>

</div>
</div>
<a id="adc9111e728908fdc3eefbc82c38340a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc9111e728908fdc3eefbc82c38340a3">&#9670;&nbsp;</a></span>bbox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HMesh::bbox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html#addeb1166a6148a372b91787509604d6c">Manifold::Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>pmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html#addeb1166a6148a372b91787509604d6c">Manifold::Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>pmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the bounding box of the manifold. </p>

</div>
</div>
<a id="ac931a6ffdbf14f33192fb54e74528276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac931a6ffdbf14f33192fb54e74528276">&#9670;&nbsp;</a></span>boundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HMesh::boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HalfEdgeID&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the halfedge is a boundary halfedge. </p>
<p>Returns true if the vertex is a boundary vertex. </p>

</div>
</div>
<a id="a3548c0b7d14893caa570c48047fe6b35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3548c0b7d14893caa570c48047fe6b35">&#9670;&nbsp;</a></span>boundary_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HalfEdgeID HMesh::boundary_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexID&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the id of the boundary edge or InvalidHalfEdgeID if the vertex is not on the boundary. </p>

</div>
</div>
<a id="ab818ab0617e0e443b3a8dc0531f9aa6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab818ab0617e0e443b3a8dc0531f9aa6e">&#9670;&nbsp;</a></span>bsphere()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HMesh::bsphere </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html#addeb1166a6148a372b91787509604d6c">Manifold::Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the bounding sphere of the manifold. </p>

</div>
</div>
<a id="acb4bc15ec0b7db2cb17a87a26c8d7e3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb4bc15ec0b7db2cb17a87a26c8d7e3c">&#9670;&nbsp;</a></span>build() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMesh_1_1VertexAttributeVector.html">VertexAttributeVector</a>&lt;int&gt; HMesh::build </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1TriMesh.html">Geometry::TriMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a manifold from a TriMesh. </p>

</div>
</div>
<a id="a9baa789f078529210812e418afc2cf25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9baa789f078529210812e418afc2cf25">&#9670;&nbsp;</a></span>build() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMesh_1_1VertexAttributeVector.html">VertexAttributeVector</a>&lt;int&gt; HMesh::build </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>no_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>vertvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>no_faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>facevec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a manifold. </p>
<p>The arguments are the number of vertices (no_vertices), the vector of vertices (vertvec), the number of faces (no_faces), a pointer to an array of double values (vert_vec) and an array of indices (indices). The build function returns an attribute vector containing a mapping from vertex ids to the original point indices.</p>
<p>Note that each vertex is three double precision floating point numbers. The indices vector is one long list of all vertex indices. Note also that this function assumes that the mesh is manifold. Failing that the results are undefined but usually a crash due to a failed assertion. </p>

</div>
</div>
<a id="ac133c861b65b755aa1112ffe6ad0a6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac133c861b65b755aa1112ffe6ad0a6c9">&#9670;&nbsp;</a></span>build() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMesh_1_1VertexAttributeVector.html">VertexAttributeVector</a>&lt;int&gt; HMesh::build </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>no_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>vertvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>no_faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>facevec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a manifold. </p>
<p>The arguments are the number of vertices (no_vertices), the vector of vertices (vertvec), the number of faces (no_faces), a pointer to an array of float values (vert_vec) and an array of indices (indices). The build function returns an attribute vector containing a mapping from vertex ids to the original point indices. Note that each vertex is three floating point numbers. The indices vector is one long list of all vertex indices. Note also that this function call assumes that the mesh is manifold. Failing that the results are undefined but usually a crash due to a failed assertion. Finally, we should consider the option to build a manifold with single precision floating point values deprecated. Hence, safe_build exists only as double precision. </p>

</div>
</div>
<a id="a1ebf1a4e57530d7e62c476998b2fdbd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ebf1a4e57530d7e62c476998b2fdbd3">&#9670;&nbsp;</a></span>cc_split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HMesh::cc_split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a Catmull-Clark split, i.e. </p>
<p>a split where each face is divided into new quadrilateral faces formed by connecting a corner with a point on each incident edge and a point at the centre of the face. </p>

</div>
</div>
<a id="a08e31843ef282d5958427d54b39da7ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08e31843ef282d5958427d54b39da7ac">&#9670;&nbsp;</a></span>centre()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMesh_1_1Manifold.html#addeb1166a6148a372b91787509604d6c">Manifold::Vec</a> HMesh::centre </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FaceID&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the centre of a face. </p>

</div>
</div>
<a id="a8772d2bebaff87460236b2ac9614c734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8772d2bebaff87460236b2ac9614c734">&#9670;&nbsp;</a></span>close_holes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HMesh::close_holes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_size</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function replaces holes by faces. </p>
<p>It is really a simple function that just finds all loops of edges next to missing faces. You can specify, max_size, the maximum hole size to close. </p>

</div>
</div>
<a id="a76f87ef03b98c2b265a924b97eeed20b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f87ef03b98c2b265a924b97eeed20b">&#9670;&nbsp;</a></span>closed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HMesh::closed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the mesh is closed, i.e. has no boundary. </p>

</div>
</div>
<a id="acd1e4f1de66565a8c774f5ebe7dd02ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd1e4f1de66565a8c774f5ebe7dd02ff">&#9670;&nbsp;</a></span>connected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HMesh::connected </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexID&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexID&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the two argument vertices are in each other's one-rings. </p>

</div>
</div>
<a id="a0fe2480b8f35f997450b51cad02d42b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe2480b8f35f997450b51cad02d42b8">&#9670;&nbsp;</a></span>edge_equalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HMesh::edge_equalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">HMesh::Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1Implicit.html">Geometry::Implicit</a> &amp;&#160;</td>
          <td class="paramname"><em>imp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform many operations in order to equalize edge lengths. </p>

</div>
</div>
<a id="a9ad2e94f52a1763876e80cc60e6a7c31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ad2e94f52a1763876e80cc60e6a7c31">&#9670;&nbsp;</a></span>find_invalid_entities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HMesh::find_invalid_entities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceHMesh.html#a3359aad6cb722629b1d9b6fe493ede41">VertexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>vs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceHMesh.html#ab5c5194c50ed11d7f2d4c8cfa1e3cffa">HalfEdgeSet</a> &amp;&#160;</td>
          <td class="paramname"><em>hs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceHMesh.html#a85a57d545ddd8234734991a3e6fb993f">FaceSet</a> &amp;&#160;</td>
          <td class="paramname"><em>fs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify <a class="el" href="classHMesh_1_1Manifold.html" title="The Manifold class represents a halfedge based mesh.">Manifold</a> Integrity Performs a series of tests to check that this is a valid manifold. </p>
<p>This function is not rigorously constructed but seems to catch all problems so far. The function returns true if the mesh is valid and false otherwise. </p>

</div>
</div>
<a id="ac53eabfab6b40b034457bc67f04afa73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac53eabfab6b40b034457bc67f04afa73">&#9670;&nbsp;</a></span>flip_orientation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HMesh::flip_orientation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flip the orientation of a mesh. </p>
<p>After calling this function, normals will point the other way and clockwise becomes counter clockwise </p>

</div>
</div>
<a id="a220f29fedadbf0c57c344cda99e57d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220f29fedadbf0c57c344cda99e57d15">&#9670;&nbsp;</a></span>laplacian_smooth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HMesh::laplacian_smooth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">HMesh::Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>t</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iter</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple laplacian smoothing with an optional weight. </p>

</div>
</div>
<a id="a298f09a535601bf723ba125b1d20bd4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a298f09a535601bf723ba125b1d20bd4b">&#9670;&nbsp;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double HMesh::length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HalfEdgeID&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the geometric length of a halfedge. </p>

</div>
</div>
<a id="a394c133900cd07b8752b0b9679212d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394c133900cd07b8752b0b9679212d7c">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HMesh::load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a geometry file. This could be a PLY, OBJ, X3D, or OFF file. </p>

</div>
</div>
<a id="a67d36f9cd3abcc6311f748454741eaea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67d36f9cd3abcc6311f748454741eaea">&#9670;&nbsp;</a></span>maximize_min_angle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HMesh::maximize_min_angle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>thresh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>anneal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximizes the minimum angle of triangles. Makes the mesh more Delaunay. </p>

</div>
</div>
<a id="ad749c5bc88e524e918f73c2293001b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad749c5bc88e524e918f73c2293001b27">&#9670;&nbsp;</a></span>median_edge_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float HMesh::median_edge_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the median edge length. A bit more involved to compute, more robust. </p>

</div>
</div>
<a id="a8fff1b56c3c6d1c356df1c53b279559b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fff1b56c3c6d1c356df1c53b279559b">&#9670;&nbsp;</a></span>merge_coincident_boundary_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HMesh::merge_coincident_boundary_vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rad</em> = <code>1e-30</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function merges pairs of boundary vertices, provided there are exactly two such vertices at a given point in space, that they are not in each others' one ring and that the one rings are disjoint. </p>

</div>
</div>
<a id="abf03d6162622513b7c54d82ae9815164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf03d6162622513b7c54d82ae9815164">&#9670;&nbsp;</a></span>minimize_curvature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HMesh::minimize_curvature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>anneal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimizes mean curvature. This is really the same as dihedral angle optimization except that we weight by edge length. </p>

</div>
</div>
<a id="a1761800ef0c39208e49371fda3f09c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1761800ef0c39208e49371fda3f09c12">&#9670;&nbsp;</a></span>minimize_dihedral_angle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HMesh::minimize_dihedral_angle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code>10000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>anneal</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gamma</em> = <code>4.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimize the angle between adjacent triangles. Almost the same as mean curvature minimization. </p>

</div>
</div>
<a id="a1e2e836221aa25f553aad1e39f455a6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e2e836221aa25f553aad1e39f455a6c">&#9670;&nbsp;</a></span>minimize_gauss_curvature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HMesh::minimize_gauss_curvature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>anneal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimizes gaussian curvature. Probably less useful than mean curvature. </p>

</div>
</div>
<a id="adfb4dc06bbcaf9497cec7c1d13e426fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb4dc06bbcaf9497cec7c1d13e426fe">&#9670;&nbsp;</a></span>no_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int HMesh::no_edges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FaceID&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the number of edges of a face. </p>

</div>
</div>
<a id="afa272182ccadcc426cb09bf70c839b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa272182ccadcc426cb09bf70c839b44">&#9670;&nbsp;</a></span>normal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHMesh_1_1Manifold.html#addeb1166a6148a372b91787509604d6c">Manifold::Vec</a> HMesh::normal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FaceID&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the vertex normal. This function computes the angle weighted sum of incident face normals. </p>
<p>Compute the normal of a face.</p>
<p>If the face is not a triangle, the normal is not defined, but computed using the first three vertices of the face. </p>

</div>
</div>
<a id="a3c2af29a6e5c5043ca1d07485a8dd876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2af29a6e5c5043ca1d07485a8dd876">&#9670;&nbsp;</a></span>obj_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HMesh::obj_load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1VertexAttributeVector.html">VertexAttributeVector</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>orig_vertex_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a Wavefront OBJ file. </p>
<p>The first argument is a string containing the file name (including path) and the second is the <a class="el" href="classHMesh_1_1Manifold.html" title="The Manifold class represents a halfedge based mesh.">Manifold</a> into which the mesh is loaded. The third argument is an attribute vector containing the indices of the original points. <br  />
 </p>

</div>
</div>
<a id="ab980f699995b83c76341d48407c3c26a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab980f699995b83c76341d48407c3c26a">&#9670;&nbsp;</a></span>obj_save()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HMesh::obj_save </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save in Wavefront OBJ format. </p>

</div>
</div>
<a id="a68a000e0bfd2eaf8a33ee8dee378e872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a000e0bfd2eaf8a33ee8dee378e872">&#9670;&nbsp;</a></span>off_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HMesh::off_load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load an OFF file (Object File Format). So far, this loader is mostly ensured to load files from the Princeton Shape Benchmark. </p>

</div>
</div>
<a id="ae4cafb10ae2c47e1c29452b9d438a22c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4cafb10ae2c47e1c29452b9d438a22c">&#9670;&nbsp;</a></span>off_save()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HMesh::off_save </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">HMesh::Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save in OFF format. </p>

</div>
</div>
<a id="af9ed37225f8a3cf466de5c35e6313968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ed37225f8a3cf466de5c35e6313968">&#9670;&nbsp;</a></span>optimize_valency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HMesh::optimize_valency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>anneal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to achieve valence 6 internally and 4 along edges. </p>

</div>
</div>
<a id="ac551c6ac0965c6a150ac701259ac59f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac551c6ac0965c6a150ac701259ac59f6">&#9670;&nbsp;</a></span>perimeter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double HMesh::perimeter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FaceID&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the perimeter of a face. </p>

</div>
</div>
<a id="aa462861e0fd27ec885865115dbe89ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa462861e0fd27ec885865115dbe89ea4">&#9670;&nbsp;</a></span>ply_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HMesh::ply_load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load an Wavefront OBJ file. </p>
<p>This is just a simple frontend for the <a class="el" href="namespaceGeometry.html#afe7dbb06fa2180494bac941c1937e400" title="Load a TriMesh from an OBJ file.">Geometry::obj_load</a> function which loads OBJ files into triangle meshes. Consequently, quads are unfortunately converted to triangles when this loader is used. </p>

</div>
</div>
<a id="a91e1ef60db88302f038e7d54af100bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e1ef60db88302f038e7d54af100bbd">&#9670;&nbsp;</a></span>precond_collapse_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HMesh::precond_collapse_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HalfEdgeID&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test for legal edge collapse. </p>
<p>The argument h is the halfedge we want to collapse. If this function does not return true, it is illegal to collapse h. The reason is that the collapse would violate the manifold property of the mesh. The test is as follows:</p><ol type="1">
<li>For the two vertices adjacent to the edge, we generate a list of all their neighbouring vertices. We then generate a list of the vertices that occur in both these lists. That is, we find all vertices connected by edges to both endpoints of the edge and store these in a list.</li>
<li>For both faces incident on the edge, check whether they are triangular. If this is the case, the face will be removed, and it is ok that the the third vertex is connected to both endpoints. Thus the third vertex in such a face is removed from the list generated in 1.</li>
<li>If the list is now empty, all is well. Otherwise, there would be a vertex in the new mesh with two edges connecting it to the same vertex. Return false.</li>
<li>TETRAHEDRON TEST: If the valency of both vertices is three, and the incident faces are triangles, we also disallow the operation. Reason: A vertex valency of two and two triangles incident on the adjacent vertices makes the construction collapse.</li>
<li>VALENCY 4 TEST: If a triangle is adjacent to the edge being collapsed, it disappears. This means the valency of the remaining edge vertex is decreased by one. A valency two vertex reduced to a valency one vertex is considered illegal.</li>
<li>PREVENT MERGING HOLES: Collapsing an edge with boundary endpoints and valid faces results in the creation where two holes meet. A non manifold situation. We could relax this...<ol type="a">
<li>New test: if the same face is in the one-ring of both vertices but not adjacent to the common edge, then the result of a collapse would be a one ring where the same face occurs twice. This is disallowed as the resulting face would be non-simple. <br  />
 </li>
</ol>
</li>
</ol>

</div>
</div>
<a id="ae0e4972e4b2cf3fba427e7ef13d607c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0e4972e4b2cf3fba427e7ef13d607c7">&#9670;&nbsp;</a></span>precond_flip_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HMesh::precond_flip_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HalfEdgeID&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test fpr legal edge flip. </p>
<p>Returns false if flipping cannot be performed. This is due to one of following:</p><ol type="1">
<li>one of the two adjacent faces is not a triangle.</li>
<li>Either end point has valency three.</li>
<li>The vertices that will be connected already are. </li>
</ol>

</div>
</div>
<a id="a7b14bcf8bdef656cf6ced38a3f2b1437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b14bcf8bdef656cf6ced38a3f2b1437">&#9670;&nbsp;</a></span>priority_queue_optimization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HMesh::priority_queue_optimization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMesh_1_1EnergyFun.html">EnergyFun</a> &amp;&#160;</td>
          <td class="paramname"><em>efun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimize in a greedy fashion. </p>

</div>
</div>
<a id="a2c29047193f74df4686ec75fbb0a766d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c29047193f74df4686ec75fbb0a766d">&#9670;&nbsp;</a></span>quadric_simplify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HMesh::quadric_simplify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>keep_fraction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>singular_thresh</em> = <code>0.0001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>choose_optimal_positions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Garland Heckbert simplification in our own implementation. </p>
<p>keep_fraction is the fraction of vertices to retain. The singular_thresh defines how small singular values from the SVD we accept. It is relative to the greatest singular value. If choose_optimal_positions is true, we reposition vertices. Otherwise the vertices are a subset of the old vertices. </p>

</div>
</div>
<a id="aceac9698ce31ea5131b8d4d8be510c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceac9698ce31ea5131b8d4d8be510c08">&#9670;&nbsp;</a></span>randomize_mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HMesh::randomize_mesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make radom flips. Useful for generating synthetic test cases. </p>

</div>
</div>
<a id="ac01ef3183c8ae4cf46a42cf123b85322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac01ef3183c8ae4cf46a42cf123b85322">&#9670;&nbsp;</a></span>refine_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int HMesh::refine_edges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split all edges in mesh passed as first argument which are longer than the threshold (second arg) length. </p>
<p>A split edge results in a new vertex of valence two. </p>

</div>
</div>
<a id="a6bfeb37978ea98fba3478ba00744e827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bfeb37978ea98fba3478ba00744e827">&#9670;&nbsp;</a></span>remove_caps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HMesh::remove_caps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>thresh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove caps from a manifold consisting of only triangles. </p>
<p>A cap is a triangle with two very small angles and an angle close to pi, however a cap does not necessarily have a very short edge. Set the ang_thresh to a value close to pi. The closer to pi the <em>less</em> sensitive the cap removal. A cap is removed by flipping the (long) edge E opposite to the vertex V with the angle close to pi. However, the function is more complex. Read code and document more carefully !!! </p>

</div>
</div>
<a id="a52b032514e541e901cf6c2ed169d4cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b032514e541e901cf6c2ed169d4cf6">&#9670;&nbsp;</a></span>remove_needles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HMesh::remove_needles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>thresh</em> = <code>0.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>averagePositions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove needles from a manifold consisting of only triangles. </p>
<p>A needle is a triangle with a single very short edge. It is moved by collapsing the short edge. The thresh parameter sets the length threshold as a fraction of the average edge length. <br  />
 </p>

</div>
</div>
<a id="a4e7830724b70d835f9ad975a370073c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e7830724b70d835f9ad975a370073c8">&#9670;&nbsp;</a></span>remove_valence_two_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HMesh::remove_valence_two_vertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove valence two vertices. </p>

</div>
</div>
<a id="a15a7860d676cc92c8649d4587d9fe35d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a7860d676cc92c8649d4587d9fe35d">&#9670;&nbsp;</a></span>simulated_annealing_optimization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HMesh::simulated_annealing_optimization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHMesh_1_1EnergyFun.html">EnergyFun</a> &amp;&#160;</td>
          <td class="paramname"><em>efun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code>10000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimize with simulated annealing. Avoids getting trapped in local minima. </p>

</div>
</div>
<a id="a402ba7f70f9eeedc1ff8207d604e0cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a402ba7f70f9eeedc1ff8207d604e0cd5">&#9670;&nbsp;</a></span>stitch_mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int HMesh::stitch_mesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stitch together edges whose endpoints coincide geometrically. </p>
<p>This function allows you to create a mesh as a bunch of faces and then stitch these together to form a coherent whole. What this function adds is a spatial data structure to find out which vertices coincide. The return value is the number of edges that could not be stitched. Often this is because it would introduce a non-manifold situation. </p>

</div>
</div>
<a id="a00005c75c1b6d0307eb34b705bc01731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00005c75c1b6d0307eb34b705bc01731">&#9670;&nbsp;</a></span>stitch_more()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HMesh::stitch_more </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stitches the mesh together, splits edges that could not be stitched and goes again. </p>
<p>This function thereby handles situations where stitch mesh would not have worked. </p>

</div>
</div>
<a id="a6eb5257522f4ce7b8b73ad9a6886d7f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eb5257522f4ce7b8b73ad9a6886d7f6">&#9670;&nbsp;</a></span>TAL_smoothing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HMesh::TAL_smoothing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">HMesh::Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iter</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tangential area weighted smoothing. </p>

</div>
</div>
<a id="a31b22ab24a539fcdc8cd61d0eb4f735d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b22ab24a539fcdc8cd61d0eb4f735d">&#9670;&nbsp;</a></span>taubin_smooth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HMesh::taubin_smooth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">HMesh::Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iter</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Taubin smoothing is similar to laplacian smoothing but reduces shrinkage. </p>

</div>
</div>
<a id="a431da0c0266faa5d82323297fd9201d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431da0c0266faa5d82323297fd9201d7">&#9670;&nbsp;</a></span>triangulate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int HMesh::triangulate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FaceID&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TriangulationMethod&#160;</td>
          <td class="paramname"><em>policy</em> = <code>CLIP_EAR</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Triangulate by connected vertices on the face f. </p>
<p>The policy indicates if we do ear clip or shortest edge triangulation. ear clip is safer, but shortest edge tends to never fail. </p>

</div>
</div>
<a id="afa1e6d131ef5eff0745216277035bb46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa1e6d131ef5eff0745216277035bb46">&#9670;&nbsp;</a></span>triangulate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HMesh::triangulate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TriangulationMethod&#160;</td>
          <td class="paramname"><em>policy</em> = <code>CLIP_EAR</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Triangulate by connectin. </p>

</div>
</div>
<a id="a23a98d70f5fdfc2d216070e8733f9c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23a98d70f5fdfc2d216070e8733f9c62">&#9670;&nbsp;</a></span>valency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int HMesh::valency </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexID&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute valency, i.e. number of incident edges. </p>

</div>
</div>
<a id="a4d840744a37a7b0dfb45477157335b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d840744a37a7b0dfb45477157335b57">&#9670;&nbsp;</a></span>volume_polygonize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HMesh::volume_polygonize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1XForm.html">Geometry::XForm</a> &amp;&#160;</td>
          <td class="paramname"><em>xform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGeometry_1_1RGrid.html">Geometry::RGrid</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">HMesh::Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>mani</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_triangles</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>high_is_inside</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a polygonal mesh from a volumetric isocontour. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xform</td><td>is the transformation from voxel indices back to the domain of the implicit being polygonized. </td></tr>
    <tr><td class="paramname">grid</td><td>is the voxel grid. </td></tr>
    <tr><td class="paramname">mani</td><td>is the manifold into which the output mesh is written. </td></tr>
    <tr><td class="paramname">tau</td><td>is the threshold (or isovalue) </td></tr>
    <tr><td class="paramname">make_triangles</td><td>tells whether we output triangles (default: true) or quads (false) </td></tr>
    <tr><td class="paramname">high_is_inside</td><td>tells whether values greater than @tau (defalut: true) are interior or exterior </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing</dd></dl>
<p>This function computes an iso surface using the method of dual contouring. For each voxel that is inside, it visits the six neighbors and outputs a quad if that neighbor is outside. This leads to a cuberille mesh. Afterwards, vertices are smoothed and finally placed on the isocontour by using a line search in the direction of the vertex normal. Dual contouring is very simple and leads to bette triangles than marching cubes. On the flip side, the vertex placement is arguably a bit more ad hoc. </p>

</div>
</div>
<a id="aec98b3dedef5824df105fd919035f93c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec98b3dedef5824df105fd919035f93c">&#9670;&nbsp;</a></span>x3d_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HMesh::x3d_load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a mesh from an X3D file. It handles arbitrary polygons. </p>

</div>
</div>
<a id="a5cfd1ab9ac0990110d68417b33984557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cfd1ab9ac0990110d68417b33984557">&#9670;&nbsp;</a></span>x3d_save()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HMesh::x3d_save </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHMesh_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save mesh to x3d file. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
